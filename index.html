<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MedRec 2.0</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    /* Basic Layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      background-color: #007bff;
      color: white;
      text-align: center;
      padding: 0.5rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      height: 185px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      box-sizing: border-box;
    }
    main {
      flex: 1;
      padding: 1rem;
      max-width: 600px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .screen {
      display: none;
      width: 100%;
      text-align: center;
    }
    .screen.active {
      display: block;
    }
    /* Card Styling */
    .card {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid #ddd;
      padding: 1rem;
      margin: 0.5rem 0;
      width: 100%;
      box-sizing: border-box;
    }
    /* Buttons & Inputs */
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      margin: 0.5rem 0;
      cursor: pointer;
      border-radius: 15px;
      width: 100%;
      max-width: 300px;
      display: block;
      font-weight: 600;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: box-shadow 0.2s ease;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #0056b3;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    /* Hide native file inputs */
    input[type="file"] {
      display: none;
    }
    .photo-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      margin: 1rem 0;
      width: 100%;
    }
    .photo-actions button {
      width: 100%;
      max-width: 300px;
      margin: 0;
    }
    .disclaimer-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1rem 0;
      width: 100%;
    }
    .disclaimer-actions button {
      width: 100%;
      max-width: 300px;
    }
    .upload-instructions {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #555;
    }
    .upload-prompt {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #333;
    }
    .preview-container {
      text-align: center;
      margin: 0.5rem 0 1rem;
    }
    .thumbnail-container {
      position: relative;
      display: inline-block;
      margin: 0.25rem;
    }
    .thumbnail-container img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    /* ============== delete (close) chip ============== */
    .delete-btn {
      position: absolute;
      top: -6px;                   /* sticks out a little */
      right: -6px;
      width: 24px;                 /* exact circle */
      height: 24px;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #ff4d4d;         /* red chip */
      color: #fff;                 /* white ‚ÄúX‚Äù */
      font-size: 18px;             /* icon size */
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.25);
      transition: background .15s ease;
      padding: 0;                  /* override global button padding */
    }
    .delete-btn:hover {
      background: #d73838;         /* darker on hover */
    }
    /* make the glyph a touch smaller and centred */
    .delete-btn .material-icons {
      font-size: 18px;             /* icon ‚âà 75 % of circle */
      line-height: 1;
    }
    #error-message {
      color: red;
      text-align: center;
      margin: 1rem 0;
    }
    .critical {
      color: red;
      font-weight: bold;
    }
/* ========= New table styling ========== */
table.changes-table {
  width: auto;
  margin: 1rem auto;    /* center horizontally */
  border-collapse: collapse;
  font-size: 0.9rem;
}
/* allow horizontal scroll on narrow viewports */
#results-content {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
table.changes-table th,
table.changes-table td {
  border: 1px solid #ddd;
  padding: 0.5rem;
  text-align: left;
}
table.changes-table th {
  background-color: #f0f0f0;
}
/* Prevent splitting rows across PDF pages */
.changes-table,
.changes-table thead,
.changes-table tbody,
.changes-table tr,
.changes-table th,
.changes-table td {
  page-break-inside: avoid !important;
}


    .progress-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0.5rem 0;
      margin-top: -40px;
      position: relative;
    }
    .progress-step {
      width: 30px;
      height: 30px;
      background-color: #cccccc;
      border: 1px solid #999;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      transition: all 0.3s ease;
    }
    .progress-step.filled {
      background-color: #66b0ff;
      border: 1px solid #0056b3;
      color: white;
    }
    .progress-step.current {
      background-color: #007bff;
      border: 3px solid #0056b3;
      color: white;
    }
    .progress-line-container {
      position: absolute;
      top: 50%;
      left: 15px;
      right: 15px;
      height: 2px;
      z-index: 0;
      display: flex;
      justify-content: space-between;
    }
    .progress-line {
      flex: 1;
      height: 2px;
      background-color: #cccccc;
      margin: 0 5px;
    }
    .progress-line.filled {
      background-color: #66b0ff;
    }
    #loading {
      display: none;
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 0.5rem;
      text-align: center;
      z-index: 2000;
    }
    #loading-text {
      margin-bottom: 0.25rem;
    }
    #loading-progress {
      width: 80%;
      max-width: 300px;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin: 0.5rem 0;
    }
    h3 {
      margin-top: 1rem;
    }
    p.disclaimer-text {
      text-align: justify;
      max-width: 500px;
      margin: 0 auto;
    }
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: pointer;
      color: #007bff;
      margin-left: 5px;
      font-size: 0.9rem;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #333;
      color: white;
      text-align: center;
      border-radius: 5px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltip-text,
    .tooltip.active .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    #medrec-logo {
      height: 180px;
      width: auto;
      display: block;
      margin: 0 auto;
      position: relative;
      top: -10px;
      z-index: 1001;
    }
    /* New styles for text input */
    .text-input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      width: 100%;
    }
    textarea {
      width: 100%;
      max-width: 300px;
      height: 100px;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      resize: none;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
    }
    textarea:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    }
    
    @media print {
  /* hide everything but the results screen */
  header, button, .photo-actions, .progress-bar, #loading,
  .screen:not(#results-screen) {
    display: none !important;
  }
  #results-screen { display: block !important; }

  /* allow the table to grow and show all columns */
  #results-content {
    overflow: visible !important;
    -webkit-overflow-scrolling: auto !important;
    width: auto !important;
    margin: 0 !important;
  }
  table.changes-table {
    width: 100% !important;
    border-collapse: collapse !important;
  }
  table.changes-table th,
  table.changes-table td {
    border: 1px solid #ddd !important;
    padding: 8px !important;
  }
}

  </style>

</head>
<body>
  <header>
    <img src="MedRec%20Logo.png" alt="MedRec 2.0 Logo" id="medrec-logo">
    <div class="progress-bar">
      <div class="progress-line-container">
        <div class="progress-line" id="line1-2"></div>
        <div class="progress-line" id="line2-3"></div>
        <div class="progress-line" id="line3-4"></div>
      </div>
      <div class="progress-step" id="step1">1</div>
      <div class="progress-step" id="step2">2</div>
      <div class="progress-step" id="step3">3</div>
      <div class="progress-step" id="step4">4</div>
    </div>
  </header>
  <main>
    <div id="error-message"></div>
    <!-- Disclaimer Screen -->
    <div id="disclaimer-screen" class="screen active">
      <h2>Disclaimer</h2>
      <div class="card">
        <p class="disclaimer-text">
          <strong>HIPAA Warning: DO NOT UPLOAD IMAGES CONTAINING IDENTIFIABLE INFORMATION.</strong> This app is intended for use by personnel authorized to handle Protected Health Information (PHI). While MedRec 2.0 is a HIPAA compliant application, users are responsible for ensuring full compliance with HIPAA regulations, including safeguarding resident/patient data and restricting access to authorized personnel only. Unauthorized disclosure of PHI may result in disciplinary action and legal consequences.
<br><br>
          <em>Note:</em> MedRec 2.0 is a support tool and does not guarantee 100% accuracy in identifying medication discrepancies. Final verification must be completed by qualified clinical personnel.
        </p>
      </div>
      <div class="disclaimer-actions">
        <button onclick="acknowledgeDisclaimer()">I Understand</button>
      </div>
    </div>
    <!-- Photo 1 Screen -->
    <div id="photo1-screen" class="screen">
      <div class="card">
        <h2>Enter Medications Before Hospital Stay</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo1-options" class="photo-actions">
          <button onclick="document.getElementById('photo1-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo1-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo1-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput1()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo1-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo1-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo1-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo1-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-upload" accept="image/*" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto1(this.files)">
      <input type="file" id="photo1-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto1(this.files)">
      <div id="photo1-preview" class="preview-container"></div>
      <p id="photo1-status"></p>
      <p id="photo1-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo1-next" onclick="goToPhoto2()" disabled>Next</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Photo 2 Screen -->
    <div id="photo2-screen" class="screen">
      <div class="card">
        <h2>Enter Hospital Discharge Medications</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo2-options" class="photo-actions">
          <button onclick="document.getElementById('photo2-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo2-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo2-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput2()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo2-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo2-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo2-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo2-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-upload" accept="image/*" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto2(this.files)">
      <input type="file" id="photo2-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto2(this.files)">
      <div id="photo2-preview" class="preview-container"></div>
      <p id="photo2-status"></p>
      <p id="photo2-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo2-compare" onclick="comparePhotos()" disabled>Compare</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Results Screen -->
    <div id="results-screen" class="screen">
      <h2>Comparison Results</h2>
      <p>Changes listed in <span class="critical">bold red</span> are critical medications and should be reconciled with the provider within <span class="critical">4 hours</span> of discovery.</p>
      <div class="card">
        <div id="results-content"></div>
      </div>
      <div class="photo-actions">
                    <button onclick="exportToPDF()">Export as PDF</button>
        <button onclick="printResults()">Print Results</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
  </main>
  <div id="loading">
    <p id="loading-text">Processing...</p>
    <progress id="loading-progress" max="100"></progress>
  </div>
  <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-functions-compat.js"></script>
<script>
const firebaseConfig = {
  apiKey: "AIzaSyBYrJPALSB45rPm5D0T29rEwCdJ5Ek24ug",
  authDomain: "medrec-solutions-cd00e.firebaseapp.com",
  projectId: "medrec-solutions-cd00e",
  storageBucket: "medrec-solutions-cd00e.appspot.com",
  messagingSenderId: "276805089930",
  appId: "1:276805089930:web:9631c7d4cf223f1666d087"
};
const app = firebase.initializeApp(firebaseConfig);
const functions = firebase.functions(app);
</script>

  <script>
    const criticalMeds = [
      'warfarin', 'apixaban', 'rivaroxaban', 'dabigatran', 'edoxaban', 'heparin', 'enoxaparin',
      'clopidogrel', 'ticagrelor', 'prasugrel', 'insulin regular', 'insulin glargine', 'insulin detemir',
      'insulin lispro', 'insulin aspart', 'insulin degludec', 'glipizide', 'glyburide', 'glimepiride',
      'repaglinide', 'nateglinide', 'metformin', 'morphine', 'hydromorphone', 'oxycodone', 'fentanyl',
      'methadone', 'tramadol', 'codeine', 'buprenorphine', 'phenytoin', 'carbamazepine', 'valproic acid',
      'phenobarbital', 'lamotrigine', 'levetiracetam', 'digoxin', 'amiodarone', 'sotalol', 'diltiazem',
      'verapamil', 'metoprolol', 'atenolol', 'carvedilol', 'furosemide', 'bumetanide', 'torsemide',
      'spironolactone', 'hydrochlorothiazide', 'chlorthalidone', 'potassium chloride', 'magnesium sulfate',
      'calcium gluconate', 'calcium chloride', 'sodium bicarbonate', 'phosphate', 'hydralazine', 'clonidine',
      'isosorbide mononitrate', 'isosorbide dinitrate', 'nitroglycerin', 'haloperidol', 'risperidone',
      'olanzapine', 'quetiapine', 'aripiprazole', 'ziprasidone', 'lorazepam', 'diazepam', 'clonazepam',
      'temazepam', 'midazolam', 'zolpidem', 'prednisone', 'methylprednisolone', 'dexamethasone',
      'hydrocortisone', 'levothyroxine', 'liothyronine', 'tacrolimus', 'cyclosporine', 'mycophenolate',
      'azathioprine', 'vancomycin', 'gentamicin', 'tobramycin', 'amikacin', 'ciprofloxacin', 'levofloxacin',
      'moxifloxacin', 'azithromycin', 'clarithromycin', 'erythromycin', 'amoxicillin',
      'amoxicillin-clavulanate', 'ceftriaxone', 'cefepime', 'ceftazidime', 'cefdinir', 'cephalexin',
      'piperacillin-tazobactam', 'penicillin vk', 'dicloxacillin', 'nafcillin', 'meropenem', 'ertapenem',
      'imipenem-cilastatin', 'doxycycline', 'minocycline', 'tetracycline', 'linezolid',
      'sulfamethoxazole-trimethoprim', 'nitrofurantoin', 'metronidazole', 'clindamycin', 'fosfomycin',
      'daptomycin', 'tigecycline', 'carbidopa/levodopa', 'entacapone', 'selegiline', 'rasagiline', 'lithium',
      'theophylline', 'clozapine', 'methotrexate', 'allopurinol', 'colchicine', 'tamsulosin', 'finasteride',
      'denosumab', 'zoledronic acid', 'teriparatide', 'alendronate', 'risedronate', 'acetazolamide',
      'bethanechol', 'bethanechol chloride', 'donepezil', 'rivastigmine', 'galantamine', 'memantine',
      'naltrexone', 'naloxone', 'flumazenil', 'desmopressin', 'octreotide', 'erythropoietin', 'filgrastim',
      'calcitriol', 'ergocalciferol', 'cholecalciferol', 'pyridostigmine', 'propranolol', 'labetalol',
      'isosorbide', 'nicardipine', 'nitroprusside', 'ivabradine', 'sacubitril', 'valsartan',
      'atorvastatin', 'rosuvastatin', 'simvastatin', 'Norco', 'oxycodone/acetaminophen', 'hydrocodone/acetaminophen', 'codeine/acetaminophen', 'tramadol/acetaminophen', 'acetaminophen/caffeine/dihydrocodeine', 'aspirin/caffeine/dihydrocodeine', 'aspirin/codeine', 'ibuprofen/oxycodone', 'acetaminophen/butalbital/caffeine', 'aspirin/butalbital/caffeine', 'acetaminophen/butalbital', 'methylphenidate', 'amphetamine/dextroamphetamine', 'hydrocodone/pseudoephedrine', 'hydrocodone/chlorpheniramine', 'hydrocodone/homatropine', 'busulfan', 'doxorubicin', 'adalimumab', 'acetaminophen/isometheptene/dichloralphenazone', 'ultracet', 'percocet', 'roxicet', 'endocet', 'tylenol #3', 'zamicet', 'vicodin', 'lortab', 'panlor ss', 'trezix', 'synalgos-dc', 'empirin with codeine', 'combunox', 'fioricet', 'esgic', 'zebutal', 'fiorinal', 'bupap', 'rezira', 'tussionex', 'hycomine', 'hydromet', 'midrin','chlorpropamide', 'acarbose', 'miglitol', 'argatroban', 'bivalirudin', 'fondaparinux', 'methylergonovine', 'carboplatin', 'cyclophosphamide', 'promethazine'

    ].map(med => med.toLowerCase());

    const commonMedications = [
      { generic: "hydrocodone/acetaminophen", brands: ["Norco", "Vicodin", "Lortab", "Zamicet"] },
      { generic: "oxycodone/acetaminophen",  brands: ["Percocet", "Xartemis XR", "Roxicet", "Endocet"] },
               { generic: "codeine/acetaminophen",     brands: ["Tylenol #3"] },
               { generic: "tramadol/acetaminophen",    brands: ["Ultracet"] },
               { generic: "acetaminophen/caffeine/dihydrocodeine", brands: ["Panlor SS", "Trezix"] },
               { generic: "aspirin/caffeine/dihydrocodeine",       brands: ["Synalgos-DC"] },
               { generic: "aspirin/codeine",            brands: ["Empirin with codeine"] },
               { generic: "acetaminophen/butalbital/caffeine", brands: ["Fioricet", "Esgic", "Zebutal"] },
               { generic: "aspirin/butalbital/caffeine", brands: ["Fiorinal"] },
               { generic: "acetaminophen/butalbital",   brands: ["Bupap"] },
               { generic: "hydrocodone/pseudoephedrine", brands: ["Rezira"] },
               { generic: "hydrocodone/chlorpheniramine", brands: ["Tussionex", "Hycomine"] },
               { generic: "hydrocodone/homatropine",    brands: ["Hydromet"] },
               { generic: "busulfan",                   brands: ["Myleran"] },
               { generic: "acetaminophen/isometheptene/dichloralphenazone", brands: ["Midrin"] },
               { generic: "ibuprofen/oxycodone",        brands: ["Combunox"] },
      { generic: "acetaminophen", brands: ["Tylenol"] },
      { generic: "albuterol", brands: ["Ventolin", "ProAir", "Proventil", "salbutamol"] },
      { generic: "allopurinol", brands: ["Zyloprim"] },
      { generic: "alprazolam", brands: ["Xanax"] },
      { generic: "amlodipine", brands: ["Norvasc"] },
      { generic: "amoxicillin", brands: ["Amoxil", "Trimox"] },
      { generic: "aspirin", brands: ["Bayer", "Ecotrin"] },
      { generic: "atenolol", brands: ["Tenormin"] },
      { generic: "atorvastatin", brands: ["Lipitor"] },
      { generic: "azithromycin", brands: ["Zithromax", "Z-Pak"] },
      { generic: "bisoprolol", brands: ["Zebeta"] },
      { generic: "budesonide", brands: ["Pulmicort", "Rhinocort"] },
               {   generic: "calcium gluconate",  brands: [] },
               {   generic: "calcium chloride",   brands: [] },
               {   generic: "calcium carbonate",  brands: [] },
               {   generic: "calcium citrate",    brands: [] }, 
      { generic: "cefuroxime", brands: ["Ceftin", "Zinacef"] },
      { generic: "cephalexin", brands: ["Keflex"] },
      { generic: "cetirizine", brands: ["Zyrtec"] },
      { generic: "ciprofloxacin", brands: ["Cipro"] },
      { generic: "citalopram", brands: ["Celexa"] },
      { generic: "clindamycin", brands: ["Cleocin"] },
      { generic: "clonazepam", brands: ["Klonopin"] },
      { generic: "clopidogrel", brands: ["Plavix"] },
      { generic: "cyclobenzaprine", brands: ["Flexeril"] },
      { generic: "digoxin", brands: ["Lanoxin"] },
      { generic: "doxycycline", brands: ["Vibramycin"] },
      { generic: "duloxetine", brands: ["Cymbalta"] },
      { generic: "enalapril", brands: ["Vasotec"] },
      { generic: "escitalopram", brands: ["Lexapro"] },
      { generic: "esomeprazole", brands: ["Nexium"] },
      { generic: "ferrous sulfate", brands: [] },
      { generic: "fluoxetine", brands: ["Prozac"] },
      { generic: "fluticasone", brands: ["Flonase", "Flovent"] },
      { generic: "furosemide", brands: ["Lasix"] },
      { generic: "gabapentin", brands: ["Neurontin"] },
      { generic: "glipizide", brands: ["Glucotrol"] },
      { generic: "glyburide", brands: ["Diabeta", "Micronase"] },
      { generic: "hydralazine", brands: ["Apresoline"] },
      { generic: "hydrochlorothiazide", brands: ["Microzide"] },
      { generic: "ibuprofen", brands: ["Advil", "Motrin"] },
      { generic: "insulin glargine", brands: ["Lantus", "Basaglar"] },
      { generic: "insulin lispro", brands: ["Humalog"] },
      { generic: "irbesartan", brands: ["Avapro"] },
      { generic: "isosorbide mononitrate", brands: ["Imdur"] },
      { generic: "ketorolac", brands: ["Toradol"] },
      { generic: "levothyroxine", brands: ["Synthroid", "Levoxyl"] },
      { generic: "lisinopril", brands: ["Prinivil", "Zestril"] },
      { generic: "lorazepam", brands: ["Ativan"] },
      { generic: "losartan", brands: ["Cozaar"] },
      { generic: "melatonin", brands: [] },
      { generic: "meloxicam", brands: ["Mobic"] },
      { generic: "metformin", brands: ["Glucophage"] },
      { generic: "methotrexate", brands: ["Trexall"] },
      { generic: "metoprolol", brands: ["Lopressor", "Toprol XL"] },
      { generic: "montelukast", brands: ["Singulair"] },
      { generic: "naproxen", brands: ["Aleve", "Naprosyn"] },
      { generic: "nifedipine", brands: ["Procardia", "Adalat"] },
      { generic: "nystatin", brands: ["Mycostatin"] },
      { generic: "omeprazole", brands: ["Prilosec"] },
      { generic: "oxycodone", brands: ["OxyContin", "Roxicodone"] },
      { generic: "pantoprazole", brands: ["Protonix"] },
               {   generic:    "polyethylene glycol",  brands: ["MiraLAX","GaviLAX","GlycoLax","PEG 3350"] },
      { generic: "pravastatin", brands: ["Pravachol"] },
      { generic: "prednisone", brands: ["Deltasone"] },
      { generic: "propranolol", brands: ["Inderal"] },
      { generic: "quinapril", brands: ["Accupril"] },
      { generic: "ranitidine", brands: ["Zantac"] },
      { generic: "rosuvastatin", brands: ["Crestor"] },
      { generic: "sertraline", brands: ["Zoloft"] },
      { generic: "simvastatin", brands: ["Zocor"] },
      { generic: "sitagliptin", brands: ["Januvia"] },
      { generic: "sotalol", brands: ["Betapace"] },
      { generic: "spironolactone", brands: ["Aldactone"] },
      { generic: "sulfamethoxazole-trimethoprim", brands: ["Bactrim", "Septra"] },
      { generic: "tamsulosin", brands: ["Flomax"] },
      { generic: "tramadol", brands: ["Ultram"] },
      { generic: "trazodone", brands: ["Desyrel"] },
      { generic: "valacyclovir", brands: ["Valtrex"] },
      { generic: "valproic acid", brands: ["Depakene"] },
      { generic: "venlafaxine", brands: ["Effexor"] },
      { generic: "verapamil", brands: ["Calan", "Verelan"] },
      { generic: "warfarin", brands: ["Coumadin"] },
      { generic: "zolpidem", brands: ["Ambien"] },
      { generic: "amphetamine/dextroamphetamine", brands: ["Adderall", "Adderall XR"] },
      { generic: "alendronate", brands: ["Fosamax"] },
      { generic: "tadalafil", brands: ["Cialis"] },
      { generic: "fluticasone/umeclidinium/vilanterol", brands: ["Trelegy"] },
      { generic: "empagliflozin", brands: ["Jardiance"] },
      { generic: "semaglutide", brands: ["Ozempic", "Wegovy"] },
      { generic: "vitamin d", brands: ["Drisdol"] },
      { generic: "prednisolone", brands: ["Pred Forte"] },
      { generic: "enoxaparin", brands: ["Lovenox", "Clexane"] },
      { generic: "doxorubicin", brands: ["Adriamycin"] },
      { generic: "adalimumab", brands: ["Humira"] },
      { generic: "rivaroxaban", brands: ["Xarelto"] },
      { generic: "methylphenidate", brands: ["Ritalin", "Concerta"] },
      { generic: "memantine", brands: ["Namenda"] },
      { generic: "isosorbide", brands: [] },
      { generic: "isosorbide dinitrate", brands: [] }
    ];
	// ‚Äî‚Äî‚Äî Map every brand name to its generic ‚Äî‚Äî‚Äî
    const brandToGenericMap = {};
    commonMedications.forEach(({ generic, brands }) => {
      brands.forEach(brand => {
        brandToGenericMap[brand.toLowerCase()] = generic.toLowerCase();
      });
    });

    // ‚Äî‚Äî‚Äî Map every generic to its brands ‚Äî‚Äî‚Äî
    const genericToBrandMap = {};
    Object.entries(brandToGenericMap).forEach(([brand, generic]) => {
      if (!genericToBrandMap[generic]) genericToBrandMap[generic] = [];
      genericToBrandMap[generic].push(brand);
    });

    const unitVariants = {
  tablet:   ['tab','tabs','tablet','tablets','tab.','tablet.'],
  capsule:  ['cap','caps','capsule','capsules','caplet','cap.','gelcap','softgel','gel','sprinkle','sprinkles'],
  spray:    ['spray','sprays'],
  puff:     ['puff','puffs'],
  drop:     ['drop','drops','gtt','gtts','gt','drp'],
  patch:    ['patch','patches','transdermal patch'],
  injection:['shot','syringe','pen','inj','auto-injector'],
  lozenge:  ['lozenge','loz','troche'],
  suppository:['supp','suppositories'],
  solution: ['solution','sol','liq','liquid','oral sol'],
  ointment: ['ointment','oint','ung','cream','gel'],
  inhalation:['inhaler','inh','neb','nebulizer','mdi','dpi'],
  unit:     ['U','IU','units'],
  mL:       ['ml','mL','cc'],
  mcg:      ['Œºg','mcg','ug'],
  mg:       ['mg'],
  g:        ['g','gram','grams']
};


    let photo1Files = [];
    let photo2Files = [];
    let meds1 = [], meds2 = [];
    let hasTextInput1 = false; // Track if Photo 1 used text input
    let hasTextInput2 = false; // Track if Photo 2 used text input

    async function processFiles(files) {
      let allText = "";
      let lowConfidence = false;
      for (let file of files) {
        try {
          const result = await processFile(file);
//=== STEP 2  cleaned with keepOrderLines
const cleaned = keepOrderLines(result.text);
allText += "\n" + cleaned.join("\n");
//=== END STEP 2

          if (result.confidence < 0.8) {
            lowConfidence = true;
          }
        } catch (err) {
          console.error("Error processing file: ", err);
        }
      }
      if (lowConfidence) {
        showError("Warning: Some text was unclear and may not be accurate. Please review manually.");
      }
      return allText;
    }

function processFile(file) {
  return new Promise((resolve, reject) => {
    if (!file) {
      console.error('No file provided to processFile');
      reject(new Error("No file provided"));
      return;
    }
    console.log('Processing file:', file.name, file.type, file.size);
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        if (!e.target.result) {
          console.error('FileReader result is undefined');
          throw new Error('FileReader result is undefined');
        }
        const imageData = e.target.result;
        console.log('Sending image data:', imageData.substring(0, 100));
        const payload = { data: { image: imageData } };
        console.log('Payload being sent:', payload);
        const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
        const response = await callOcrFunction(payload);
        console.log('Received response from callOcrTest:', response);
        if (!response.data || typeof response.data !== 'object') {
          throw new Error('Invalid response from OCR function');
        }
        resolve(response.data);
      } catch (err) {
        console.error('Error in processFile:', err);
        reject(err);
      }
    };
    reader.onerror = () => {
      console.error('FileReader error:', reader.error);
      reject(new Error("File could not be read: " + reader.error));
    };
    reader.readAsDataURL(file);
  });
}
async function testCallOcr() {
  try {
    const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
    const payload = { data: { test: "Hello, world!" } };
    console.log('Testing callOcrTest with payload:', payload);
    const response = await callOcrFunction(payload);
    console.log('Test response from callOcrTest:', response);
  } catch (err) {
    console.error('Error in testCallOcr:', err);
  }
}
//=== STEP 1  keepOrderLines helper =========================
function keepOrderLines(rawText) {
  const DEBUG_JUNK = false;   // flip to true to see what you drop

//=== STEP‚ÄëSPLITMULTI  ‚¨áÔ∏é break ‚ÄúA ‚Ä¶ B ‚Ä¶‚Äù lines into two =================
rawText = rawText
  .replace(/\s{2,}/g, '\n')               // two+ spaces  ‚Üí new line
  .replace(/(?:,|;|\band\b)/gi, '\n');    // commas/‚Äúand‚Äù ‚Üí new line
//=== END STEP‚ÄëSPLITMULTI =================================================

  return rawText
    .split(/\r?\n+/)                 // ‚Üí separate lines
    .map(line => cleanLine(line))    // ‚Üí trim weird endings
  .flatMap(splitConcatOrders)      // ‚Üí split ‚Äúlisinopril ‚Ä¶ polyethylene ‚Ä¶‚Äù
    .filter(line => {
      const keep =
        isLikelyOrderLine(line) &&   // letters + numbers?
       ( containsKnownMedication(line) ||    // ‚Üñ try drug list first
         /\d+\s*(mg|mcg|g|mL|units|tablet|capsule|puff|drop)\b/i.test(line) )
        && /\d/.test(line);          // must still have a digit
      if (!keep && DEBUG_JUNK) console.log('üóëÔ∏è', line);
      return keep;
    });
}
//=== END STEP 1 ============================================

    function cleanLine(line) {
  	// 1) drop any ‚Äúnumber.‚Äù or ‚Äúnumber)‚Äù at the start
  	line = line.replace(/^\s*\d+[\.\)]\s*/, '');
  	// 2) remove trailing non-alphanumeric junk and trim
  	return line.replace(/[^a-z0-9]+$/i, '').trim();
}


// ‚Äî‚Äî‚Äî remove trailing junk from merged lines ‚Äî‚Äî‚Äî
function pruneLine(line) {
  // keep dose ‚Üí form ‚Üí route ‚Üí freq ‚Üí PRN ‚Üí ‚Äúfor ‚Ä¶ pain‚Äù or ‚Äúmoderate pain‚Äù
  // only strip off trailing garbage like ‚Äú;‚Äù or OCR noise, but preserve any
  // remaining words (e.g. ‚Äúfor hypertension‚Äù or ‚Äúheart failure‚Äù)
  return line.trim();
 }

    function isLikelyOrderLine(line) {
      //=== STEP 3  stricter test
if (line.length < 5) return false;
const good = (line.match(/[a-z0-9]/gi) || []).length;
return good / line.length >= 0.5;
//=== END STEP 3
    }

function containsKnownMedication(line) {
  const lower = line.toLowerCase();

  // 1) Critical meds always match
  if (criticalMeds.some(med => lower.includes(med))) return true;

  // 2) Any brand name in commonMedications also counts
  if (commonMedications.some(m =>
        m.brands.some(b => lower.includes(b.toLowerCase()))
      )) return true;

  // 3) Generic names or dose patterns as before
  return commonMedications.some(med => lower.includes(med.generic))
      || /\d+\s*(?:mg|mcg|units|puffs|tabs?|tablets?|capsules?)\b/.test(lower);
}

    function normalizeText(str) {
  let text = str.toLowerCase()
  .replace(
    /\b(\d+)\s*[x√ó]\s*(?:\/|per)\s*(?:day|daily)\b/gi,
    (match, n) => ({
      '1':'once daily','2':'twice daily','3':'three times daily',
      '4':'four times daily','5':'five times daily','6':'six times daily',
      '7':'seven times daily','8':'eight times daily','9':'nine times daily',
      '10':'ten times daily'
    }[n] || match)
  )
    .replace(
     /\bevery\s*(\d+)\s*hours?\s+as\s*needed\b/gi,
      (_, n) => `q${n}h prn`
  )


    // common shorthand ‚Üí full text
    .replace(/\bsob\b/gi, 'shortness of breath')
    .replace(/\bnpo\b/g, 'nothing by mouth')
    .replace(/\bac\b/g, 'before meals')
    .replace(/\bpc\b/g, 'after meals')
    .replace(/\bhs\b/g, 'at bedtime')
    .replace(/\bqod\b/g, 'every other day')
    .replace(/\bq(\d+)h\b/g, 'every $1 hours')
    .replace(/\btid\b/g, 'three times daily')
    .replace(/\bqid\b/g, 'four times daily')

    // ‚Äî‚Äî‚Äî additional frequency normalizations ‚Äî‚Äî‚Äî
    .replace(/\bevery\s*day\b/g,         'daily')
    .replace(/\bper\s*day\b/g,           'daily')
    .replace(/\bdaily\b/g,               'daily')
    .replace(/\bonce\s*(?:a|per)?\s*(?:day|daily)\b/gi, 'daily')

    .replace(/\btwice\s*(?:a|per)?\s*day\b/g, 'twice daily')
    .replace(/\bbi-?daily\b/g,               'twice daily')

    .replace(/\bthree\s*times?\s*(?:a|per)?\s*day\b/g, 'three times daily')
    .replace(/\bt\.?i\.?d\.?\b/g,                       'three times daily')

    .replace(/\bfour\s*times?\s*(?:a|per)?\s*day\b/g, 'four times daily')
    // (you already handle ‚Äúqid‚Äù above)

    .replace(/\bqhs\b/g,                 'at bedtime')
    .replace(/\b(?:nightly|at night)\b/g, 'at bedtime')

    .replace(/\bevery\s*morning\b/g,     'every morning')
    .replace(/\bevery\s*evening\b/g,     'every evening')

    .replace(/\bas\s*needed\b/g,         'prn')
    .replace(/\bas\s*required\b/g,       'prn')

    .replace(/\bnow\b/g,      'immediately')
    .replace(/\bstat\b/g,     'immediately')
    .replace(/\bevery\s*(\d+)\s*hrs?\b/gi, 'q$1h')
    .replace(/\bq(\d+)\s*hr?s?\b/gi,       'q$1h')
    .replace(/\beach\s*day\b/gi,           'daily')
    .replace(/\bprn\s*(?:as\s*)?/gi,       'prn ')
    .replace(/\bhs\b/gi,                   'at bedtime')
    .replace(/\btab\.?\b/gi, 'tablet')
    .replace(/\bcap\.?\b/gi, 'capsule')


    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî


    // your original word-to-digit and cleanup steps
.replace(/\bone\b(?!\s+times)/g,   '1')
.replace(/\bonce\s*daily\b/gi, 'daily')
.replace(/\btwo\b(?!\s+times)/g,   '2')
.replace(/\bthree\b(?!\s+times)/g, '3')
.replace(/\bfour\b(?!\s+times)/g,  '4')
.replace(/\bfive\b(?!\s+times)/g,  '5')


  return text
    .replace(/p\.?o\.?/g, 'po')
    .replace(/\bby mouth\b/g, 'po')
    .replace(/q\.?d\.?/g, 'daily')
    .replace(/b\.?i\.?d\.?/g, 'twice daily')
    .replace(/\bqhs\b/g, 'at bedtime')
    .replace(/\bq\s*a\.?m\.?\b/g, 'every morning')
    .replace(/\bq\s*p\.?m\.?\b/g, 'every evening')
    .replace(/\bevery night\b/g, 'at bedtime')
    .replace(/hrs/g, 'hours')
    .replace(/Œºg/g, 'mcg')
    .replace(/ml/g, 'mL')
    .replace(/[^\w\s\/.\-]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

/* ---------- break a single line that actually contains TWO orders ---------- */
function splitConcatOrders(line){
  // look for the 1st complete dose‚Äëand‚Äëfrequency pattern,
  // then decide if the tail of the line is a new drug
  const freqTok = /\b(?:daily|at bedtime|every [^\s]+|q\d+h|bid|tid|qid)\b/ig;
  let m;
  while ((m = freqTok.exec(line)) !== null) {
    const tail = line.slice(m.index + m[0].length);
    if (/\b\d+\s*(?:mg|mcg|g|tablet[s]?|capsule[s]?|puff[s]?|drop[s]?)\b/i.test(tail)){
      return [ line.slice(0, m.index + m[0].length).trim(),
               tail.trim() ];
    }
  }
  return [ line ];          // nothing to split ‚Üí return original line
}

// ‚îÄ‚îÄ new helper: merge continuation lines into the previous order ‚îÄ‚îÄ
function mergeMultiLineOrders(lines) {
  const merged = [];
  lines.forEach(line => {
    if (containsKnownMedication(line)) {
      // a true order ‚Üí start new entry
      merged.push(line);
    } else if (merged.length) {
      // continuation ‚Üí append to last entry
      merged[merged.length - 1] += ' ' + line;
    } else {
      // fallback if first lines aren‚Äôt detected as orders
      merged.push(line);
    }
  });
  return merged;
}

/**
 * Turn any raw order line into its canonical generic name
 * so we can group ‚Äúday 1 prednisone‚Äù and ‚Äúday 2 Prednisone.‚Äù
 */
function normalizeMedicationName(name) {
  if (!name) return "";
  const lowerName = name.toLowerCase();
  for (let med of criticalMeds) {
    if (lowerName.includes(med)) return med;
  }
  for (const { generic, brands } of commonMedications) {
    if (lowerName.includes(generic)) return generic;
    if (brands.some(b => lowerName.includes(b.toLowerCase()))) {
      return generic;
    }
  }
  return lowerName;
}

/**
 * Collapse any ‚ÄúDay X ‚Ä¶ <drug> ‚Ä¶‚Äù lines into one ‚Äúpack‚Äù order.
 */
function mergeTaperPackOrders(lines) {
  const packs = {};
  const standalone = [];

  lines.forEach(line => {
    // normalize drug name for grouping, e.g. ‚Äúprednisone‚Äù
    const drugKey = normalizeMedicationName(line);
    // detect ‚ÄúDay N‚Äù prefix
    if (/\bday\s*\d+\b/i.test(line) && drugKey) {
      packs[drugKey] = packs[drugKey] || [];
      packs[drugKey].push(line.trim());
    } else {
      standalone.push(line);
    }
  });

  // build result: all non-pack lines + one joined string per pack
  const result = standalone.slice();
  Object.values(packs).forEach(packLines => {
    result.push(packLines.join('; '));
  });
  return result;
}

/* ---------- helper: are these the SAME DRUG? --------- */
function sameDrugName(a, b){
  return normalizeMedicationName(a.parsed?.drug || a.drug) ===
         normalizeMedicationName(b.parsed?.drug || b.drug);
}

// ======= New helper to describe what changed ========
function getChangeReason(orig, updated) {
  /* 1) early guard rails */
  if (!orig || !updated) return 'Misc. Change';

  // ---- QUICK EXIT for taper‚Äë/burst packs --------------------------
  if (/\bday\s*\d+\b/i.test(orig.drug) || /\bday\s*\d+\b/i.test(updated.drug)) {
    return 'Multiple changes';
  }
  // -----------------------------------------------------------------


  /* 2) helpers */
  const norm   = (s = '') => s.toLowerCase().trim().replace(/\s+/g, ' ');
  // treat "", "daily", "q24h" all as "daily"
  const canon = f => {
    f = norm(f);
    return (f === '' || f === 'daily' || f === 'q24h') ? 'daily' : f;
  };
  // ---- helper: treat blank¬†vs¬†filled as ‚Äúsame‚Äù ----
  const sameOrBlank = (a, b) => {
  return a === b || !a || !b;   // true if identical OR either side empty
  };


  /* 3) Check for specific single changes first */

/* 3‚Äëa) Time‚Äëof‚Äëday change ONLY */
const isOnlyTimeOfDayChanged = (
  norm(orig.timeOfDay) !== norm(updated.timeOfDay) &&          // TOD differs
  canon(orig.frequency) === canon(updated.frequency) &&        // same freq
  (orig.dose?.value === updated.dose?.value &&                 // same dose
   orig.dose?.unit  === updated.dose?.unit) &&
  sameOrBlank(norm(orig.form),  norm(updated.form)) &&         // form blank‚Äësafe
  sameOrBlank(norm(orig.route), norm(updated.route)) &&        // route blank‚Äësafe
  orig.prn === updated.prn &&                                  // same PRN flag
  norm(orig.indication) === norm(updated.indication)           // same indication
);
if (isOnlyTimeOfDayChanged) return 'Time of day changed';

  let changes = [];
  const add = label => { if (!changes.includes(label)) changes.push(label); };

/* 3‚Äëb) Brand¬†‚Üî¬†Generic swap
   ‚Äë‚Äë¬†only when one string contains a **known brand name**
   ‚Äë‚Äë¬†AND the other contains its generic.
*/
{
  const genA = normalizeMedicationName(orig.drug);
  const genB = normalizeMedicationName(updated.drug);

  if (genA === genB) {                       // both map to same generic
    const isBrandA = brandToGenericMap[norm(orig.drug)];
    const isBrandB = brandToGenericMap[norm(updated.drug)];
    // exactly one side is a recognised brand
    if ( Boolean(isBrandA) !== Boolean(isBrandB) ) {
      add('Brand/Generic changed');
    }
  }
}


/* -----------------------------------------------------------
   3‚Äëc) Dose
   ‚Äî Flag dose differences UNLESS both orders are clearly
     ‚Äúinhaled‚Äù (neb, inhaler, MDI, DPI, puffs‚Ä¶)
     ‚Üí those already raise Form / Route alerts and a second
       ‚ÄúDose changed‚Äù just clutters the report.
----------------------------------------------------------- */
const isInhaledOrder = o => {
  const f = norm(o.form);
  const r = norm(o.route);
  return /inhal|puff|neb|mdi|dpi/.test(f) || /inhal/.test(r);
};

  // 3-c) Dose ‚Äî allow tiny diffs once everything is in mg
  const sameUnit = (orig.dose?.unit ?? '') === (updated.dose?.unit ?? '');
  const sameValue = sameUnit &&
    Math.abs((orig.dose?.value || 0) - (updated.dose?.value || 0)) < 0.001;
  if (!sameValue && !(isInhaledOrder(orig) && isInhaledOrder(updated))) {
    add('Dose changed');
  }


  /* 3-d) Frequency ------------------------------------------- */
  const fA = canon(orig.frequency);     // ‚Üê already normalised
  const fB = canon(updated.frequency);    // ‚Üê
  if (fA !== fB) {
    /* ---- real vs phantom change? ----
        If one side is blank / ‚Äúq24h‚Äù / ‚Äúdaily‚Äù (all canon ‚Üí ‚Äúdaily‚Äù)
        and the other is also ‚Äúdaily‚Äù, that is *not* a genuine change.
     */
    const trivial =
      (fA === 'daily' && fB === 'daily');

    if (!trivial) add('Frequency changed');
  }


  /* 3‚Äëe) Time‚Äëof‚Äëday */
if (norm(orig.timeOfDay) !== norm(updated.timeOfDay)) {
  add('Time of day changed');
}

/* 3‚Äëf) Form / Route  ‚Äì¬†normal case = both sides present & different,
         BUT raise a flag if an inhaled form/route appears on one side only */
const isInhalWord = s => /inhal|puff|neb|mdi|dpi/i.test(norm(s || ''));

/* --- FORM --- */
if (norm(orig.form) !== norm(updated.form)) {
  add('Form changed');
}


/* --- ROUTE --- */
if (
  (orig.route && updated.route && norm(orig.route) !== norm(updated.route)) ||
  (/inhal/i.test(norm(orig.route || '')) !== /inhal/i.test(norm(updated.route || '')))  // ‚Üê NEW
) {
  add('Route changed');
}

/* 3‚Äëg) PRN flag */
if (orig.prn !== updated.prn) {
  add('PRN changed');
}

  /* 3-h) Indication */
  if (norm(orig.indication) !== norm(updated.indication)) {
    add('Indication changed');
  }

    /* 4) Demote bogus ‚ÄúFrequency changed‚Äù when it‚Äôs just a TOD tweak */
  if (
    changes.includes('Frequency changed') &&
    changes.includes('Time of day changed') &&
    canon(orig.frequency) === 'daily' &&
    canon(updated.frequency) === 'daily'
  ) {
    changes = changes.filter(c => c !== 'Frequency changed');
  }

  /* 4‚Äëb) Collapse the inhaler double‚Äëhit
          (we don‚Äôt want both ‚ÄúForm changed‚Äù **and** ‚ÄúRoute changed‚Äù
          for the same inhaler swap)                              */
  if (
    changes.includes('Form changed') &&
    changes.includes('Route changed')
  ) {
    // keep one ‚Äî here we keep ‚ÄúForm changed‚Äù
    changes = changes.filter(c => c !== 'Route changed');
  }

  /* 5) final decision */
  if (changes.length === 0)  return 'Misc. Change';
  if (changes.length === 1)  return changes[0];
  return 'Multiple changes';
}


    function parseOrder(orderStr) {
      orderStr = orderStr.replace(/[\u2010\u2011\u2012\u2013\u2014\u2015\u2212]/g, '-');
      orderStr = normalizeText(orderStr);
  
let order = {
  drug: "",
  dose: { value: null, unit: '', total: null },
  route: "",
  frequency: "",
  timeOfDay: "",
     administration: "",
  prn: false,
  form: "",
  indication: ""
};

// ‚Äî‚Äî‚Äî EXTRACT TIME-OF-DAY ‚Äî‚Äî‚Äî
{
  const todMatch = orderStr.match(
/\b(?:in the\s*)?(each\s*(morning|evening|night)|every\s*(morning|evening)|at\s*bedtime|bedtime|night|morning|evening)\b/i
  );
  if (todMatch) {
    // todMatch[1] will catch "every evening" or "at bedtime"; fallback to todMatch[0] otherwise
    let phrase = (todMatch[1] || todMatch[0]).toLowerCase();
    // strip leading "every " or "at "
    phrase = phrase.replace(/^every\s*/, '').replace(/^at\s*/, '');
    order.timeOfDay = phrase;      // e.g. "evening" or "bedtime"
    orderStr = orderStr.replace(todMatch[0], '').trim();
  }
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ TRACK ADMINISTRATION (with/without X) ‚îÄ‚îÄ‚îÄ
{
  const adminMatch = orderStr.match(
    /\b(?:with|w\/)\s*(meals|water|juice|liquid)\b|\b(?:without|w\/o)\s*(meals|water|juice|liquid)\b/i
  );
  if (adminMatch) {
    // determine ‚Äúwith‚Äù vs ‚Äúwithout‚Äù
    const prefix = adminMatch[0].toLowerCase().startsWith('with') ? 'with ' : 'without ';
    // capture the noun (meals, water, etc.)
    const noun = (adminMatch[1] || adminMatch[2] || '').toLowerCase();
    order.administration = prefix + noun;   // e.g. ‚Äúwith meals‚Äù or ‚Äúwithout water‚Äù
    // strip it out so it won‚Äôt interfere with later parsing
    orderStr = orderStr.replace(adminMatch[0], '').trim();
  }
}

// ‚îÄ‚îÄ extra normalizations that need the `order` object ‚îÄ‚îÄ
// weight-based dosing (mg/kg)
const weightMatch = orderStr.match(/(\d+(?:\.\d+)?)\s*mg\/kg\b/i);
if (weightMatch) {
  order.dose = { value: parseFloat(weightMatch[1]), unit: 'mg/kg', total: null };
  orderStr = orderStr.replace(weightMatch[0], '').trim();
}
// duration: x3d ‚Üí for 3 days
orderStr = orderStr.replace(/\bx(\d+)d\b/ig, 'for $1 days');
// #60 ‚Üí quantity 60
orderStr = orderStr.replace(/#(\d+)/g, 'quantity $1');
// fix common typos
orderStr = orderStr.replace(/\btablt\b/ig, 'tablet');
orderStr = orderStr.replace(/\bcaps\b/ig, 'capsule');

// ‚Äî‚Äî‚Äî TRACK PRN FLAG ‚Äî‚Äî‚Äî
if (/\bprn\b/i.test(orderStr)) {
  order.prn = true;
  orderStr = orderStr.replace(/\bprn\b/i, '').trim();
}

// ‚Äî‚Äî‚Äî TRACK PAIN INDICATION ‚Äî‚Äî‚Äî
// capture **any** adjective(s) before ‚Äúpain‚Äù (eg. ‚Äúchronic pain‚Äù, ‚Äúsevere acute pain‚Äù)

const indicMatch = orderStr.match(
  /\b(?:for\s+)?((?:[a-zA-Z]+(?:\s+[a-zA-Z]+)*)?)\s*pain\b/i
);
if (indicMatch) {
  // group 1 is everything before ‚Äúpain‚Äù, possibly empty
  const qualifier = indicMatch[1].trim();   // e.g. "chronic", "severe acute", or ""
  order.indication = qualifier
    ? qualifier.toLowerCase() + " pain"
    : "pain";
  // remove the matched phrase (e.g. ‚Äúchronic pain‚Äù or just ‚Äúpain‚Äù)
  orderStr = orderStr.replace(indicMatch[0], "").trim();
}

// ‚Äî‚Äî‚Äî TRACK RESPIRATORY INDICATION (shortness‚ÄØof‚ÄØbreath / ‚ÄúSOB‚Äù) ‚Äî‚Äî‚Äî
if (!order.indication) {
  // note: ‚ÄúSOB‚Äù is already expanded to ‚Äúshortness of breath‚Äù in normalizeText()
  const sobMatch = orderStr.match(/\bshortness of breath\b/i);
  if (sobMatch) {
    order.indication = 'shortness of breath';
    orderStr = orderStr.replace(sobMatch[0], '').trim();
  }
}

// ‚Äî‚Äî‚Äî ADD for combo doses like ‚Äú10-325 mg‚Äù ‚Äî‚Äî‚Äî
const comboMatch = orderStr.match(/(\d+)\s*-\s*(\d+)\s*mg\b/);
if (comboMatch) {
  order.dose = {
    value: [parseInt(comboMatch[1], 10), parseInt(comboMatch[2], 10)],
    unit: 'mg',
    total: null
  };
  orderStr = orderStr.replace(comboMatch[0], '').trim();
}
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî



      try {
        // Build a flat list of all unit synonyms
        const allUnits = Object.values(unitVariants).flat();

        // Find every occurrence of "<number> <unit>" for those variants
        let unitMatches = [];
        for (let u of allUnits) {
          const re = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*${u}\\b`, 'ig');
          let m;
          while ((m = re.exec(orderStr)) !== null) {
            unitMatches.push({ idx: m.index, qty: +m[1], rawUnit: u });
          }
        }

        // If we found any, pick the one that comes last in the line
        if (!Array.isArray(order.dose.value) && unitMatches.length) {
          const best = unitMatches.reduce((a, b) => b.idx > a.idx ? b : a);
          const stdUnit = Object.entries(unitVariants)
            .find(([std, arr]) => arr.includes(best.rawUnit))?.[0];
          if (stdUnit) {
            order.dose = { value: best.qty, unit: stdUnit, total: best.qty };
            orderStr = orderStr.replace(new RegExp(`${best.qty}\\s*${best.rawUnit}\\b`, 'i'), '').trim();
          } else {
            console.warn('No standard unit found for raw unit:', best.rawUnit, 'in:', orderStr);
          }
        } else {
          console.warn('No unit matches found in:', orderStr);
        }

        // 1. Extract "sprays per nostril" first
        const sprayPerNostril = orderStr.match(/(\d+)\s+sprays?\s+per\s+nostril/i);
        if (sprayPerNostril) {
          const n = parseInt(sprayPerNostril[1], 10);
          order.dose = { value: n, unit: 'spray', total: n * 2 };
          order.route = "nasal";
          orderStr = orderStr.replace(sprayPerNostril[0], '').trim();
        }

        // 2. Dose unit pattern (ignore form words)
const doseUnits = ['mcg','Œºg','ug','mg','g','mL','ml','cc','unit','IU','units','tsp','tbsp','drop','spray','puff'];
const doseRegex = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*(${doseUnits.join('|')})\\b`, 'i');
const doseMatch = orderStr.match(doseRegex);
if (doseMatch && !order.dose.value) {
  const qty = parseFloat(doseMatch[1]);
  let raw = doseMatch[2].toLowerCase();
  // normalize synonyms
  if (raw==='Œºg'||raw==='ug') raw='mcg';
  else if (raw==='ml'||raw==='cc') raw='mL';
  else if (['unit','iu','units'].includes(raw)) raw='unit';
  order.dose = { value: qty, unit: raw, total: qty };
  orderStr = orderStr.replace(doseMatch[0], '').trim();
}


        // 3. Fallback to standard dose extraction
        if (!order.dose.value) {
          // fallback: allow decimals, e.g. 0.5 mg/kg or 0.125 mg
	let leadingDoseMatch = orderStr.match(/(\d+(?:\.\d+)?)\s+(sprays|spray|capsules|capsule|puffs|puff|drops|drop|[ŒºmcgnmLgtspbIumeqmol%\/]+)/i);
          if (leadingDoseMatch) {
            order.dose = {
              value: parseFloat(leadingDoseMatch[1]),
              unit: leadingDoseMatch[2] || '',
              total: parseFloat(leadingDoseMatch[1])
            };
            orderStr = orderStr.replace(leadingDoseMatch[0], '').trim();
          } else {
            console.warn('No leading dose match found in:', orderStr);
          }
        }

        // Adjust for "per nostril", "per eye", "per ear" if not already handled
        if (order.dose.value && !order.sprayCountPerNostril && (orderStr.match(/\bper nostril\b/i) || orderStr.match(/\bper eye\b/i) || orderStr.match(/\bper ear\b/i))) {
          order.dose.total = order.dose.value * 2;
          orderStr = orderStr.replace(/\bper nostril\b/i, '').replace(/\bper eye\b/i, '').replace(/\bper ear\b/i, '').trim();
        }

        // Normalize the unit
const units = {
  'mcg':      ['mcg','Œºg'],
  'mg':       ['mg'],
  'g':        ['g'],
  'mL':       ['mL','ml'],
  'L':        ['L'],
  'tsp':      ['tsp','teaspoon'],
  'tbsp':     ['tbsp','tablespoon'],
  'drop':     ['drop','drops','gtt'],
  'spray':    ['spray','sprays'],
  'puff':     ['puff','puffs'],
  'unit':     ['unit','units'],
  'IU':       ['IU','international units'],
  'mEq':      ['mEq','milliequivalents'],
  'mmol':     ['mmol','millimoles'],
  'mg/mL':    ['mg/mL'],
  'mcg/mL':   ['mcg/mL'],
  '%':        ['%'],
  'patch':    ['patch','patches'],
  'applicator':['applicator','applicators'],
  'ampule':   ['ampule','ampules'],
  'vial':     ['vial','vials'],
  'capsule':  ['cap','caps','capsule','capsules','caplet','cap.','gelcap','softgel','gel','sprinkle','sprinkles'],
  'tablet':   ['tab','tabs','tablet','tablets','tab.','tablet.'],
  'lozenge':  ['lozenge','lozenges'],
  'suppository':['suppository','suppositories']
};

        if (order.dose.unit) {
          for (let [standard, variations] of Object.entries(units)) {
            if (variations.includes(order.dose.unit)) {
              order.dose.unit = standard;
              break;
            }
          }
        }
// ‚Äî‚Äî‚Äî weight-unit conversions ‚Üí mg ‚Äî‚Äî‚Äî
if (order.dose.unit === 'mcg') {
  // 1 mcg = 0.001 mg
  order.dose.value     = order.dose.value    / 1000;
  if (order.dose.total != null) order.dose.total = order.dose.total / 1000;
  order.dose.unit      = 'mg';
}
else if (order.dose.unit === 'g') {
  // 1 g = 1000 mg
  order.dose.value     = order.dose.value    * 1000;
  if (order.dose.total != null) order.dose.total = order.dose.total * 1000;
  order.dose.unit      = 'mg';
}
// ‚Äî‚Äî‚Äî normalize any remaining mcg/g glitch ‚Äî‚Äî‚Äî
if (order.dose.unit === 'mg') {
  // round to three decimals so 0.1 and 0.100 match exactly
  order.dose.value = Math.round(order.dose.value * 1000) / 1000;
  if (order.dose.total != null) order.dose.total = Math.round(order.dose.total * 1000) / 1000;
}
     
// ‚Äî‚Äî‚Äî DETECT TABLET vs CAPSULE ‚Äî‚Äî‚Äî

//=== STEP-FORMFIX  ‚¨áÔ∏é recognise dosage-form words ======================
const formMatch = orderStr.match(
  /\b(chewable\s+tablet|delayed[-\s]?release\s+tablet|tablet|caplet|capsule|patch(?:es)?|lozenge|suppository|spray|puff|drop|solution|suspension|elixir|syrup|cream|ointment|gel|inhaler)\b/i
);
if (formMatch) {
  const raw = formMatch[1].toLowerCase();

  /* map every synonym ‚Üí one canonical word */
  let form = 'other';  // fallback

  // 1) chewable tablet first
  if (raw.includes('chewable tablet')) {
    form = 'chewable tablet';

  // 2) delayed-release next
  } else if (
    raw.includes('delayed-release tablet') ||
    raw.includes('delayed release tablet')
  ) {
    form = 'delayed-release tablet';

  // 3) plain tablet
  } else if (raw.includes('tablet')) {
    form = 'tablet';

  } else if (raw.includes('caplet')) {
    form = 'caplet';

  } else if (raw.includes('capsule')) {
    form = 'capsule';

  } else if (raw.includes('patch')) {
    form = 'patch';

  } else if (raw.includes('lozenge')) {
    form = 'lozenge';

  } else if (raw.includes('suppository')) {
    form = 'suppository';

  } else if (raw.includes('spray')) {
    form = 'spray';

  } else if (raw.includes('puff')) {
    form = 'puff';

  } else if (raw.includes('drop')) {
    form = 'drop';

  } else if (raw.includes('suspension')) {
    form = 'suspension';

  } else if (
    raw.includes('solution') ||
    raw.includes('elixir') ||
    raw.includes('syrup')
  ) {
    form = 'solution';

  } else if (raw.includes('cream')) {
    form = 'cream';

  } else if (raw.includes('ointment')) {
    form = 'ointment';

  } else if (raw.includes('gel')) {
    form = 'gel';

  } else if (raw.includes('inhaler')) {
    form = 'inhaler';
  }

  order.form = form;

  /* strip the dosage-form word so it won‚Äôt confuse later parsing */
  orderStr = orderStr.replace(formMatch[0], '').trim();

  ['tablet','tablets','capsule','capsules','caplet'].forEach(s => {
    orderStr = orderStr.replace(new RegExp(`\\b${s}\\b`, 'gi'), '').trim();
  });

}
//=== END STEP-FORMFIX ===================================================

     // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

        // Define routes with their possible variations
        const routes = [
          { standard: "po", variations: ["po", "oral"] },
          { standard: "sl", variations: ["sl", "sublingual"] },
          { standard: "buccal", variations: ["buccal"] },
          { standard: "pr", variations: ["pr", "rectal"] },
          { standard: "ng", variations: ["ng", "nasogastric"] },
          { standard: "og", variations: ["og", "orogastric"] },
          { standard: "gastrostomy", variations: ["gastrostomy"] },
          { standard: "jejunostomy", variations: ["jejunostomy"] },
          { standard: "iv", variations: ["iv", "intravenous"] },
          { standard: "im", variations: ["im", "intramuscular"] },
          { standard: "subq", variations: ["subq", "sc", "subcutaneous"] },
          { standard: "id", variations: ["id", "intradermal"] },
          { standard: "io", variations: ["io", "intraosseous"] },
          { standard: "intrathecal", variations: ["intrathecal"] },
          { standard: "epidural", variations: ["epidural"] },
          { standard: "topical", variations: ["topical"] },
          { standard: "transdermal", variations: ["transdermal"] },
          { standard: "ophthalmic", variations: ["ophthalmic"] },
          { standard: "otic", variations: ["otic"] },
          { standard: "nasal", variations: ["nasal"] },
          { standard: "vaginal", variations: ["vaginal"] },
          { standard: "urethral", variations: ["urethral"] },
          { standard: "intrauterine", variations: ["intrauterine"] },
          { standard: "inhalation", variations: ["inhalation", "mdi", "dpi", "nebulized"] },
          { standard: "intranasal", variations: ["intranasal"] },
          { standard: "intraperitoneal", variations: ["intraperitoneal"] },
          { standard: "intraarticular", variations: ["intraarticular", "intra-articular"] },
          { standard: "intrapleural", variations: ["intrapleural"] },
          { standard: "intravesical", variations: ["intravesical"] },
          { standard: "implantable", variations: ["implantable"] }
        ];

        if (!order.route) {
          for (const routeDef of routes) {
            for (const variation of routeDef.variations) {
              if (orderStr.includes(variation)) {
                order.route = routeDef.standard;
                orderStr = orderStr.replace(new RegExp(`\\b${variation}\\b`, 'i'), '');
                break;
              }
            }
            if (order.route) break;
          }
        }
            // ‚Äî‚Äî‚Äî INTERVAL-ONLY FREQUENCY ‚Äî‚Äî‚Äî
    // 1) ‚Äúq6h‚Äù style
    const qhMatch = orderStr.match(/\bq(\d+)h\b/i);
    if (qhMatch) {
      order.frequency = `q${qhMatch[1]}h`;
      orderStr = orderStr.replace(qhMatch[0], '').trim();
    } else {
     
    //=== STEP‚ÄëFREQFIX  recognise ‚Äúevery 4 hours‚Äù style =========
    if (!order.frequency) {
      const everyHours = orderStr.match(/\bevery\s*(\d+)\s*hours?\b/i);
      if (everyHours) {
        order.frequency = `q${everyHours[1]}h`;
        orderStr = orderStr.replace(everyHours[0], '').trim();
      }
    }
    //=== END STEP‚ÄëFREQFIX ======================================


 // 2) named intervals (daily, bid, tid, qod, stat‚Ä¶)
const freqMapping = {
  "once daily":        "daily",
  "once a day":        "daily",    // ‚Üê NEW

  "1 times daily":     "daily",

  "daily":             "daily",

  "twice daily":       "twice daily",
  "2 times daily":     "twice daily",
  "bid":               "twice daily",

  "three times daily": "three times daily",
  "3 times daily":     "three times daily",
  "tid":               "three times daily",

  "four times daily":  "four times daily",
  "4 times daily":     "four times daily",
  "qid":               "four times daily",

  "every other day":   "every other day",
  "stat":              "immediately"
};


      // longest keys first so ‚Äúthree times daily‚Äù beats ‚Äúdaily‚Äù
      Object.keys(freqMapping)
  .sort((a, b) => b.length - a.length)
  .forEach(key => {
    // ‚Äî use word‚Äëboundaries so ‚Äústat‚Äù doesn‚Äôt hit simvaSTATin ‚Äî
    const pattern = new RegExp(`\\b${key.replace(/\s+/g, '\\s+')}\\b`, 'i');
    if (!order.frequency && pattern.test(orderStr)) {
      order.frequency = freqMapping[key];
      orderStr = orderStr.replace(pattern, '').trim();
    }
  });
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // If they gave a time‚Äêof‚Äêday but no explicit freq, assume daily
    if (!order.frequency && order.timeOfDay) {
      order.frequency = 'daily';
    }

    // ==== NEW: capture a real indication only when the keyword ‚Äúfor‚Äù is present ====
    if (!order.indication && /\bfor\b/i.test(orderStr)) {
    const parts = orderStr.split(/\bfor\b/i);
    orderStr          = parts[0].trim();        // everything before ‚Äúfor‚Äù is the drug
    order.indication  = parts[1].trim();        // everything after  ‚Äúfor‚Äù is the indication
    }


                // ‚Äî after all your stripping out of dose/route/freq/prn/etc ‚Äî
// split the remaining text into the drug name + anything else
const parts = orderStr.trim().split(/\s+/);
order.drug = parts[0] || '';
// if you haven‚Äôt already set an indication, capture whatever follows
if (!order.indication && parts.length > 1) {
  order.indication = parts.slice(1).join(' ');
}


        // Debugging for all orders
        console.log('Parsed order:', { original: orderStr, parsed: order });

        return order;
      } catch (e) {
        console.error('Error parsing order:', orderStr, e.stack || e);
         return { 
      drug: orderStr || '', 
      dose: { value: null, unit: '', total: null }, 
      route: '', 
      frequency: '',
      timeOfDay: '', 
      prn: false, 
      form: '', 
      indication: '' 
    };
   }
}

    function levenshteinDistance(a, b) {
      const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
      for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
      for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
          matrix[j][i] = Math.min(
            matrix[j][i - 1] + 1,
            matrix[j - 1][i] + 1,
            matrix[j - 1][i - 1] + indicator
          );
        }
      }
      return matrix[b.length][a.length];
    }

    function similarity(a, b) {
      const distance = levenshteinDistance(a, b);
      const maxLen = Math.max(a.length, b.length);
      return 1 - distance / maxLen;
    }

    function ordersAreEqual(a, b) {
  // 1) drug name
  const normA = normalizeMedicationName(a.drug);
  const normB = normalizeMedicationName(b.drug);
  const drugSimilarity = normA && normB
    ? similarity(normA, normB)
    : (normA === normB ? 1 : 0);
  if (drugSimilarity < 0.85) return false;

  // 2) dose (including combos)
  if (Array.isArray(a.dose.value) || Array.isArray(b.dose.value)) {
    if (!Array.isArray(a.dose.value) || !Array.isArray(b.dose.value)) return false;
    if (a.dose.value.length !== b.dose.value.length) return false;
    for (let i = 0; i < a.dose.value.length; i++) {
      if (a.dose.value[i] !== b.dose.value[i]) return false;
    }
    if (a.dose.unit !== b.dose.unit) return false;
  } else {
    const totalA = (a.dose.total != null ? a.dose.total : a.dose.value);
    const totalB = (b.dose.total != null ? b.dose.total : b.dose.value);
    if (totalA !== totalB || a.dose.unit !== b.dose.unit) return false;
  }

  // 3) route
  if (a.route !== b.route) return false;

    /// 4) frequency  ‚Äî treat ‚Äúdaily‚Äù, ‚Äúq24h‚Äù, and blank as the same
	const canonFreq = f => {
 	 f = (f || '').toLowerCase().trim();
 	 return (f === '' || f === 'daily' || f === 'q24h') ? 'daily' : f;
	};

	const fA = canonFreq(a.frequency);
	const fB = canonFreq(b.frequency);

	// exact ‚ÄúqNh‚Äù forms (q4h, q6h, ‚Ä¶) must match numerically
	const qA = fA.match(/^q(\d+)h$/);
	const qB = fB.match(/^q(\d+)h$/);

	if (qA && qB) {
  	if (+qA[1] !== +qB[1]) return false;
	} else if (fA !== fB) {
  	// fall back to fuzzy text similarity for phrases like ‚Äútwice daily‚Äù
  	const freqSim = similarity(fA, fB);
  	if (freqSim < 0.85) return false;
}


  // ‚îÄ‚îÄ‚îÄ normalize time-of-day equivalence ‚îÄ‚îÄ‚îÄ
  const normalizeTOD = t => {
    if (!t) return '';
    t = t.toLowerCase();
    if (['evening','night','bedtime'].includes(t)) return 'bedtime';
    return t;
  };
  if (normalizeTOD(a.timeOfDay) !== normalizeTOD(b.timeOfDay)) {
    return false;
  }
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // 5) dosage form must match ‚Ä¶
  if ((a.form || '') !== (b.form || '')) return false;
  // 6) PRN flag ‚Ä¶
  if (a.prn !== b.prn) return false;


// ‚Äî‚Äî‚Äî ENSURE PAIN INDICATION MATCHES ‚Äî‚Äî‚Äî
if ((a.indication || b.indication) && a.indication !== b.indication) {
  return false;
}
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

  return true;
}

    function compareOrders(list1, list2) {
      let unchanged = [];
      let removed = [];
      let added = [];
      let matched2 = new Array(list2.length).fill(false);
      for (let orderObj1 of list1) {
        let found = false;
        for (let i = 0; i < list2.length; i++) {
          if (!matched2[i] && ordersAreEqual(orderObj1.parsed, list2[i].parsed)) {
            matched2[i] = true;
            unchanged.push({             //  ‚Üê NEW: remember BOTH originals
                              orig: orderObj1,           //     from the facility list
                              new : list2[i]             //     from the hospital list
                              });
            found = true;
            break;
          }
        }
        if (!found) removed.push(orderObj1);
      }
      for (let i = 0; i < list2.length; i++) {
        if (!matched2[i]) added.push(list2[i]);
      }
//=== STEP‚ÄëMERGESAME  ‚¨áÔ∏é stop double‚Äëcounting identical meds =============
for (let i = removed.length - 1; i >= 0; i--) {
  const r = removed[i];
  const j = added.findIndex(a => ordersAreEqual(r.parsed, a.parsed));
  if (j !== -1) {
    unchanged.push({ orig: r, new: added[j] });
    removed.splice(i, 1);          // pull it from ‚Äúremoved‚Äù
    added.splice(j, 1);            // pull it from ‚Äúadded‚Äù
  }
}
//=== END STEP‚ÄëMERGESAME ===============================================

      return { unchanged, removed, added };
    }

    function isCriticalOrder(orderObj) {
      const text = orderObj.original.toLowerCase();
      return criticalMeds.some(med => text.includes(med));
    }

    function showScreen(screenId) {
      document.getElementById('error-message').textContent = '';
      document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
      updateProgress(screenId);
    }

    function updateProgress(screenId) {
      document.getElementById('step1').classList.remove('filled', 'current');
      document.getElementById('step2').classList.remove('filled', 'current');
      document.getElementById('step3').classList.remove('filled', 'current');
      document.getElementById('step4').classList.remove('filled', 'current');
      document.getElementById('line1-2').classList.remove('filled');
      document.getElementById('line2-3').classList.remove('filled');
      document.getElementById('line3-4').classList.remove('filled');

      if (screenId === 'disclaimer-screen') {
        document.getElementById('step1').classList.add('current');
      } else if (screenId === 'photo1-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
      } else if (screenId === 'photo2-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
      } else if (screenId === 'results-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('filled');
        document.getElementById('step4').classList.add('filled');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
        document.getElementById('line3-4').classList.add('filled');
      }
    }

    function showLoading(msg) {
      const ld = document.getElementById('loading'),
            lt = document.getElementById('loading-text');
      ld.style.display = 'flex';
      lt.textContent = msg;
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(msg) {
      document.getElementById('error-message').textContent = msg;
    }

    function acknowledgeDisclaimer() {
      showScreen('photo1-screen');
    }

    function handlePhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
    }

    function handleAdditionalPhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
      document.getElementById('photo1-capture2').value = "";
      document.getElementById('photo1-upload2').value = "";
    }

    function updatePhoto1UI() {
  // 1) grab the ‚ÄúYou can take a photo‚Ä¶‚Äù paragraph
  const instr1 = document.querySelector('#photo1-screen .upload-instructions');
  // 2) hide it as soon as you've added ‚â•1 photo OR used the text‚Äêpaste path
  instr1.style.display = (photo1Files.length > 0 || hasTextInput1)
    ? 'none'
    : 'block';

  // Update count & Next-button state:
  document.getElementById('photo1-status').textContent =
    photo1Files.length + (photo1Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo1-next').disabled =
    photo1Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo1-preview', photo1Files, 1);

  if (photo1Files.length > 0) {
    // Show prompt with **Next** bold:
    const prompt1 = document.getElementById('photo1-prompt');
    prompt1.style.display = 'block';
    prompt1.innerHTML =
      `Photo ${photo1Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Next</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo1-options').style.display = 'none';
    document.getElementById('additional-photo1-option').style.display = 'flex';
  } else {
    // No photos ‚Üí back to start
    document.getElementById('photo1-prompt').style.display = 'none';
    document.getElementById('initial-photo1-options').style.display = 'flex';
    document.getElementById('additional-photo1-option').style.display = 'none';
  }

  // Clear file inputs so you can re-select the same file if needed:
  document.getElementById('photo1-capture').value = "";
  document.getElementById('photo1-upload').value = "";
}



    function handlePhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
    }

    function handleAdditionalPhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
      document.getElementById('photo2-capture2').value = "";
      document.getElementById('photo2-upload2').value = "";
    }

    function updatePhoto2UI() {
    // 1) grab the ‚ÄúYou can take a photo‚Ä¶‚Äù paragraph on screen 2
  const instr2 = document.querySelector('#photo2-screen .upload-instructions');
  // 2) hide it as soon as you've added ‚â•1 photo OR used the paste path
  instr2.style.display = (photo2Files.length > 0 || hasTextInput2)
    ? 'none'
    : 'block';

  // Update count & Compare-button state:
  document.getElementById('photo2-status').textContent =
    photo2Files.length + (photo2Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo2-compare').disabled =
    photo2Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo2-preview', photo2Files, 2);

  if (photo2Files.length > 0) {
    // Show prompt with **Compare** bold:
    const prompt2 = document.getElementById('photo2-prompt');
    prompt2.style.display = 'block';
    prompt2.innerHTML =
      `Photo ${photo2Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Compare</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo2-options').style.display = 'none';
    document.getElementById('additional-photo2-option').style.display = 'flex';
  } else {
    // No photos ‚Üí back to start
    document.getElementById('photo2-prompt').style.display = 'none';
    document.getElementById('initial-photo2-options').style.display = 'flex';
    document.getElementById('additional-photo2-option').style.display = 'none';
  }

  // Clear file inputs
  document.getElementById('photo2-capture').value = "";
  document.getElementById('photo2-upload').value = "";
}

    function updatePreview(previewId, files, listNumber) {
      const container = document.getElementById(previewId);
      container.innerHTML = "";
      files.forEach((file, index) => {
        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.className = 'thumbnail-container';
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '<span class="material-icons">close</span>';
        deleteBtn.onclick = () => deletePhoto(listNumber, index);
        thumbnailDiv.appendChild(img);
        thumbnailDiv.appendChild(deleteBtn);
        container.appendChild(thumbnailDiv);
      });
    }

    function deletePhoto(listNumber, index) {
      if (listNumber === 1) {
        photo1Files.splice(index, 1);
        updatePhoto1UI();
      } else if (listNumber === 2) {
        photo2Files.splice(index, 1);
        updatePhoto2UI();
      }
    }

    function handleTextInput1() {
      const text = document.getElementById('photo1-text-input').value.trim();
      if (!text) {
        showError('Please paste a medication list before submitting.');
        return;
      }
      // Clear any old status
      document.getElementById('photo1-status').textContent = 'List pasted.';
      hasTextInput1 = true;
      let lines = text.split(/\r?\n+/).map(line => cleanLine(line));
	lines = mergeMultiLineOrders(lines);
	lines = mergeTaperPackOrders(lines);
	// prune off any trailing non-order text
	// lines = lines.map(line => pruneLine(line));
	lines = lines.filter(line => 
		isLikelyOrderLine(line) && containsKnownMedication(line)
		);


      console.log('Raw lines after filtering:', lines); // Debug log
      lines = [...new Set(lines)];
      if (lines.length === 0) {
        showError('No valid medication orders detected in the pasted list. Please try again.');
        return;
      }
      meds1 = lines.map(med => {
        try {
          const parsed = parseOrder(med);
          if (!parsed || typeof parsed !== 'object') {
            console.warn('Parse failed for:', med, 'returning default object');
            return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
          }
          return { original: med, parsed: parsed };
        } catch (e) {
          console.error('Error parsing line:', med, e.stack || e);
          return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
        }
      });
      console.log('Medications from First List (Text Input):', meds1);
      document.getElementById('photo1-status').textContent = 'Proceeding to second list...';
      document.getElementById('initial-photo1-options').style.display = 'none';
      document.getElementById('additional-photo1-option').style.display = 'none';
      document.getElementById('photo1-prompt').style.display = 'none';
      showError('');
      showScreen('photo2-screen');
    }

    function handleTextInput2() {
      const text = document.getElementById('photo2-text-input').value.trim();
      if (!text) {
        showError('Please paste a medication list before submitting.');
        return;
      }
      // Clear any old status
      document.getElementById('photo2-status').textContent = 'List pasted.';
      hasTextInput2 = true;
          let lines = text.split(/\r?\n+/).map(line => cleanLine(line));
    	lines = mergeMultiLineOrders(lines);
	lines = mergeTaperPackOrders(lines);
	// prune off any trailing non-order text
	// lines = lines.map(line => pruneLine(line));
    	lines = lines.filter(line => 
		isLikelyOrderLine(line) && containsKnownMedication(line)
		);

      console.log('Raw lines after filtering:', lines); // Debug log
      lines = [...new Set(lines)];
      if (lines.length === 0) {
        showError('No valid medication orders detected in the pasted list. Please try again.');
        return;
      }
      meds2 = lines.map(med => {
        try {
          const parsed = parseOrder(med);
          if (!parsed || typeof parsed !== 'object') {
            console.warn('Parse failed for:', med, 'returning default object');
            return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
          }
          return { original: med, parsed: parsed };
        } catch (e) {
          console.error('Error parsing line:', med, e.stack || e);
          return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
        }
      });
      console.log('Medications from Second List (Text Input):', meds2);
      document.getElementById('photo2-compare').disabled = false;
      document.getElementById('initial-photo2-options').style.display = 'none';
      document.getElementById('additional-photo2-option').style.display = 'flex';
      document.getElementById('photo2-prompt').style.display = 'block';
      document.getElementById('photo2-prompt').textContent = 'You may add a photo or click Compare to continue.';
      showError('');
    }

    async function goToPhoto2() {
      if (!hasTextInput1 && (!photo1Files || photo1Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput1) {
        showLoading('Processing first image(s)...');
        try {
          let combinedText = await processFiles(photo1Files);
                      let lines = combinedText.split(/\r?\n+/).map(line => cleanLine(line));
      		lines = mergeMultiLineOrders(lines);
		lines = mergeTaperPackOrders(lines);
		// prune off any trailing non-order text
		// lines = lines.map(line => pruneLine(line));
//=== STEP 4  removed ‚Äì keepOrderLines already filtered


          console.log('Raw lines from OCR:', lines); // Debug log
          lines = [...new Set(lines)];
          if (lines.length === 0) {
            hideLoading();
            showError('No valid medication orders detected in the first photos. Please try again.');
            return;
          }
          meds1 = lines.map(med => {
            try {
              const parsed = parseOrder(med);
              if (!parsed || typeof parsed !== 'object') {
                console.warn('Parse failed for:', med, 'returning default object');
                return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
              }
              return { original: med, parsed: parsed };
            } catch (e) {
              console.error('Error parsing line:', med, e.stack || e);
              return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
            }
          });
          console.log('Medications from First List:', meds1);
          hideLoading();
          showScreen('photo2-screen');
        } catch (err) {
          console.error('OCR Error:', err);
          hideLoading();
          showError('Error extracting text from the first photos. Please try again.');
        }
      }
    }

    async function comparePhotos() {
      if (!hasTextInput2 && (!photo2Files || photo2Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput2) {
        showLoading('Processing second image(s)...');
        try {
          let combinedText = await processFiles(photo2Files);
                let lines = combinedText.split(/\r?\n+/).map(line => cleanLine(line));
      		lines = mergeMultiLineOrders(lines);
		lines = mergeTaperPackOrders(lines);
		// prune off any trailing non-order text
		// lines = lines.map(line => pruneLine(line));
//=== STEP 4  removed ‚Äì keepOrderLines already filtered

          console.log('Raw lines from OCR:', lines); // Debug log
          lines = [...new Set(lines)];
          if (lines.length === 0) {
            hideLoading();
            showError('No valid medication orders detected in the second photos. Please try again.');
            return;
          }
          meds2 = lines.map(med => {
            try {
              const parsed = parseOrder(med);
              if (!parsed || typeof parsed !== 'object') {
                console.warn('Parse failed for:', med, 'returning default object');
                return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
              }
              return { original: med, parsed: parsed };
            } catch (e) {
              console.error('Error parsing line:', med, e.stack || e);
              return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
            }
          });
          console.log('Medications from Second List:', meds2);
          hideLoading();
          compareAndShowResults();
        } catch (err) {
          console.error('OCR Error:', err);
          hideLoading();
          showError('Error extracting text from the second photos. Please try again.');
        }
      } else {
        compareAndShowResults();
      }
    }

function compareAndShowResults() {
    let { unchanged, removed, added } = compareOrders(meds1, meds2);
    
//=== STEP-MERGE-REMOVED-ADDED (enhanced) ======================
const merged = [];
const addedMap = Object.create(null);
added.forEach(a => {
  addedMap[ normalizeMedicationName(a.original) ] = a;
});

removed = removed.filter(r => {
  const key   = normalizeMedicationName(r.original);
  const match = addedMap[key];
  if (!match) return true;

  // 2-a) if the only difference is form, force a single "Form changed"
  const reason = getChangeReason(r.parsed, match.parsed);
  if (reason === 'Form changed') {
    merged.push({ orig:r, new:match, reason:'Form changed' });
    delete addedMap[key];
    return false;
  }

  // 2-b) otherwise fall back to your old logic
  merged.push({ orig:r, new:match, reason });
  delete addedMap[key];
  return false;
});

added = Object.values(addedMap);
//=== END STEP-MERGE-REMOVED-ADDED ==============================


//=== STEP‚ÄëFIX  skip any blank or junk entries =========================
const notBlank = obj =>
  obj && obj.original && obj.original.trim().length > 0;

unchanged = unchanged.filter(pair => notBlank(pair.orig) && notBlank(pair.new));
removed   = removed  .filter(notBlank);
added     = added    .filter(notBlank);
//=== END STEP‚ÄëFIX ======================================================

    // Build a numbered, four-column table of changes
    let html = `
        <table class="changes-table">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Original Order (Facility)</th>
                    <th>New Order (Hospital)</th>
                    <th>Suspected Change</th>
                </tr>
            </thead>
            <tbody>
    `;

    let idx = 1;

    // Process removed orders (potential changes or removals)

// ‚Äë‚Äë‚Äë FIRST: show the neatly‚Äëmerged pairs ‚Äë‚Äë‚Äë
merged.forEach(pair => {
  const crit = isCriticalOrder(pair.orig) || isCriticalOrder(pair.new);
  html += `
    <tr class="${crit ? 'critical' : ''}">
      <td>${idx++}</td>
      <td>${pair.orig.original}</td>
      <td>${pair.new.original}</td>
      <td>${pair.reason}</td>
    </tr>`;
});
    
removed.forEach(r => {
        console.group(`üîç Comparing removed: ${r.original}`);
        console.log('   current added[]:', added.map(a => a.original));
        const lowerRem = r.original.toLowerCase();
        let match = null;
        let changeType = null;

        // 1) Brand ‚Üí generic?
        const brandKey = Object.keys(brandToGenericMap).find(b => lowerRem.includes(b));
        if (brandKey) {
            changeType = 'Generic Medication';
            const gen = brandToGenericMap[brandKey];
            match = added.find(a => normalizeMedicationName(a.parsed.drug) === gen);
        }

        // 2) Generic ‚Üí brand?
        if (!match) {
            const genKey = normalizeMedicationName(r.parsed.drug);
            const brandList = genericToBrandMap[genKey] || [];
            for (let brand of brandList) {
                const regex = new RegExp(`\\b${brand}\\b`, 'i');
                const found = added.find(a => regex.test(a.original));
                if (found) {
                    changeType = 'Brand Medication';
                    match = found;
                    break;
                }
            }
        }

        // 3) Substring match (fallback, less precise)
        if (!match) {
            const drugName = r.parsed.drug.toLowerCase();
            match = added.find(a => a.original.toLowerCase().includes(drugName));
            if (match) {
                changeType = getChangeReason(r.parsed, match.parsed);
                console.log(`   ‚Üí substring matched "${drugName}" to`, match.original);
            }
        }

        const crit = isCriticalOrder(r) || (match && isCriticalOrder(match));

        // 4) Brand ‚Üî generic swap
        if (match && (changeType === 'Generic Medication' || changeType === 'Brand Medication')) {
            html += `
                <tr class="${crit ? 'critical' : ''}">
                    <td>${idx++}</td>
                    <td>${r.original}</td>
                    <td>${match.original}</td>
                    <td>${changeType}</td>
                </tr>
            `;
            added = added.filter(a => a !== match);
            console.groupEnd();
            return;
        }

        // 5) Dose / freq / form / route / PRN / admin reasons
        if (match) {
            // Use getChangeReason to determine the specific change
            const reason = getChangeReason(r.parsed, match.parsed);
            html += `
                <tr class="${crit ? 'critical' : ''}">
                    <td>${idx++}</td>
                    <td>${r.original}</td>
                    <td>${match.original}</td>
                    <td>${reason}</td>
                </tr>
            `;
            added = added.filter(a => a !== match);
            console.groupEnd();
            return;
        }

        // 6) Same-drug match
        const sameDrug = added.find(a =>
            normalizeMedicationName(a.parsed.drug) === normalizeMedicationName(r.parsed.drug)
        );
        if (sameDrug) {
            const reason = getChangeReason(r.parsed, sameDrug.parsed);
            html += `
                <tr class="${crit ? 'critical' : ''}">
                    <td>${idx++}</td>
                    <td>${r.original}</td>
                    <td>${sameDrug.original}</td>
                    <td>${reason}</td>
                </tr>
            `;
            added = added.filter(a => a !== sameDrug);
            console.groupEnd();
            return;
        }

        // 7) Pure removal
        html += `
            <tr class="${crit ? 'critical' : ''}">
                <td>${idx++}</td>
                <td>${r.original}</td>
                <td></td>
                <td>Removed</td>
            </tr>
        `;
        console.groupEnd();
    });

    // Unchanged ‚Äë‚Äë‚Üí now re‚Äëevaluate for brand/generic etc.
    unchanged.forEach(u => {
       const reason = getChangeReason(u.orig.parsed, u.new.parsed);
       const label  = (reason === 'Misc. Change') ? 'Unchanged' : reason;

      html += `
    <tr${label !== 'Unchanged' && (isCriticalOrder(u.orig)||isCriticalOrder(u.new)) ? ' class="critical"' : ''}>
                <td>${idx++}</td>
                 <td>${u.orig.original}</td>
                 <td>${u.new.original}</td>
                 <td>${label}</td>
             </tr>
        `;
      });


    // Added orders
    added.forEach(a => {
        const crit = isCriticalOrder(a);
        html += `
            <tr class="${crit ? 'critical' : ''}">
                <td>${idx++}</td>
                <td></td>
                <td>${a.original}</td>
                <td>Added</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
    `;

    document.getElementById('results-content').innerHTML = html;
    showScreen('results-screen');
}

    async function exportToPDF() {
  // 1) grab your table
  const table = document.querySelector('.changes-table');
  // 2) init jsPDF
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });

  // 3) optional: add a title
  pdf.setFontSize(14);
  pdf.text('Comparison Results', 40, 40);

  // 4) render the table with AutoTable
  pdf.autoTable({
    html: table,
    startY: 60,
    theme: 'grid',
    headStyles: { fillColor: [240,240,240] },
    styles: {
      fontSize: 9,
      cellPadding: 4,
      overflow: 'linebreak'
    },
    // ensure no row ever splits across pages:
    pageBreak: 'avoid',
    didDrawPage: (data) => {
      // here you could add page numbers, headers, etc.
    }
  });

  // 5) save the PDF
  pdf.save('MedRec_Report.pdf');
}


function printResults() {
  // 1) make sure we‚Äôre on the results screen
  showScreen('results-screen');

  // 2) give the browser a moment to apply your @media print CSS
  setTimeout(() => {
    window.print();
  }, 100);
}

    function startOver() {
      photo1Files = [];
      photo2Files = [];
      meds1 = [];
      meds2 = [];
      hasTextInput1 = false;
      hasTextInput2 = false;
      document.getElementById('photo1-capture').value = '';
      document.getElementById('photo1-upload').value = '';
      document.getElementById('photo1-capture2').value = '';
      document.getElementById('photo1-upload2').value = '';
      document.getElementById('photo2-capture').value = '';
      document.getElementById('photo2-upload').value = '';
      document.getElementById('photo2-capture2').value = '';
      document.getElementById('photo2-upload2').value = '';
      document.getElementById('photo1-text-input').value = '';
      document.getElementById('photo2-text-input').value = '';
      document.getElementById('photo1-status').textContent = '';
      document.getElementById('photo2-status').textContent = '';
      document.getElementById('photo1-next').disabled = true;
      document.getElementById('photo2-compare').disabled = true;
      document.getElementById('results-content').innerHTML = '';
      document.getElementById('photo1-preview').innerHTML = "";
      document.getElementById('photo2-preview').innerHTML = "";
      document.getElementById('photo1-prompt').style.display = 'none';
      document.getElementById('initial-photo1-options').style.display = 'flex';
      document.getElementById('additional-photo1-option').style.display = 'none';
      document.getElementById('photo2-prompt').style.display = 'none';
      document.getElementById('initial-photo2-options').style.display = 'flex';
      document.getElementById('additional-photo2-option').style.display = 'none';
      showScreen('disclaimer-screen');
    }

    // Tooltip toggle for mobile
    document.querySelectorAll('.tooltip').forEach(tooltip => {
      tooltip.addEventListener('click', (e) => {
        e.stopPropagation();
        const isActive = tooltip.classList.contains('active');
        document.querySelectorAll('.tooltip').forEach(t => t.classList.remove('active'));
        if (!isActive) {
          tooltip.classList.add('active');
        }
      });
    });

    document.addEventListener('click', () => {
      document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.classList.remove('active');
      });
    });

    document.addEventListener('DOMContentLoaded', () => {
      hideLoading();
      updateProgress('disclaimer-screen');
    });
  </script>
<!-- 1) html2canvas: required for jsPDF.html() to work -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<!-- 2) jsPDF UMD bundle -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<!-- 3) jsPDF-AutoTable plugin: add this line -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>

</body>
</html>
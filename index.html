<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MedRec 2.0</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    /* Basic Layout */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "Helvetica Neue", Arial, sans-serif;
      font-size: 1rem;
      color: #333;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    p {
      line-height: 1.6;
    }
    header {
      background-color: #007bff;
      color: white;
      text-align: center;
      padding: 10px 15px;
      position: sticky;
      top: 0;
      z-index: 1000;
      height: 125px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      width: 100%;
    }

    @media (max-width: 600px) {
      header {
        height: 110px;
        padding: 5px 15px;
      }
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center; /* Horizontal centering of .screen */
      justify-content: center; /* Vertical centering of .screen when content is short */
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      width: 100%;
      padding: 1rem;
      box-sizing: border-box;
    }
    .screen {
      display: none;
      width: 100%;
      text-align: center;
    }
    .screen.active {
      display: block;
    }
    /* Card Styling */
    .card {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.07);
      border: 1px solid #ddd;
      padding: 1.5rem;
      margin: 0.5rem 0;
      width: 100%;
      box-sizing: border-box;
    }
    /* Buttons & Inputs */
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      margin: 0.5rem 0;
      cursor: pointer;
      border-radius: 6px;
      width: 100%;
      max-width: 300px;
      display: block;
      font-weight: 600;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: background-color 0.2s ease, border-color 0.2s ease,
        color 0.2s ease, box-shadow 0.2s ease;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    /* Hide native file inputs */
    input[type="file"] {
      display: none;
    }
    .photo-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      margin: 1rem 0;
      width: 100%;
    }
    .photo-actions button {
      width: 100%;
      max-width: 300px;
      margin: 0;
    }
    .disclaimer-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1rem 0;
      width: 100%;
    }
    .disclaimer-actions button {
      width: 100%;
      max-width: 300px;
    }

    /* Secondary buttons (default for photo actions) */
    .photo-actions button,
    button[onclick='exportToPDF()'],
    button[onclick='printResults()'] {
      background-color: #fff;
      color: #0069d9;
      border: 1px solid #0069d9;
    }

    .photo-actions button:hover:not(:disabled),
    button[onclick='exportToPDF()']:hover:not(:disabled),
    button[onclick='printResults()']:hover:not(:disabled) {
      background-color: #e6f2ff;
    }

    /* Primary action buttons */
    .disclaimer-actions button,
    #photo1-next,
    #photo2-compare,
    .text-input-container button {
      background-color: #0069d9;
      color: #fff;
      border: 1px solid #0069d9;
      background-image: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.08),
        rgba(0, 0, 0, 0.08)
      );
    }

    .disclaimer-actions button:hover:not(:disabled),
    #photo1-next:hover:not(:disabled),
    #photo2-compare:hover:not(:disabled),
    .text-input-container button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    /* Tertiary buttons */
    button[onclick='startOver()'] {
      background-color: #f8f9fa;
      color: #6c757d;
      border: 1px solid #ced4da;
    }

    button[onclick='startOver()']:hover:not(:disabled) {
      background-color: #e9ecef;
      border-color: #adb5bd;
    }
    .upload-instructions {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #555;
    }
    .upload-prompt {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #333;
    }
    .preview-container {
      text-align: center;
      margin: 0.5rem 0 1rem;
    }
    .thumbnail-container {
      position: relative;
      display: inline-block;
      margin: 0.25rem;
    }
    .thumbnail-container img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    /* ============== delete (close) chip ============== */
    .delete-btn {
      position: absolute;
      top: -6px;                   /* sticks out a little */
      right: -6px;
      width: 24px;                 /* exact circle */
      height: 24px;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #ff4d4d;         /* red chip */
      color: #fff;                 /* white “X” */
      font-size: 18px;             /* icon size */
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.25);
      transition: background .15s ease;
      padding: 0;                  /* override global button padding */
    }
    .delete-btn:hover {
      background: #d73838;         /* darker on hover */
    }
    /* make the glyph a touch smaller and centred */
    .delete-btn .material-icons {
      font-size: 18px;             /* icon ≈ 75 % of circle */
      line-height: 1;
    }
    #error-message {
      color: red;
      text-align: center;
      margin: 1rem 0;
    }
    .critical {
      color: red;
      font-weight: bold;
    }
/* ========= New table styling ========== */
table.changes-table {
  width: auto;
  margin: 1rem auto;    /* center horizontally */
  border-collapse: collapse;
  font-size: 0.9rem;
}
/* allow horizontal scroll on narrow viewports */
#results-content {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
table.changes-table th,
table.changes-table td {
  border: 1px solid #ddd;
  padding: 0.5rem;
  text-align: left;
  line-height: 1.6;
}
table.changes-table th {
  background-color: #f0f0f0;
}
/* Prevent splitting rows across PDF pages */
.changes-table,
.changes-table thead,
.changes-table tbody,
.changes-table tr,
.changes-table th,
.changes-table td {
  page-break-inside: avoid !important;
}

    .progress-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0 auto;
      width: 90%;
      max-width: 400px;
      position: relative;
    }
    .progress-step {
      width: 30px;
      height: 30px;
      background-color: #cccccc;
      border: 1px solid #999;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      transition: all 0.3s ease;
    }
    .progress-step.filled {
      background-color: #66b0ff;
      border: 1px solid #0056b3;
      color: white;
    }
    .progress-step.current {
      background-color: #007bff;
      border: 3px solid #0056b3;
      color: white;
    }
    .progress-line-container {
      position: absolute;
      top: 50%;
      left: 15px;
      right: 15px;
      height: 2px;
      z-index: 0;
      display: flex;
      justify-content: space-between;
    }
    .progress-line {
      flex: 1;
      height: 2px;
      background-color: #cccccc;
      margin: 0 5px;
    }
    .progress-line.filled {
      background-color: #66b0ff;
    }
    #loading {
      display: none;
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 0.5rem;
      text-align: center;
      z-index: 2000;
    }
    #loading-text {
      margin-bottom: 0.25rem;
    }
    #loading-progress {
      width: 80%;
      max-width: 300px;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin: 0.5rem 0;
    }
    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    h3 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
    }

    p.disclaimer-text {
      text-align: left;
      line-height: 1.6;
      max-width: 500px;
      margin: 0 auto;
    }
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: pointer;
      color: #007bff;
      margin-left: 5px;
      font-size: 0.9rem;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #333;
      color: white;
      text-align: center;
      border-radius: 5px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltip-text,
    .tooltip.active .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    #medrec-logo {
      display: block;
      height: 70px;
      width: auto;
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 5px;
    }

    @media (max-width: 600px) {
      #medrec-logo {
        height: 60px;
        margin-bottom: 5px;
      }
    }
    /* New styles for text input */
    .text-input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      width: 100%;
    }
    textarea {
      width: 100%;
      max-width: 300px;
      height: 100px;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      resize: none;
      font-family: Arial, sans-serif;
      font-size: 16px;
    }
    textarea:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    }
    
    @media print {
  footer { display: none !important; }
  /* hide everything but the results screen */
  header, button, .photo-actions, .progress-bar, #loading,
  .screen:not(#results-screen) {
    display: none !important;
  }
  #results-screen { display: block !important; }

  /* allow the table to grow and show all columns */
  #results-content {
    overflow: visible !important;
    -webkit-overflow-scrolling: auto !important;
    width: auto !important;
    margin: 0 !important;
  }
  table.changes-table {
    width: 100% !important;
    border-collapse: collapse !important;
  }
  table.changes-table th,
  table.changes-table td {
    border: 1px solid #ddd !important;
    padding: 8px !important;
  }
}

main { /* Add padding to main element */
  padding-bottom: 4rem; /* Add space at bottom before footer */
}

footer {
  text-align: center;
  padding: 1rem;
  margin-top: auto; /* Helps push footer down */
  font-size: 0.8rem;
  color: #6c757d; /* Muted grey color */
  background-color: #f4f4f4; /* Match body background */
}

footer a {
  color: #0056b3; /* Link color */
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

/* ========== highlight rows that contain a contra‑indicated med ========== */
.ci-row {
  background-color: #fffbe6;          /* pale yellow that prints as light grey */
}

.confidence-high {
  background-color: #e6ffed;
  color: #006421;
}
.confidence-medium {
  background-color: #fff8e1;
  color: #6B4F02;
}
.confidence-low {
  background-color: #ffebee;
  color: #b71c1c;
  font-weight: bold;
}

  </style>

<!-- === PDF LIBRARIES === -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
<!-- === END PDF LIBRARIES === -->

</head>
<body>
  <header>
    <img src="MedRec%20Logo.png" alt="MedRec 2.0 Logo" id="medrec-logo">
    <div class="progress-bar">
      <div class="progress-line-container">
        <div class="progress-line" id="line1-2"></div>
        <div class="progress-line" id="line2-3"></div>
        <div class="progress-line" id="line3-4"></div>
      </div>
      <div class="progress-step" id="step1">1</div>
      <div class="progress-step" id="step2">2</div>
      <div class="progress-step" id="step3">3</div>
      <div class="progress-step" id="step4">4</div>
    </div>
  </header>
  <main class="main-scroll">
    <div id="error-message"></div>
    <!-- Disclaimer Screen -->
    <div id="disclaimer-screen" class="screen active">
      <h2>Disclaimer</h2>
      <div class="card">
        <p class="disclaimer-text">
          <strong>HIPAA Warning: DO NOT UPLOAD IMAGES CONTAINING IDENTIFIABLE INFORMATION.</strong> This app is intended for use by personnel authorized to handle Protected Health Information (PHI). While MedRec 2.0 is a HIPAA compliant application, users are responsible for ensuring full compliance with HIPAA regulations, including safeguarding resident/patient data and restricting access to authorized personnel only. Unauthorized disclosure of PHI may result in disciplinary action and legal consequences.
<br><br>
          <em>Note:</em> MedRec 2.0 is a support tool and does not guarantee 100% accuracy in identifying medication discrepancies. Final verification must be completed by qualified clinical personnel.
        </p>
      </div>
      <div class="disclaimer-actions">
        <button onclick="acknowledgeDisclaimer()">I Understand</button>
      </div>
    </div>
    <!-- Photo 1 Screen -->
    <div id="photo1-screen" class="screen">
      <div class="card">
        <h2>Enter Medications Before Hospital Stay</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo1-options" class="photo-actions">
          <button onclick="document.getElementById('photo1-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo1-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo1-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput1()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo1-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo1-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo1-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo1-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-upload" accept="image/*" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto1(this.files)">
      <input type="file" id="photo1-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto1(this.files)">
      <div id="photo1-preview" class="preview-container"></div>
      <p id="photo1-status"></p>
      <p id="photo1-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo1-next" onclick="goToPhoto2()" disabled>Next</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Photo 2 Screen -->
    <div id="photo2-screen" class="screen">
      <div class="card">
        <h2>Enter Hospital Discharge Medications</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo2-options" class="photo-actions">
          <button onclick="document.getElementById('photo2-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo2-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo2-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput2()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo2-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo2-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo2-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo2-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-upload" accept="image/*" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto2(this.files)">
      <input type="file" id="photo2-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto2(this.files)">
      <div id="photo2-preview" class="preview-container"></div>
      <p id="photo2-status"></p>
      <p id="photo2-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo2-compare" onclick="comparePhotos()" disabled>Compare</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Results Screen -->
    <div id="results-screen" class="screen">
      <h2>Comparison Results</h2>
      <p>Changes listed in <span class="critical">bold red</span> are critical medications and should be reconciled with the provider within <span class="critical">4 hours</span> of discovery.</p>
      <div class="card">
        <div id="results-content"></div>
      </div>
      <div class="photo-actions">
                    <button onclick="exportToPDF()">Export as PDF</button>
        <button onclick="printResults()">Print Results</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
  </main>
  <footer>
  &copy; 2025 David Gottschalk. For technical support, please contact <a id="supportEmail" href="#">support@example.com</a>.
</footer>
  <div id="loading">
    <p id="loading-text">Processing...</p>
    <progress id="loading-progress" max="100"></progress>
  </div>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-functions-compat.js"></script>
  <script>
    // New script block for Firebase Initialization
    const firebaseConfig = {
      apiKey: "AIzaSyBYrJPALSB45rPm5D0T29rEwCdJ5Ek24ug",
      authDomain: "medrec-solutions-cd00e.firebaseapp.com",
      projectId: "medrec-solutions-cd00e",
      storageBucket: "medrec-solutions-cd00e.appspot.com",
      messagingSenderId: "276805089930",
      appId: "1:276805089930:web:9631c7d4cf223f1666d087"
    };
    // Initialize Firebase
    if (!firebase.apps.length) {
      window.firebaseApp = firebase.initializeApp(firebaseConfig);
      if (window.DEBUG) console.log("Firebase initialized directly in HTML.");
    } else {
      window.firebaseApp = firebase.app();
      if (window.DEBUG) console.log("Firebase was already initialized.");
    }
  </script>

  <script>
    const DEBUG = false;
    const criticalMeds = [
      'warfarin', 'coumadin', 'apixaban', 'rivaroxaban', 'dabigatran', 'edoxaban', 'heparin', 'enoxaparin',
      'clopidogrel', 'ticagrelor', 'prasugrel', 'insulin regular', 'insulin glargine', 'insulin detemir',
      'insulin lispro', 'insulin aspart', 'insulin degludec', 'glipizide', 'glyburide', 'glimepiride',
      'repaglinide', 'nateglinide', 'metformin', 'morphine', 'hydromorphone', 'oxycodone', 'fentanyl',
      'methadone', 'tramadol', 'codeine', 'buprenorphine', 'phenytoin', 'carbamazepine', 'valproic acid',
      'phenobarbital', 'lamotrigine', 'levetiracetam', 'digoxin', 'amiodarone', 'sotalol', 'diltiazem',
      'verapamil', 'metoprolol', 'atenolol', 'carvedilol', 'furosemide', 'bumetanide', 'torsemide',
      'spironolactone', 'hydrochlorothiazide', 'chlorthalidone', 'potassium chloride', 'magnesium sulfate',
      'calcium gluconate', 'calcium chloride', 'sodium bicarbonate', 'phosphate', 'hydralazine', 'clonidine',
      'isosorbide mononitrate', 'isosorbide dinitrate', 'nitroglycerin', 'haloperidol', 'risperidone',
      'olanzapine', 'quetiapine', 'aripiprazole', 'ziprasidone', 'lorazepam', 'diazepam', 'clonazepam',
      'temazepam', 'midazolam', 'zolpidem', 'prednisone', 'methylprednisolone', 'dexamethasone',
      'hydrocortisone', 'levothyroxine', 'liothyronine', 'tacrolimus', 'cyclosporine', 'mycophenolate',
      'azathioprine', 'vancomycin', 'gentamicin', 'tobramycin', 'amikacin', 'ciprofloxacin', 'levofloxacin',
      'moxifloxacin', 'azithromycin', 'clarithromycin', 'erythromycin', 'amoxicillin',
      'amoxicillin-clavulanate', 'ceftriaxone', 'cefepime', 'ceftazidime', 'cefdinir', 'cephalexin',
      'piperacillin-tazobactam', 'penicillin vk', 'dicloxacillin', 'nafcillin', 'meropenem', 'ertapenem',
      'imipenem-cilastatin', 'doxycycline', 'minocycline', 'tetracycline', 'linezolid',
      'sulfamethoxazole-trimethoprim', 'nitrofurantoin', 'metronidazole', 'clindamycin', 'fosfomycin',
      'daptomycin', 'tigecycline', 'carbidopa/levodopa', 'entacapone', 'selegiline', 'rasagiline', 'lithium',
      'theophylline', 'clozapine', 'methotrexate', 'allopurinol', 'colchicine', 'tamsulosin', 'finasteride',
      'denosumab', 'zoledronic acid', 'teriparatide', 'alendronate', 'risedronate', 'acetazolamide',
      'bethanechol', 'bethanechol chloride', 'donepezil', 'rivastigmine', 'galantamine', 'memantine',
      'naltrexone', 'naloxone', 'flumazenil', 'desmopressin', 'octreotide', 'erythropoietin', 'filgrastim',
      'calcitriol', 'ergocalciferol', 'cholecalciferol', 'pyridostigmine', 'propranolol', 'labetalol',
      'isosorbide', 'nicardipine', 'nitroprusside', 'ivabradine', 'sacubitril', 'valsartan',
      'atorvastatin', 'rosuvastatin', 'simvastatin', 'Norco', 'oxycodone/acetaminophen', 'hydrocodone/acetaminophen', 'codeine/acetaminophen', 'tramadol/acetaminophen', 'acetaminophen/caffeine/dihydrocodeine', 'aspirin/caffeine/dihydrocodeine', 'aspirin/codeine', 'ibuprofen/oxycodone', 'acetaminophen/butalbital/caffeine', 'aspirin/butalbital/caffeine', 'acetaminophen/butalbital', 'methylphenidate', 'amphetamine/dextroamphetamine', 'hydrocodone/pseudoephedrine', 'hydrocodone/chlorpheniramine', 'hydrocodone/homatropine', 'busulfan', 'doxorubicin', 'adalimumab', 'acetaminophen/isometheptene/dichloralphenazone', 'ultracet', 'percocet', 'roxicet', 'endocet', 'tylenol #3', 'zamicet', 'vicodin', 'lortab', 'panlor ss', 'trezix', 'synalgos-dc', 'empirin with codeine', 'combunox', 'fioricet', 'esgic', 'zebutal', 'fiorinal', 'bupap', 'rezira', 'tussionex', 'hycomine', 'hydromet', 'midrin','chlorpropamide', 'acarbose', 'miglitol', 'argatroban', 'bivalirudin', 'fondaparinux', 'methylergonovine', 'carboplatin', 'cyclophosphamide', 'promethazine'

    ].map(med => med.toLowerCase());

/* Drug Contraindications List */
const drugContraindications = {
  /* 1 */ "atorvastatin": [
           "tipranavir", "ritonavir", "glecaprevir", "pibrentasvir",
           "cyclosporine", "gemfibrozil"
         ],
  /* 2 */ "levothyroxine": [],
  /* 3 */ "lisinopril": [
           "aliskiren", "sacubitril"
         ],
  /* 4 */ "metformin": [],
  /* 5 */ "amlodipine": [],
  /* 6 */ "omeprazole": [
           "rilpivirine", "nelfinavir"
         ],
  /* 7 */ "simvastatin": [
           "itraconazole", "ketoconazole", "posaconazole", "voriconazole",
           "erythromycin", "clarithromycin", "telithromycin", "nelfinavir",
           "ritonavir", "boceprevir", "telaprevir", "nefazodone", "gemfibrozil",
           "cyclosporine", "danazol", "cobicistat", "lomitapide"
         ],
  /* 8 */ "hydrochlorothiazide": [
           "dofetilide", "lithium"
         ],
  /* 9 */ "gabapentin": [],
  /* 10 */ "sertraline": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine", "thioridazine"
         ],
  /* 11 */ "amoxicillin": [],
  /* 12 */ "vitamin_d": [],
  /* 13 */ "ibuprofen": [
           "aspirin", "ketorolac", "methotrexate", "pemetrexed"
         ],
  /* 14 */ "apixaban": [
           "defibrotide"
         ],
  /* 15 */ "montelukast": [],
  /* 16 */ "fluticasone": [
           "ritonavir", "ketoconazole"
         ],
  /* 17 */ "escitalopram": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine"
         ],
  /* 18 */ "rosuvastatin": [
           "cyclosporine", "gemfibrozil", "sofosbuvir_velpatasvir_voxilaprevir",
           "glecaprevir_pibrentasvir"
         ],
  /* 19 */ "pantoprazole": [
           "rilpivirine", "nelfinavir"
         ],
  /* 20 */ "trazodone": [
           "isocarboxazid", "linezoid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine",
           "saquinavir", "thioridazine"
         ],
  /* 21 */ "losartan": [
           "aliskiren"
         ],
  /* 22 */ "metoprolol": [],
  /* 23 */ "albuterol": [],
  /* 24 */ "bupropion": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 25 */ "duloxetine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine",
           "thioridazine"
         ],
  /* 26 */ "prednisone": [
           "itraconazole", "ketoconazole", "mifepristone"
         ],
  /* 27 */ "aspirin": [
           "ketorolac", "methotrexate"
         ],
  /* 28 */ "cetirizine": [
           "levocetirizine"
         ],
  /* 29 */ "azithromycin": [
           "pimozide", "dihydroergotamine", "ergotamine"
         ],
  /* 30 */ "tramadol": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 31 */ "pravastatin": [
           "gemfibrozil"
         ],
  /* 32 */ "clopidogrel": [],
  /* 33 */ "furosemide": [],
  /* 34 */ "fluoxetine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine", "thioridazine"
         ],
  /* 35 */ "citalopram": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine", "dasabuvir"
         ],
  /* 36 */ "warfarin": [
           "defibrotide", "mifepristone"
         ],
  /* 37 */ "doxycycline": [
           "acitretin", "isotretinoin", "methoxyflurane"
         ],
  /* 38 */ "tamsulosin": [],
  /* 39 */ "allopurinol": [
           "didanosine", "azathioprine", "mercaptopurine"
         ],
  /* 40 */ "carvedilol": [],
  /* 41 */ "venlafaxine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 42 */ "propranolol": [
           "thioridazine", "rizatriptan"
         ],
  /* 43 */ "spironolactone": [
           "eplerenone", "triamterene", "amiloride"
         ],
  /* 44 */ "lorazepam": [],
  /* 45 */ "clonazepam": [],
  /* 46 */ "zolpidem": [
           "alcohol"
         ],
  /* 47 */ "cyclobenzaprine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 48 */ "meloxicam": [
           "aspirin", "ketorolac"
         ],
  /* 49 */ "lamotrigine": [
           "dofetilide"
         ],
  /* 50 */ "hydrocodone_acetaminophen": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 51 */ "potassium_chloride": [
           "amiloride", "spironolactone", "triamterene", "eplerenone"
         ],
  /* 52 */ "glipizide": [
           "bosentan"
         ],
  /* 53 */ "methylphenidate": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 54 */ "finasteride": [],
  /* 55 */ "insulin_glargine": [],
  /* 56 */ "esomeprazole": [
           "rilpivirine", "nelfinavir"
         ],
  /* 57 */ "pregabalin": [],
  /* 58 */ "sildenafil": [
           "nitroglycerin", "riociguat", "vericiguat", "amyl_nitrite"
         ],
  /* 59 */ "oxycodone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine",
           "nalmefene", "naltrexone", "samidorphan"
         ],
  /* 60 */ "mirtazapine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 61 */ "alprazolam": [
           "itraconazole", "ketoconazole"
         ],
  /* 62 */ "chlorthalidone": [
           "dofetilide"
         ],
  /* 63 */ "valsartan": [
           "aliskiren", "sacubitril"
         ],
  /* 64 */ "cephalexin": [],
  /* 65 */ "buspirone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 66 */ "diclofenac": [
           "aspirin", "ketorolac"
         ],
  /* 67 */ "levetiracetam": [],
  /* 68 */ "risperidone": [],
  /* 69 */ "ramipril": [
           "aliskiren", "sacubitril"
         ],
  /* 70 */ "aripiprazole": [],
  /* 71 */ "nitroglycerin": [
           "sildenafil", "tadalafil", "vardenafil", "avanafil",
           "riociguat", "vericiguat"
         ],
  /* 72 */ "quetiapine": [
           "pimozide", "thioridazine"
         ],
  /* 73 */ "atenolol": [],
  /* 74 */ "topiramate": [],
  /* 75 */ "lovastatin": [
           "itraconazole", "ketoconazole", "posaconazole", "voriconazole",
           "erythromycin", "clarithromycin", "telithromycin", "nelfinavir",
           "ritonavir", "boceprevir", "telaprevir", "nefazodone", "gemfibrozil",
           "cyclosporine", "danazol", "cobicistat", "lomitapide"
         ],
  /* 76 */ "tiotropium": [
           "ipratropium"
         ],
  /* 77 */ "adalimumab": [
           "anakinra", "abatacept", "etanercept", "infliximab",
           "golimumab", "certolizumab_pegol"
         ],
  /* 78 */ "semaglutide": [],
  /* 79 */ "tirzepatide": [],
  /* 80 */ "ferrous_sulfate": [
           "dimercaprol"
         ],
  /* 81 */ "calcium_carbonate": [
           "ceftriaxone", "sodium_polystyrene_sulfonate"
         ],
  /* 82 */ "fish_oil": [],
  /* 83 */ "multivitamin": [
           "levodopa"
         ],
  /* 84 */ "magnesium": [
           "raltegravir", "elvitegravir", "dolutegravir", "bictegravir"
         ],
  /* 85 */ "probiotics": [],
  /* 86 */ "coenzyme_q10": [],
  /* 87 */ "melatonin": [],
  /* 88 */ "vitamin_c": [],
  /* 89 */ "vitamin_b12": [
           "chloramphenicol"
         ],
  /* 90 */ "zinc": [
           "penicillamine"
         ],
  /* 91 */ "glucosamine": [],
  /* 92 */ "turmeric": [],
  /* 93 */ "vitamin_e": [
           "warfarin", "dicumarol"
         ],
  /* 94 */ "vitamin_k": [
           "warfarin", "anisindione", "dicumarol"
         ],
  /* 95 */ "collagen": [],
  /* 96 */ "biotin": [],
  /* 97 */ "folic_acid": [
           "methotrexate", "pyrimethamine", "raltitrexed"
         ],
  /* 98 */ "cranberry_extract": [],
  /* 99 */ "ashwagandha": [],
  /* 100 */ "elderberry": [],
  /* 101 */ "benzonatate": [],
  /* 102 */ "budesonide": [
           "ketoconazole", "itraconazole", "ritonavir", "clarithromycin"
         ],
  /* 103 */ "carbidopa_levodopa": [
           "isocarboxazid", "phenelzine", "procarbazine", "tranylcypromine"
         ],
  /* 104 */ "celecoxib": [
           "ketorolac", "aspirin"
         ],
  /* 105 */ "ciprofloxacin": [
           "tizanidine", "agomelatine", "flibanserin", "lomitapide",
           "pimozide", "thioridazine"
         ],
  /* 106 */ "clonidine": [],
  /* 107 */ "donepezil": [],
  /* 108 */ "enalapril": [
           "aliskiren", "sacubitril"
         ],
  /* 109 */ "ezetimibe": [
           "cyclosporine"
         ],
  /* 110 */ "famotidine": [],
  /* 111 */ "fexofenadine": [],
  /* 112 */ "hydralazine": [],
  /* 113 */ "hydroxyzine": [
           "amifampridine", "droperidol", "pimozide", "thioridazine"
         ],
  /* 114 */ "indapamide": [
           "dofetilide", "sulpiride"
         ],
  /* 115 */ "insulin_aspart": [],
  /* 116 */ "ipratropium": [
           "tiotropium", "aclidinium", "umeclidinium", "revefenacin",
           "glycopyrrolate"
         ],
  /* 117 */ "isosorbide": [
           "sildenafil", "tadalafil", "vardenafil", "avanafil",
           "riociguat", "vericiguat"
         ],
  /* 118 */ "ketoconazole": [
           "alfuzosin", "amiodarone", "apixaban", "astemizole", "bepridil",
           "cisapride", "colchicine", "conivaptan", "dabigatran", "darifenacin",
           "disopyramide", "dofetilide", "domperidone", "dronedarone",
           "eletriptan", "eplerenone", "ergotamine", "dihydroergotamine",
           "ergometrine", "methylergometrine", "felodipine", "fesoterodine",
           "flibanserin", "halofantrine", "irinotecan", "isavuconazonium",
           "ivabradine", "levacetylmethadol", "lomitapide", "loperamide",
           "lovastatin", "lurasidone", "methadone", "mifepristone",
           "mizolastine", "naloxegol", "nisoldipine", "oral_midazolam",
           "pimozide", "quinidine", "ranolazine", "rivaroxaban", "salmeterol",
           "sertindole", "simvastatin", "sirolimus", "solifenacin",
           "tacrolimus", "terfenadine", "ticagrelor", "tolvaptan",
           "triazolam", "udenafil", "vardenafil", "vincristine", "voclosporin"
         ],
  /* 119 */ "liraglutide": [],
  /* 120 */ "loratadine": [],
  /* 121 */ "memantine": [],
  /* 122 */ "methocarbamol": [],
  /* 123 */ "metronidazole": [
           "disulfiram", "alcohol", "busulfan"
         ],
  /* 124 */ "mupirocin": [],
  /* 125 */ "nifedipine": [
           "rifampin"
         ],
  /* 126 */ "olanzapine": [
           "samidorphan", "thioridazine", "mesoridazine"
         ],
  /* 127 */ "ondansetron": [
           "apomorphine", "dronedarone", "pimozide", "thioridazine"
         ],
  /* 128 */ "oxybutynin": [],
  /* 129 */ "paroxetine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "thioridazine", "tranylcypromine"
         ],
  /* 130 */ "pioglitazone": [],
  /* 131 */ "promethazine": [
           "amifampridine", "bepridil", "cisapride", "dronedarone",
           "levomethadyl", "mesoridazine", "pimozide", "piperaquine",
           "sparfloxacin", "terfenadine", "thioridazine", "ziprasidone"
         ],
  /* 132 */ "ranitidine": [],
  /* 133 */ "ropinirole": [
           "sulpiride", "metoclopramide", "thioridazine"
         ],
  /* 134 */ "sotalol": [
           "amifampridine", "amisulpride", "anagrelide", "arsenic_trioxide",
           "astemizole", "azithromycin", "bepridil", "chloroquine",
           "chlorpromazine", "ciprofloxacin", "cisapride", "citalopram",
           "clarithromycin", "clozapine", "crizotinib", "dabrafenib",
           "dasatinib", "degarelix", "delamanid", "disopyramide",
           "dofetilide", "dolasetron", "domperidone", "donepezil",
           "dronedarone", "droperidol", "eribulin", "erythromycin",
           "escitalopram", "famotidine", "fingolimod", "flecainide",
           "fluconazole", "fluoxetine", "foscarnet", "fosphenytoin",
           "galantamine", "gatifloxacin", "gemifloxacin", "glasdegib",
           "granisetron", "halofantrine", "haloperidol", "hydroxychloroquine",
           "hydroxyzine", "ibutilide", "iloperidone", "imipramine",
           "inotuzumab_ozogamicin", "itraconazole", "ivabradine", "ivosidenib",
           "ketoconazole", "lapatinib", "lenvatinib", "leuprolide",
           "levofloxacin", "lithium", "lofexidine", "lumefantrine",
           "macimorelin", "mefloquine", "mesoridazine", "methadone",
           "metronidazole", "mifepristone", "mirtazapine", "mizolastine",
           "mobocertinib", "moxifloxacin", "nilotinib", "norfloxacin",
           "octreotide", "ofloxacin", "olanzapine", "ondansetron",
           "osimertinib", "oxaliplatin", "paliperidone", "panobinostat",
           "papaverine", "paroxetine", "pasireotide", "pazopanib",
           "pentamidine", "perphenazine", "pimavanserin", "pimozide",
           "piperaquine", "pitolisant", "ponesimod", "posaconazole",
           "probucol", "procainamide", "prochlorperazine", "promazine",
           "promethazine", "propafenone", "protriptyline", "quetiapine",
           "quinidine", "quinine", "ranolazine", "relugolix", "ribociclib",
           "risperidone", "ritonavir", "saquinavir", "selpercatinib",
           "sertindole", "sertraline", "sevoflurane", "siponimod",
           "sodium_phosphate", "solifenacin", "sorafenib", "sparfloxacin",
           "sulpiride", "sunitinib", "tacrolimus", "tamoxifen", "telavancin",
           "telithromycin", "terfenadine", "tetrabenazine", "thioridazine",
           "toremifene", "trazodone", "triclabendazole", "trimethoprim",
           "trimipramine", "vandetanib", "vardenafil", "vemurafenib",
           "venlafaxine", "vinflunine", "voriconazole", "vorinostat",
           "ziprasidone", "zolmitriptan", "zuclopenthixol"
         ],
  /* 135 */ "sulfamethoxazole_trimethoprim": [
           "dofetilide", "methenamine", "leucovorin"
         ],
  /* 136 */ "terazosin": [
           "sildenafil", "tadalafil", "vardenafil", "avanafil"
         ],
  /* 137 */ "timolol": [],
  /* 138 */ "tolterodine": [
           "clarithromycin", "itraconazole", "ketoconazole", "ritonavir"
         ],
  /* 139 */ "triamterene": [
           "amiloride", "spironolactone", "eplerenone", "potassium_supplements"
         ],
  /* 140 */ "valacyclovir": [],
  /* 141 */ "verapamil": [
           "atazanavir", "cisapride", "colchicine", "dabigatran",
           "dofetilide", "dronedarone", "eletriptan", "eplerenone",
           "ergotamine", "flibanserin", "ivabradine", "lomitapide",
           "lovastatin", "lurasidone", "naloxegol", "ranolazine",
           "rivaroxaban", "simvastatin", "sirolimus", "tacrolimus",
           "tolvaptan", "udenafil", "voclosporin"
         ],
  /* 142 */ "acyclovir": [],
  /* 143 */ "amiodarone": [
           "atazanavir", "bepridil", "cisapride", "cobicistat",
           "colchicine", "darunavir", "dasabuvir", "digitoxin",
           "disopyramide", "dofetilide", "domperidone", "dronedarone",
           "eliglustat", "elvitegravir", "fingolimod", "flecainide",
           "fluconazole", "fosamprenavir", "gemifloxacin", "halofantrine",
           "ibutilide", "idelalisib", "indinavir", "itraconazole",
           "ivabradine", "ketoconazole", "ledipasvir", "lenvatinib",
           "lopinavir_ritonavir", "lorlatinib", "lumefantrine",
           "mavacamten", "mefloquine", "mesoridazine", "mifepristone",
           "moxifloxacin", "nelfinavir", "nilotinib", "ombitasvir_paritaprevir_ritonavir",
           "pacritinib", "pentamidine", "pimozide", "piperaquine",
           "posaconazole", "procainamide", "propafenone", "quetiapine",
           "quinidine", "ranolazine", "ribociclib", "ritonavir",
           "saquinavir", "simeprevir", "simvastatin", "sofosbuvir",
           "sorafenib", "sotalol", "sparfloxacin", "sulpiride",
           "tacrolimus", "tamoxifen", "telaprevir", "telithromycin",
           "terfenadine", "tetrabenazine", "thioridazine", "tipranavir",
           "toremifene", "trazodone", "vandetanib", "vemurafenib",
           "venetoclax", "vinflunine", "voriconazole", "ziprasidone"
         ],
  /* 144 */ "baclofen": [],
  /* 145 */ "betamethasone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 146 */ "brimonidine": [
           "isocarboxazid", "phenelzine", "procarbazine", "rasagiline",
           "selegiline", "tranylcypromine"
         ],
  /* 147 */ "candesartan": [
           "aliskiren"
         ],
  /* 148 */ "chlorhexidine": [],
  /* 149 */ "colchicine": [
           "atazanavir", "clarithromycin", "cyclosporine", "darunavir",
           "elvitegravir_cobicistat", "fluconazole", "fosamprenavir",
           "idelalisib", "indinavir", "itraconazole", "ketoconazole",
           "lopinavir_ritonavir", "mifepristone", "nelfinavir",
           "ombitasvir_paritaprevir_ritonavir_dasabuvir", "posaconazole",
           "ranolazine", "ritonavir", "saquinavir", "telaprevir",
           "telithromycin", "tipranavir", "verapamil", "voriconazole"
         ],
  /* 150 */ "dabigatran": [
           "rifampin", "tipranavir", "dronedarone", "ketoconazole",
           "itraconazole", "cyclosporine"
         ],
  /* 151 */ "desvenlafaxine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 152 */ "digoxin": [],
  /* 153 */ "diltiazem": [
           "cisapride", "colchicine", "dabigatran", "dofetilide",
           "dronedarone", "eletriptan", "eplerenone", "ergotamine",
           "flibanserin", "ivabradine", "lomitapide", "lovastatin",
           "lurasidone", "naloxegol", "pimozide", "rivaroxaban",
           "simvastatin", "sirolimus", "tacrolimus", "tolvaptan",
           "udenafil", "voclosporin"
         ],
  /* 154 */ "divalproex": [
           "meropenem"
         ],
  /* 155 */ "dorzolamide": [],
  /* 156 */ "dronedarone": [
           "amifampridine", "amiodarone", "apomorphine", "arsenic_trioxide",
           "asenapine", "astemizole", "atazanavir", "bepridil", "boceprevir",
           "chloroquine", "chlorpromazine", "ciprofloxacin", "cisapride",
           "citalopram", "clarithromycin", "clofazimine", "clomipramine",
           "clozapine", "cobicistat", "colchicine", "conivaptan",
           "crizotinib", "cyclosporine", "dabigatran", "darunavir",
           "dasatinib", "degarelix", "delamanid", "desipramine",
           "dibenzepin", "disopyramide", "dofetilide", "dolasetron",
           "domperidone", "donepezil", "droperidol", "efavirenz",
           "eliglustat", "encorafenib", "entrectinib", "eribulin",
           "erythromycin", "escitalopram", "famotidine", "fexinidazole",
           "fingolimod", "flecainide", "fluconazole", "fluoxetine",
           "formoterol", "foscarnet", "fostemsavir", "galantamine",
           "gatifloxacin", "gemifloxacin", "gepirone", "givinostat",
           "glasdegib", "granisetron", "halofantrine", "haloperidol",
           "hydroxychloroquine", "hydroxyzine", "ibutilide", "idelalisib",
           "iloperidone", "imipramine", "indinavir", "inotuzumab_ozogamicin",
           "itraconazole", "ivabradine", "ivosidenib", "ketoconazole",
           "lapatinib", "lenvatinib", "leuprolide", "levofloxacin",
           "levoketoconazole", "lithium", "lofepramine", "lopinavir",
           "lovastatin", "lumefantrine", "lurasidone", "macimorelin",
           "mefloquine", "mesoridazine", "methadone", "metronidazole",
           "mifepristone", "mirtazapine", "mizolastine", "mobocertinib",
           "moxifloxacin", "nafarelin", "nelfinavir", "nefazodone",
           "nilotinib", "norfloxacin", "nortriptyline", "octreotide",
           "ofloxacin", "olanzapine", "ondansetron", "osilodrostat",
           "osimertinib", "ozanimod", "paliperidone", "panobinostat",
           "papaverine", "paroxetine", "pasireotide", "pazopanib",
           "pentamidine", "perphenazine", "phenobarbital", "pimavanserin",
           "pimozide", "piperaquine", "pipothiazine", "pitolisant",
           "ponesimod", "posaconazole", "primidone", "probucol",
           "procainamide", "prochlorperazine", "promazine", "promethazine",
           "propafenone", "protriptyline", "quetiapine", "quinidine",
           "quinine", "ranolazine", "relugolix", "ribociclib", "rifabutin",
           "rifampin", "rifapentine", "risperidone", "ritonavir",
           "saquinavir", "selpercatinib", "sertindole", "sertraline",
           "sevoflurane", "simeprevir", "simvastatin", "siponimod",
           "sirolimus", "sodium_phosphate", "solifenacin", "sorafenib",
           "sotalol", "sparfloxacin", "sulpiride", "sunitinib", "tacrolimus",
           "tamoxifen", "telaprevir", "telavancin", "telithromycin",
           "terfenadine", "tetrabenazine", "thioridazine", "toremifene",
           "trazodone", "triclabendazole", "trimipramine", "triptorelin",
           "vandetanib", "vardenafil", "vemurafenib", "venlafaxine",
           "verapamil", "vinflunine", "voclosporin", "voriconazole",
           "vorinostat", "ziprasidone", "zolmitriptan", "zuclopenthixol"
         ],
  /* 157 */ "eletriptan": [
           "atazanavir", "clarithromycin", "cobicistat", "darunavir",
           "diltiazem", "elvitegravir", "ergotamine", "fosamprenavir",
           "idelalisib", "indinavir", "itraconazole", "ketoconazole",
           "lopinavir", "nefazodone", "nelfinavir", "posaconazole",
           "ritonavir", "saquinavir", "telaprevir", "telithromycin",
           "tipranavir", "troleandomycin", "verapamil", "voriconazole"
         ],
  /* 158 */ "empagliflozin": [],
  /* 159 */ "enoxaparin": [
           "defibrotide"
         ],
  /* 160 */ "erythromycin": [
           "alfuzosin", "astemizole", "cisapride", "colchicine",
           "dihydroergotamine", "domperidone", "dronedarone", "eletriptan",
           "eplerenone", "ergotamine", "flibanserin", "ivabradine",
           "lomitapide", "lovastatin", "lurasidone", "mevastatin",
           "mifepristone", "naloxegol", "nisoldipine", "oral_midazolam",
           "pimozide", "ranolazine", "rivaroxaban", "saquinavir",
           "silodosin", "simvastatin", "suvorexant", "tasimelteon",
           "terfenadine", "ticagrelor", "tolvaptan", "triazolam",
           "udenafil", "vardenafil", "voclosporin"
         ],
  /* 161 */ "estradiol": [
           "anastrozole", "exemestane", "letrozole", "ospemifene",
           "tamoxifen"
         ],
  /* 162 */ "etanercept": [
           "anakinra", "abatacept", "adalimumab", "infliximab"
         ],
  /* 163 */ "exenatide": [],
  /* 164 */ "fenofibrate": [
           "simvastatin", "rosuvastatin"
         ],
  /* 165 */ "fluconazole": [
           "alfuzosin", "astemizole", "bepridil", "cisapride",
           "colchicine", "darunavir", "dofetilide", "domperidone",
           "dronedarone", "eletriptan", "eliglustat", "eplerenone",
           "ergotamine", "dihydroergotamine", "erythromycin",
           "fesoterodine", "flibanserin", "halofantrine", "irinotecan",
           "isavuconazonium", "ivabradine", "levacetylmethadol",
           "lomitapide", "lopinavir", "lovastatin", "lurasidone",
           "methadone", "mifepristone", "mizolastine", "naloxegol",
           "nisoldipine", "oral_midazolam", "pimozide", "quinidine",
           "ranolazine", "rivaroxaban", "saquinavir", "sertindole",
           "silodosin", "simvastatin", "sirolimus", "solifenacin",
           "tacrolimus", "terfenadine", "thioridazine", "ticagrelor",
           "tipranavir", "tolvaptan", "triazolam", "udenafil",
           "vardenafil", "venetoclax", "vincristine", "voclosporin",
           "voriconazole", "ziprasidone"
         ],
  /* 166 */ "fluvoxamine": [
           "agomelatine", "alosetron", "astemizole", "cisapride",
           "dronedarone", "eplerenone", "eliglustat", "frovatriptan",
           "isocarboxazid", "ivabradine", "linezolid", "lomitapide",
           "lurasidone", "mesoridazine", "methylene_blue", "mevastatin",
           "mizolastine", "nelfinavir", "phenelzine", "pimozide",
           "procarbazine", "ramelteon", "rasagiline", "ropivacaine",
           "saquinavir", "selegiline", "silodosin", "simvastatin",
           "tacrine", "terfenadine", "theophylline", "thioridazine",
           "tizanidine", "tolvaptan", "tranylcypromine", "triazolam",
           "udenafil", "ziprasidone"
         ],
  /* 167 */ "folic_acid": [
           "methotrexate", "pyrimethamine", "raltitrexed"
         ],
  /* 168 */ "gemfibrozil": [
           "atorvastatin", "cerivastatin", "dasabuvir", "ezetimibe",
           "fluvastatin", "lovastatin", "mevastatin", "pitavastatin",
           "pravastatin", "repaglinide", "rosuvastatin", "selexipag",
           "simvastatin"
         ],
  /* 169 */ "glimepiride": [
           "bosentan"
         ],
  /* 170 */ "glyburide": [
           "bosentan"
         ],
  /* 171 */ "heparin": [
           "defibrotide"
         ],
  /* 172 */ "hydrocortisone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 173 */ "imatinib": [
           "alfuzosin", "astemizole", "bepridil", "cisapride",
           "colchicine", "conivaptan", "darunavir", "dihydroergotamine",
           "domperidone", "dronedarone", "eletriptan", "eplerenone",
           "ergotamine", "fesoterodine", "flibanserin", "halofantrine",
           "irinotecan", "isavuconazonium", "ivabradine", "ketoconazole",
           "levacetylmethadol", "lomitapide", "lovastatin", "lurasidone",
           "methadone", "mifepristone", "mizolastine", "naloxegol",
           "nisoldipine", "oral_midazolam", "pimozide", "quinidine",
           "ranolazine", "rivaroxaban", "salmeterol", "sertindole",
           "silodosin", "simvastatin", "sirolimus", "solifenacin",
           "tacrolimus", "terfenadine", "thioridazine", "ticagrelor",
           "tolterodine", "tolvaptan", "triazolam", "udenafil",
           "vardenafil", "venetoclax", "vincristine", "voclosporin",
           "voriconazole", "ziprasidone"
         ],
  /* 174 */ "irbesartan": [
           "aliskiren"
         ],
  /* 175 */ "labetalol": [
           "thioridazine"
         ],
  /* 176 */ "latanoprost": [],
  /* 177 */ "linagliptin": [],
  /* 178 */ "lisdexamfetamine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 179 */ "lithium": [
           "sodium_polystyrene_sulfonate", "thioridazine", "ziprasidone"
         ],
  /* 180 */ "loperamide": [
           "eluxadoline", "gemfibrozil", "itraconazole", "ketoconazole",
           "ritonavir", "saquinavir", "tipranavir"
         ],
  /* 181 */ "meclizine": [
           "potassium_chloride"
         ],
  /* 182 */ "methotrexate": [
           "acitretin", "aspirin", "probenecid", "co_trimoxazole",
           "nitrous_oxide"
         ],
  /* 183 */ "methylprednisolone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 184 */ "minocycline": [
           "acitretin", "isotretinoin", "methoxyflurane", "penicillin"
         ],
  /* 185 */ "mometasone": [
           "ritonavir", "ketoconazole"
         ],
  /* 186 */ "morphine": [
           "isocarboxazid", "linezolid", "methylene_blue", "nalmefene",
           "naltrexone", "phenelzine", "procarbazine", "rasagiline",
           "selegiline", "samidorphan", "tranylcypromine"
         ],
  /* 187 */ "mycophenolate": [
           "azathioprine", "sevelamer", "cholestyramine"
         ],
  /* 188 */ "naproxen": [
           "aspirin", "ketorolac", "methotrexate", "pemetrexed"
         ],
  /* 189 */ "nebivolol": [
           "thioridazine"
         ],
  /* 190 */ "nortriptyline": [
           "cisapride", "dronedarone", "isocarboxazid", "linezolid",
           "mesoridazine", "methylene_blue", "phenelzine", "pimozide",
           "procarbazine", "rasagiline", "safinamide", "selegiline",
           "thioridazine", "tranylcypromine"
         ],
  /* 191 */ "olmesartan": [
           "aliskiren"
         ],
  /* 192 */ "oseltamivir": [],
  /* 193 */ "oxcarbazepine": [
           "eslicarbazepine"
         ],
  /* 194 */ "phenazopyridine": [],
  /* 195 */ "phenytoin": [
           "delavirdine", "rilpivirine", "doravirine", "isavuconazonium",
           "praziquantel", "voriconazole"
         ],
  /* 196 */ "prazosin": [
           "riociguat", "sildenafil", "tadalafil", "vardenafil", "avanafil"
         ],
  /* 197 */ "prochlorperazine": [
           "amifampridine", "astemizole", "bepridil", "cisapride",
           "dronedarone", "fluoxetine", "levomethadyl", "mesoridazine",
           "metrizamide", "paroxetine", "pimozide", "piperaquine",
           "propafenone", "quinidine", "saquinavir", "sparfloxacin",
           "terfenadine", "thioridazine", "toremifene", "ziprasidone"
         ],
  /* 198 */ "propofol": [],
  /* 199 */ "raloxifene": [
           "cholestyramine"
         ],
  /* 200 */ "rivaroxaban": [
           "atazanavir", "carbamazepine", "clarithromycin", "cobicistat",
           "conivaptan", "darunavir", "defibrotide", "elvitegravir",
           "enzalutamide", "fosamprenavir", "idelalisib", "indinavir",
           "itraconazole", "ketoconazole", "lopinavir", "lumacaftor",
           "mifepristone", "mitotane", "nelfinavir", "nefazodone",
           "ombitasvir_paritaprevir_ritonavir_dasabuvir", "phenobarbital",
           "phenytoin", "posaconazole", "primidone", "rifampin",
           "rifabutin", "rifapentine", "ritonavir", "saquinavir",
           "telaprevir", "tipranavir", "troleandomycin", "voriconazole"
         ],
  /* 201 */ "rizatriptan": [
           "ergotamine", "isocarboxazid", "linezolid", "methylene_blue",
           "phenelzine", "procarbazine", "propranolol", "rasagiline",
           "selegiline", "tranylcypromine"
         ],
  /* 202 */ "salmeterol": [
           "atazanavir", "clarithromycin", "cobicistat", "darunavir",
           "elvitegravir", "fosamprenavir", "idelalisib", "indinavir",
           "itraconazole", "ketoconazole", "lopinavir", "nefazodone",
           "nelfinavir", "posaconazole", "ritonavir", "saquinavir",
           "telaprevir", "telithromycin", "tipranavir", "troleandomycin",
           "voriconazole"
         ],
  /* 203 */ "saxagliptin": [],
  /* 204 */ "sitagliptin": [],
  /* 205 */ "sumatriptan": [
           "ergotamine", "isocarboxazid", "linezolid", "methylene_blue",
           "phenelzine", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine"
         ],
  /* 206 */ "tacrolimus": [
           "astemizole", "cisapride", "cyclosporine", "dronedarone",
           "fluconazole", "itraconazole", "ketoconazole", "mifepristone",
           "pimozide", "posaconazole", "ritonavir", "terfenadine",
           "thioridazine", "tipranavir", "voriconazole", "ziprasidone"
         ],
  /* 207 */ "telmisartan": [
           "aliskiren"
         ],
  /* 208 */ "temazepam": [
           "sodium_oxybate"
         ],
  /* 209 */ "terbinafine": [
           "eliglustat", "flibanserin", "pimozide", "tamoxifen",
           "thioridazine"
         ],
  /* 210 */ "testosterone": [],
  /* 211 */ "tizanidine": [
           "ciprofloxacin", "fluvoxamine", "acyclovir"
         ],
  /* 212 */ "torsemide": [],
  /* 213 */ "trandolapril": [
           "aliskiren", "sacubitril"
         ],
  /* 214 */ "triamcinolone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 215 */ "valproic_acid": [
           "meropenem"
         ],
  /* 216 */ "vardenafil": [
           "amyl_nitrite", "atazanavir", "boceprevir", "cobicistat",
           "darunavir", "elvitegravir", "fosamprenavir", "idelalisib",
           "indinavir", "isosorbide_dinitrate", "isosorbide_mononitrate",
           "itraconazole", "ketoconazole", "lopinavir", "mifepristone",
           "nelfinavir", "nitroglycerin", "posaconazole", "riociguat",
           "ritonavir", "saquinavir", "telaprevir", "tipranavir",
           "vericiguat", "voriconazole"
         ],
  /* 217 */ "vilazodone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 218 */ "voriconazole": [
           "alfuzosin", "aprepitant", "astemizole", "atorvastatin",
           "avanafil", "barbiturates", "bosutinib", "bromocriptine",
           "carbamazepine", "cisapride", "colchicine", "conivaptan",
           "dabrafenib", "darunavir", "domperidone", "dronedarone",
           "efavirenz", "eletriptan", "eliglustat", "encorafenib",
           "entrectinib", "eplerenone", "ergotamine", "dihydroergotamine",
           "eslicarbazepine", "estazolam", "everolimus", "fesoterodine",
           "flibanserin", "fluconazole", "fosamprenavir", "fostamatinib",
           "glasdegib", "halofantrine", "hydroxyzine", "idelalisib",
           "indinavir", "irinotecan", "isavuconazonium", "isoniazid",
           "ivabradine", "ivacaftor", "ivosidenib", "lapatinib",
           "levacetylmethadol", "lomitapide", "lopinavir", "lorlatinib",
           "lovastatin", "lumacaftor", "lurasidone", "mavacamten",
           "mefloquine", "mesoridazine", "methadone", "mifepristone",
           "mitotane", "mizolastine", "mobocertinib", "naloxegol",
           "nelfinavir", "neratinib", "nilotinib", "nisoldipine",
           "olaparib", "omaveloxolone", "oral_midazolam", "osilodrostat",
           "osimertinib", "oxcarbazepine", "palbociclib", "panobinostat",
           "pazopanib", "phenytoin", "pimavanserin", "pimozide",
           "piperaquine", "pitavastatin", "pralsetinib", "quetiapine",
           "quinidine", "ranolazine", "regorafenib", "repotrectinib",
           "ribociclib", "rifabutin", "rifampin", "rimegepant",
           "ritonavir", "rivaroxaban", "romidepsin", "rosuvastatin",
           "salmeterol", "saquinavir", "selumetinib", "sertindole",
           "silodosin", "simeprevir", "simvastatin", "sirolimus",
           "sonidegib", "sotorasib", "sunitinib", "suvorexant",
           "tacrolimus", "tadalafil", "tamoxifen", "tasimelteon",
           "tazemetostat", "terfenadine", "tetrabenazine", "thioridazine",
           "ticagrelor", "tipranavir", "tolterodine", "tolvaptan",
           "trabectedin", "trazodone", "triazolam", "ubrogepant",
           "udenafil", "ulipristal", "vandetanib", "vardenafil",
           "vemurafenib", "venetoclax", "vincristine", "vinflunine",
           "voclosporin", "ziprasidone", "zolpidem"
         ],
  /* 219 */ "zaleplon": [
           "sodium_oxybate"
         ],
  /* 220 */ "zonisamide": [
           "topiramate"
         ],
  /* 221 */ "acetaminophen": [],
  /* 222 */ "alendronate": [],
  /* 223 */ "anastrozole": [
           "estradiol", "tamoxifen", "raloxifene"
         ],
  /* 224 */ "azathioprine": [
           "febuxostat", "allopurinol"
         ],
  /* 225 */ "benazepril": [
           "aliskiren", "sacubitril"
         ],
  /* 226 */ "bimatoprost": [],
  /* 227 */ "bisoprolol": [
           "thioridazine"
         ],
  /* 228 */ "buprenorphine": [
           "nalmefene", "naltrexone", "samidorphan"
         ],
  /* 229 */ "cholecalciferol": [],
  /* 230 */ "cimetidine": [
           "astemizole", "cisapride", "dofetilide", "eliglustat",
           "flibanserin", "lomitapide", "pimozide", "terfenadine",
           "thioridazine"
         ],
  /* 231 */ "clarithromycin": [
           "alfuzosin", "astemizole", "cisapride", "colchicine",
           "dihydroergotamine", "domperidone", "dronedarone", "eletriptan",
           "eplerenone", "ergotamine", "fesoterodine", "flibanserin",
           "ivabradine", "levacetylmethadol", "lomitapide", "lovastatin",
           "lurasidone", "mevastatin", "mifepristone", "naloxegol",
           "nisoldipine", "oral_midazolam", "pimozide", "ranolazine",
           "rivaroxaban", "saquinavir", "salmeterol", "silodosin",
           "simvastatin", "suvorexant", "tacrolimus", "tasimelteon",
           "terfenadine", "thioridazine", "ticagrelor", "tolterodine",
           "tolvaptan", "triazolam", "udenafil", "vardenafil",
           "venetoclax", "voclosporin"
         ],
  /* 232 */ "clindamycin": [],
  /* 233 */ "clobetasol": [],
  /* 234 */ "clozapine": [
           "amifampridine", "bepridil", "cisapride", "dronedarone",
           "fluoxetine", "fluvoxamine", "levomethadyl", "mesoridazine",
           "metoclopramide", "paroxetine", "pimozide", "piperaquine",
           "saquinavir", "sertraline", "sparfloxacin", "terfenadine",
           "thioridazine", "ziprasidone"
         ],
  /* 235 */ "codeine": [
           "isocarboxazid", "linezolid", "methylene_blue", "nalmefene",
           "naltrexone", "phenelzine", "procarbazine", "rasagiline",
           "selegiline", "samidorphan", "tranylcypromine"
         ],
  /* 236 */ "dexamethasone": [
           "desmopressin", "itraconazole", "ketoconazole", "mifepristone",
           "ritonavir", "praziquantel", "rilpivirine"
         ],
  /* 237 */ "diazepam": [
           "sodium_oxybate"
         ],
  /* 238 */ "docusate": [
           "mineral_oil"
         ],
  /* 239 */ "entacapone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 240 */ "eplerenone": [
           "clarithromycin", "itraconazole", "ketoconazole", "nefazodone",
           "nelfinavir", "posaconazole", "ritonavir", "saquinavir",
           "telithromycin", "voriconazole", "potassium_supplements"
         ],
  /* 241 */ "felodipine": [
           "carbamazepine", "clarithromycin", "erythromycin", "itraconazole",
           "ketoconazole", "nefazodone", "phenobarbital", "phenytoin",
           "rifampin", "ritonavir", "telithromycin"
         ],
  /* 242 */ "flurazepam": [
           "sodium_oxybate", "itraconazole", "ketoconazole", "ritonavir"
         ],
  /* 243 */ "fosfomycin": [],
  /* 244 */ "haloperidol": [
           "amifampridine", "astemizole", "bepridil", "cisapride",
           "dronedarone", "fluoxetine", "itraconazole", "ketoconazole",
           "levomethadyl", "mesoridazine", "metoclopramide", "paroxetine",
           "pimozide", "piperaquine", "probucol", "propafenone",
           "quinidine", "saquinavir", "sertindole", "sparfloxacin",
           "terfenadine", "thioridazine", "toremifene", "ziprasidone"
         ],
  /* 245 */ "hydroxychloroquine": [
           "amifampridine", "dronedarone", "fingolimod", "halofantrine",
           "mefloquine", "pimozide", "saquinavir", "tamoxifen",
           "thioridazine", "ziprasidone"
         ],
  /* 246 */ "infliximab": [
           "anakinra", "abatacept", "adalimumab", "etanercept"
         ],
  /* 247 */ "isoniazid": [
           "disulfiram", "carbamazepine", "phenytoin", "valproic_acid"
         ],
  /* 248 */ "ketorolac": [
           "aspirin", "celecoxib", "diclofenac", "diflunisal", "etodolac",
           "fenoprofen", "flurbiprofen", "ibuprofen", "indomethacin",
           "ketoprofen", "meclofenamate", "mefenamic_acid", "meloxicam",
           "nabumetone", "naproxen", "oxaprozin", "pentoxifylline",
           "piroxicam", "probenecid", "sulindac", "tolmetin"
         ],
  /* 249 */ "letrozole": [
           "estradiol", "tamoxifen", "raloxifene"
         ],
  /* 250 */ "lidocaine": [
           "amiodarone", "dofetilide", "dronedarone", "propafenone",
           "quinidine", "tocainide"
         ]
};

function canonicalDrugKey(name) {
  return (name || '').toLowerCase().replace(/[^a-z0-9]/g,'').trim();
}

function hasContra(orderObj, wholeList = []) {
  /* real check can be added later */
  return false;
}

    const commonMedications = [
      { generic: "hydrocodone/acetaminophen", brands: ["Norco", "Vicodin", "Lortab", "Zamicet"] },
      { generic: "oxycodone/acetaminophen",  brands: ["Percocet", "Xartemis XR", "Roxicet", "Endocet"] },
               { generic: "codeine/acetaminophen",     brands: ["Tylenol #3"] },
               { generic: "tramadol/acetaminophen",    brands: ["Ultracet"] },
               { generic: "acetaminophen/caffeine/dihydrocodeine", brands: ["Panlor SS", "Trezix"] },
               { generic: "aspirin/caffeine/dihydrocodeine",       brands: ["Synalgos-DC"] },
               { generic: "aspirin/codeine",            brands: ["Empirin with codeine"] },
               { generic: "acetaminophen/butalbital/caffeine", brands: ["Fioricet", "Esgic", "Zebutal"] },
               { generic: "aspirin/butalbital/caffeine", brands: ["Fiorinal"] },
               { generic: "acetaminophen/butalbital",   brands: ["Bupap"] },
               { generic: "hydrocodone/pseudoephedrine", brands: ["Rezira"] },
               { generic: "hydrocodone/chlorpheniramine", brands: ["Tussionex", "Hycomine"] },
               { generic: "hydrocodone/homatropine",    brands: ["Hydromet"] },
               { generic: "busulfan",                   brands: ["Myleran"] },
               { generic: "acetaminophen/isometheptene/dichloralphenazone", brands: ["Midrin"] },
               { generic: "ibuprofen/oxycodone",        brands: ["Combunox"] },
      { generic: "acetaminophen", brands: ["Tylenol"] },
      { generic: "albuterol", brands: ["Ventolin", "ProAir", "Proventil", "salbutamol"] },
      { generic: "allopurinol", brands: ["Zyloprim"] },
      { generic: "alprazolam", brands: ["Xanax"] },
      { generic: "amlodipine", brands: ["Norvasc"] },
      { generic: "amoxicillin", brands: ["Amoxil", "Trimox"] },
      { generic: "aspirin", brands: ["Bayer", "Ecotrin"] },
      { generic: "atenolol", brands: ["Tenormin"] },
      { generic: "atorvastatin", brands: ["Lipitor"] },
      { generic: "azithromycin", brands: ["Zithromax", "Z-Pak"] },
      { generic: "bisoprolol", brands: ["Zebeta"] },
      { generic: "budesonide", brands: ["Pulmicort", "Rhinocort"] },
              { generic: "budesonide/formoterol", brands: ["Symbicort"] },
               {   generic: "calcium gluconate",  brands: [] },
               {   generic: "calcium chloride",   brands: [] },
               {   generic: "calcium carbonate",  brands: [] },
               {   generic: "calcium citrate",    brands: [] }, 
      { generic: "cefuroxime", brands: ["Ceftin", "Zinacef"] },
      { generic: "cephalexin", brands: ["Keflex"] },
      { generic: "cetirizine", brands: ["Zyrtec"] },
              { generic: "loratadine", brands: ["Claritin"] },
      { generic: "ciprofloxacin", brands: ["Cipro"] },
      { generic: "citalopram", brands: ["Celexa"] },
      { generic: "clindamycin", brands: ["Cleocin"] },
      { generic: "clonazepam", brands: ["Klonopin"] },
      { generic: "clopidogrel", brands: ["Plavix"] },
      { generic: "cyclobenzaprine", brands: ["Flexeril"] },
      { generic: "digoxin", brands: ["Lanoxin"] },
      { generic: "doxycycline", brands: ["Vibramycin"] },
      { generic: "duloxetine", brands: ["Cymbalta"] },
      { generic: "enalapril", brands: ["Vasotec"] },
      { generic: "escitalopram", brands: ["Lexapro"] },
      { generic: "esomeprazole", brands: ["Nexium"] },
      { generic: "ferrous sulfate", brands: [] },
      { generic: "fluoxetine", brands: ["Prozac"] },
      { generic: "fluticasone", brands: ["Flonase", "Flovent"] },
      { generic: "furosemide", brands: ["Lasix"] },
      { generic: "gabapentin", brands: ["Neurontin"] },
      { generic: "glipizide", brands: ["Glucotrol"] },
      { generic: "glyburide", brands: ["Diabeta", "Micronase"] },
      { generic: "hydralazine", brands: ["Apresoline"] },
      { generic: "hydrochlorothiazide", brands: ["Microzide", "HCTZ"] },
      { generic: "ibuprofen", brands: ["Advil", "Motrin"] },
              { generic: "insulin aspart", brands: ["Novolog"] },
      { generic: "insulin glargine", brands: ["Lantus", "Basaglar", "Lantus Solostar"] },
      { generic: "insulin lispro", brands: ["Humalog"] },
      { generic: "irbesartan", brands: ["Avapro"] },
      { generic: "isosorbide mononitrate", brands: ["Imdur"] },
      { generic: "ketorolac", brands: ["Toradol"] },
      { generic: "levothyroxine", brands: ["Synthroid", "Levoxyl"] },
      { generic: "lisinopril", brands: ["Prinivil", "Zestril"] },
      { generic: "lisinopril-hydrochlorothiazide", brands: ["Zestoretic"] },
      { generic: "lorazepam", brands: ["Ativan"] },
      { generic: "losartan", brands: ["Cozaar"] },
      { generic: "melatonin", brands: [] },
      { generic: "meloxicam", brands: ["Mobic"] },
      { generic: "metformin", brands: ["Glucophage"] },
      { generic: "methotrexate", brands: ["Trexall"] },
      { generic: "metoprolol", brands: ["Lopressor", "Toprol XL"] },
      { generic: "montelukast", brands: ["Singulair"] },
      { generic: "naproxen", brands: ["Aleve", "Naprosyn"] },
      { generic: "nifedipine", brands: ["Procardia", "Adalat"] },
      { generic: "nystatin", brands: ["Mycostatin"] },
      { generic: "omeprazole", brands: ["Prilosec"] },
      { generic: "oxycodone", brands: ["OxyContin", "Roxicodone"] },
      { generic: "pantoprazole", brands: ["Protonix"] },
      {   generic:    "polyethylene glycol",  brands: ["MiraLAX","GaviLAX","GlycoLax","PEG 3350"] },
              { generic: "potassium chloride", brands: ["Klor-Con", "K-Dur", "Micro-K"] },
      { generic: "pravastatin", brands: ["Pravachol"] },
      { generic: "prednisone", brands: ["Deltasone"] },
      { generic: "propranolol", brands: ["Inderal"] },
      { generic: "quinapril", brands: ["Accupril"] },
      { generic: "ranitidine", brands: ["Zantac"] },
      { generic: "rosuvastatin", brands: ["Crestor"] },
      { generic: "sertraline", brands: ["Zoloft"] },
      { generic: "simvastatin", brands: ["Zocor"] },
      { generic: "sitagliptin", brands: ["Januvia"] },
      { generic: "sotalol", brands: ["Betapace"] },
      { generic: "spironolactone", brands: ["Aldactone"] },
      { generic: "sulfamethoxazole-trimethoprim", brands: ["Bactrim", "Septra"] },
      { generic: "tamsulosin", brands: ["Flomax"] },
      { generic: "tramadol", brands: ["Ultram"] },
      { generic: "trazodone", brands: ["Desyrel"] },
      { generic: "valacyclovir", brands: ["Valtrex"] },
      { generic: "valproic acid", brands: ["Depakene"] },
      { generic: "venlafaxine", brands: ["Effexor"] },
      { generic: "verapamil", brands: ["Calan", "Verelan"] },
      { generic: "warfarin", brands: ["Coumadin"] },
      { generic: "zolpidem", brands: ["Ambien"] },
      { generic: "amphetamine/dextroamphetamine", brands: ["Adderall", "Adderall XR"] },
      { generic: "alendronate", brands: ["Fosamax"] },
      { generic: "tadalafil", brands: ["Cialis"] },
      { generic: "fluticasone/umeclidinium/vilanterol", brands: ["Trelegy"] },
      { generic: "empagliflozin", brands: ["Jardiance"] },
      { generic: "semaglutide", brands: ["Ozempic", "Wegovy"] },
               { generic: "vitamin d", brands: ["Drisdol", "vitamin d3", "cholecalciferol"] },
      { generic: "prednisolone", brands: ["Pred Forte"] },
      { generic: "enoxaparin", brands: ["Lovenox", "Clexane"] },
      { generic: "doxorubicin", brands: ["Adriamycin"] },
      { generic: "adalimumab", brands: ["Humira"] },
      { generic: "rivaroxaban", brands: ["Xarelto"] },
      { generic: "methylphenidate", brands: ["Ritalin", "Concerta"] },
      { generic: "memantine", brands: ["Namenda"] },
               { generic: "tiotropium", brands: ["Spiriva", "Spiriva HandiHaler", "Spiriva Respimat"] },
      { generic: "isosorbide", brands: [] },
      { generic: "isosorbide dinitrate", brands: [] }
    ];
	// ——— Map every brand name to its generic ———
    const brandToGenericMap = {};
    commonMedications.forEach(({ generic, brands }) => {
      brands.forEach(brand => {
        brandToGenericMap[brand.toLowerCase()] = generic.toLowerCase();
      });
    });

    // Extra brand spellings not captured above
    Object.assign(brandToGenericMap, {
      'k dur': 'potassium chloride',
      'k-dur': 'potassium chloride',
      kdur: 'potassium chloride',
      'tiotropium bromide': 'tiotropium',
      'fluticasone propionate': 'fluticasone'
    });

    // ——— Map every generic to its brands ———
  const genericToBrandMap = {};
  Object.entries(brandToGenericMap).forEach(([brand, generic]) => {
    if (!genericToBrandMap[generic]) genericToBrandMap[generic] = [];
    genericToBrandMap[generic].push(brand);
  });


  const ignoreSalts = /\b(hydrochloride|sulfate|phosphate|acetate|carbonate|maleate|succinate|tartrate|mesylate|besylate|camsylate|gluconate|bitartrate|edisylate|propionate|sodium|potassium|calcium|magnesium|fumarate)\b/gi;
  const trivialSalts = /\b(sodium|sulfate|phosphate|acetate|carbonate|succinate|maleate|tartrate|mesylate|besylate|camsylate|gluconate|bitartrate|edisylate|propionate|calcium|magnesium|fumarate|hydrochloride)\b/gi;

  const importantSaltPairs = [
    ['diclofenac sodium',      'diclofenac potassium'],
    ['cyclosporine',           'cyclosporine modified'],
    ['ferrous sulfate',        'ferrous gluconate']
  ];

  const genericSynonyms = {
    hctz: 'hydrochlorothiazide',
    hydrochlorothiazide: 'hydrochlorothiazide'
  };
  genericSynonyms['tiotropium bromide'] = 'tiotropium';
  genericSynonyms['fluticasone propionate'] = 'fluticasone';
  genericSynonyms['kcl'] = 'potassium chloride';
  genericSynonyms['iron'] = 'ferrous';
  genericSynonyms['iron sulfate'] = 'ferrous sulfate';


  function normalizeMedicationName(name) {
    if (!name) return { name: '', brandTok: [] };
    let n = name.toLowerCase().trim();
    const brandTok = [];

    n = n.replace(ignoreSalts, '').replace(/\s{2,}/g, ' ').trim();

    /* 1 .  Convert any brand name that appears anywhere in the text
       (e.g. "symbicort 160/4.5") to its generic. */
      for (const brand in brandToGenericMap) {
        const re = new RegExp('\\b' + brand + '\\b', 'gi');
        n = n.replace(re, match => {
          const token = match.toLowerCase();
          if (brandTok.length === 0 && !brandTok.includes(token)) {
            brandTok.push(token);
          }
          return brandToGenericMap[brand];
        });
      }

      // Apply generic synonyms after brand replacements
      for (const syn in genericSynonyms) {
        const reSyn = new RegExp('\\b' + syn + '\\b', 'gi');
        n = n.replace(reSyn, genericSynonyms[syn]);
      }

    // normalize common formulation abbreviations early
    n = n.replace(/\b(xl|xr)\b/, 'er');

    // separate letters and numbers so "warfarin5mg" becomes "warfarin 5mg"
    n = n.replace(/([a-z])([0-9])/gi, '$1 $2')
         .replace(/([0-9])([a-z])/gi, '$1 $2');

    /* 2 .  Strip common salt words */
    const commonSalts = [
      'hydrochloride', 'hcl',
      'sodium', 'potassium',
      'acetate', 'phosphate', 'carbonate',
      'maleate', 'succinate', 'tartrate',
      'besylate', 'camsylate', 'mesylate',
      'gluconate', 'propionate', 'bitartrate', 'edisylate',
      'nacl'
    ];
    commonSalts.sort((a,b) => b.length - a.length);
    for (const salt of commonSalts) {
      const saltRegex = new RegExp(salt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      n = n.replace(saltRegex, ' ');
    }
    n = n.replace(/\s+/g, ' ').trim();

    // Remove common descriptive modifiers like "extra strength" or "pm"
    const commonModifiers = [
        'extra strength', 'regular strength', 'maximum strength',
        'extra', 'regular', 'maximum',
        'pm', 'am', 'advanced', 'complete',
        'childrens', 'infants',
        'arthritis pain', 'cold & flu', 'cold and flu', 'sinus', 'allergy',
        'headache', 'migraine', 'multi symptom', 'daytime', 'nighttime'
    ];
    commonModifiers.sort((a, b) => b.length - a.length);
    for (const modifier of commonModifiers) {
        const modifierRegex = new RegExp(`\\b${modifier.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&')}\\b`, 'gi');
        n = n.replace(modifierRegex, ' ');
    }
    n = n.replace(/\s+/g, ' ').trim();

    /* 3 .  Remove timing / meal phrases that sneak into the name */
    n = n.replace(/\b(?:\d+\s*(?:min(?:ute)?s?|hr|hrs?|hours?)\s*)?(?:at|before|after|with|without)\s+(?:breakfast|lunch|dinner|meal(?:s)?|night|bedtime|morning|evening)\b/ig, '')
         .trim();

    /* 4. Remove common leftover instructional/form words and numbers from name string */
    n = n.replace(/\b\d+(?:\.\d+)?\b/g, '');
    n = n.replace(/\b(?:tablet|tablets|tab|tabs|cap|capsule|capsules|caplet|oral|po|subq|sc|im|iv|id|pr|sl|os|od|au|oin|oint|ophth|neb|inh|inj|inject|supp|sol|solution|susp|elix|syr|tr|tinct|lot|crm|crm.|ung|gel|aero|conc|dil|dp|ds|emuls|enema|er|film|gas|gran|gum|impl|inf|ins|irrig|jec|liq|lotn|loz|mdi|hfa|mis|nebu|oint|oph|pad|part|pas|past|pel|pen|pill|plst|powd|pwd|rinse|sat|shamp|soak|spg|spl|spray|stk|strip|subl|sup|swab|syr|sys|tab|tamp|tape|top|troche|twa|vag|wafer|xt|xr|xl|xd|sr|cr|dr|la|patch|puffs|drops|lozenge|spray|unit|units|ml|mcg|mg|g|solostar|actuation)\b/gi, '');

    /* 5. Final cleanup */
    n = n.replace(/[\/\-]/g, ' ')
         .replace(/[^a-z0-9 ]+/g, '')
         .replace(/\s+/g, ' ')
         .trim();

    // 6. Drop trailing noise words like dosing instructions or route leftovers
    n = n.replace(/\b(?:daily|weekly|bid|tid|qid|q\d+h|every|once|monday|tuesday|wednesday|thursday|friday|saturday|sunday|mon|tue|wed|thu|fri|sat|sun|m\/?w\/?f|m\s*w\s*f|tu\/?th\/?sa\/?su|ttsu|in|po|sc|im|iv|combination|combo)\b.*$/i, '');
    // 7. Drop leading verbs that accidentally made it into the drug name
    n = n.replace(/^(?:take|give|inject|inhale|apply|use)\b\s*/i, '');

    n = n.trim();

  return { name: n, brandTok };
}

    const unitVariants = {
  tablet:   ['tab','tabs','tablet','tablets','tab.','tablet.'],
  capsule:  ['cap','caps','capsule','capsules','caplet','cap.','gelcap','softgel','gel','sprinkle','sprinkles'],
  spray:    ['spray','sprays'],
  puff:     ['puff','puffs'],
  drop:     ['drop','drops','gtt','gtts','gt','drp'],
  patch:    ['patch','patches','transdermal patch'],
   injection:['shot','syringe','pen','inj','auto-injector','flexpen','solostar'],
  lozenge:  ['lozenge','loz','troche'],
  suppository:['supp','suppositories'],
  solution: ['solution','sol','liq','liquid','oral sol'],
  ointment: ['ointment','oint','ung','cream','gel'],
     inhalation:['inhaler','inh','neb','nebulizer','mdi','dpi','respimat','handihaler'],
  unit:     ['U','IU','units'],
  mL:       ['ml','mL','cc'],
  mcg:      ['μg','mcg','ug'],
  mg:       ['mg'],
  mEq:      ['meq', 'mEq', 'milliequivalents'],
  g:        ['g','gram','grams']
};

    let photo1Files = [];
    let photo2Files = [];
    let meds1 = [], meds2 = [];
    let hasTextInput1 = false; // Track if Photo 1 used text input
    let hasTextInput2 = false; // Track if Photo 2 used text input

    async function processFiles(files) {
  let allCombinedOrderStrings = [];
  let lowConfidence = false;
  const totalFiles = files.length;
  let currentFileIndex = 0;

  for (let file of files) {
    currentFileIndex++;
    showLoading(`Processing image ${currentFileIndex} of ${totalFiles}...`);
    try {
      const result = await processFile(file); // result.text is raw OCR text from one image
      // keepOrderLines processes raw text from one image into an array of order strings
      const orderStringsFromFile = keepOrderLines(result.text);
      const entries = orderStringsFromFile.map(t => ({ text: t, confidence: result.confidence }));
      allCombinedOrderStrings = allCombinedOrderStrings.concat(entries);

      if (result.confidence < 0.8) {
        lowConfidence = true;
      }
    } catch (err) {
      console.error("Error processing file: ", file.name, err);
      showError(`Error processing file ${file.name}. Some data may be missing.`);
    }
  }

  if (lowConfidence) {
    showError("Warning: Some OCR text was unclear and may not be accurate. Please review manually.");
  }
  // Return a flat array of unique processed order objects from all images
  const unique = [];
  const seen = new Set();
  allCombinedOrderStrings.forEach(entry => {
    const t = (entry.text || '').trim();
    if (!t || seen.has(t)) return;
    seen.add(t);
    unique.push(entry);
  });
  return unique;
}

function processFile(file) {
  return new Promise((resolve, reject) => {
    if (!file) {
      console.error('No file provided to processFile');
      reject(new Error("No file provided"));
      return;
    }
    if (DEBUG) console.log('Processing file:', file.name, file.type, file.size);
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        if (!e.target.result) {
          console.error('FileReader result is undefined');
          throw new Error('FileReader result is undefined');
        }
        const imageData = e.target.result;
        if (DEBUG) console.log('Sending image data:', imageData.substring(0, 100));
        const payload = { data: { image: imageData } };
        if (DEBUG) console.log('Payload being sent:', payload);
        const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
        const response = await callOcrFunction(payload);
        if (DEBUG) console.log('Received response from callOcrTest:', response);
        if (!response.data || typeof response.data !== 'object') {
          throw new Error('Invalid response from OCR function');
        }
        resolve(response.data);
      } catch (err) {
        console.error('Error in processFile:', err);
        reject(err);
      }
    };
    reader.onerror = () => {
      console.error('FileReader error:', reader.error);
      reject(new Error("File could not be read: " + reader.error));
    };
    reader.readAsDataURL(file);
  });
}
async function testCallOcr() {
  try {
    const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
    const payload = { data: { test: "Hello, world!" } };
    if (DEBUG) console.log('Testing callOcrTest with payload:', payload);
    const response = await callOcrFunction(payload);
    if (DEBUG) console.log('Test response from callOcrTest:', response);
  } catch (err) {
    console.error('Error in testCallOcr:', err);
  }
}
    /**
     * If a single line actually contains two orders (two doses),
     * split it into two.
     */
    function splitConcatOrders(line) {
      // look for two dose patterns in one line
      const doseRegex = /\d+\s*(?:mg|mcg|g|mL|tablet|capsule|puff|drop|unit|IU)\b/gi;
      const matches = [...line.matchAll(doseRegex)];
      if (matches.length > 1) {
        const splitAt = matches[1].index;
        return [
          line.slice(0, splitAt).trim(),
          line.slice(splitAt).trim()
        ];
      }
      return [ line ];
    }

    /**
     * If a “continuation” line didn’t itself name a drug,
     * glue it back onto the previous order.
     */
    function mergeMultiLineOrders(lines) {
      const merged = [];
      lines.forEach(l => {
        if (/^[a-z]/i.test(l) && /\d/.test(l)) {
          // starts like an order → new entry
          merged.push(l);
        } else if (merged.length) {
          // continuation → append
          merged[merged.length - 1] += ' ' + l;
        } else {
          // no previous → keep alone
          merged.push(l);
        }
      });
      return merged;
    }

    /**
     * Merge “Day 1…”, “Day 2…” lines (taper packs) back onto
     * the preceding order line.
     */
    function mergeTaperPackOrders(lines) {
      const out = [];
      lines.forEach(l => {
        if (/^day\s*\d+/i.test(l) && out.length) {
          out[out.length - 1] += ' ' + l;
        } else {
          out.push(l);
        }
      });
      return out;
    }

function mergeEMRLines(lines) {
  const mergedOrders = [];
  let i = 0;
  if (DEBUG) console.log("mergeEMRLines: Input lines count:", lines.length); // Log total lines
  while (i < lines.length) {
    const line1 = lines[i]?.trim();
    if (!line1) { 
      i++;
      continue;
    }

    const isOrderStartLine1 =
    /^[a-zA-Z\s.-]+\s+\d+(?:\.\d+)?\s*(?:mg|mcg|g|u|iu|units?|ml|meq|unit\/ml)\s+[a-zA-Z\s.-]+$/i.test(line1) || // Added units: u, iu, meq, unit/ml. Added 'i' flag. Escaped '/'.
    /^[a-zA-Z\s.-]+\s+inhaler$/i.test(line1); // Added 'i' flag for case-insensitivity

    const line2 = lines[i + 1]?.trim();
    const line3 = lines[i + 2]?.trim();

    // DEBUGGING LOGS START HERE
    if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")) { // Focus on problem meds
        if (DEBUG) {
        console.log("------------------------------------");
        console.log("mergeEMRLines checking:", JSON.stringify(line1));
        console.log("  isOrderStartLine1:", isOrderStartLine1);
        console.log("  line2:", JSON.stringify(line2));
        console.log("  line3:", JSON.stringify(line3));
        }
    }
    // DEBUGGING LOGS END HERE

    // This is your NEW line2 condition block
    const line2ConditionMet = line2 && 
        (
            ['give', 'take', 'inhale', 'inject', 'apply', 'use', 'place', 'administer', 'chew', 'dissolve', 'spray', 'sprinkle'].some(kw => line2.toLowerCase().startsWith(kw + ' ')) ||
            /^(day\s*\d+|take\s*\d+\s*tab)/i.test(line2.toLowerCase())
        );

    const line3ConditionMet = line3 && line3.toLowerCase().startsWith('start:');

    // MORE DEBUGGING LOGS
    if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")) {
         if (DEBUG) {
         console.log("  line2ConditionMet:", line2ConditionMet);
         console.log("  line3ConditionMet:", line3ConditionMet);
         }
    }
    // DEBUGGING LOGS END

    if (isOrderStartLine1 && line2ConditionMet && line3ConditionMet) {
      if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")){
        if (DEBUG) console.log("  DECISION: MERGING these 3 lines.");
      }
      mergedOrders.push(`${line1} ${line2} ${line3}`);
      i += 3; 
    } else {
      if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")){
        if (DEBUG) console.log("  DECISION: NOT MERGING. Pushing line1 only:", JSON.stringify(line1));
      }
      mergedOrders.push(line1); 
      i += 1; 
    }
  }
  if (DEBUG) console.log("mergeEMRLines: Output mergedOrders count:", mergedOrders.length); // Log output count
  return mergedOrders;
}

    // ←── END INSERT ──▶

//=== STEP 1  keepOrderLines helper =========================
function keepOrderLines(rawText) {
  //— flatten any tab-separated rows into free-text orders —
  if (rawText.includes('\t')) {
    rawText = rawText
      .split(/\r?\n+/)
      .map(line => {
        const cols = line.split('\t');
        if (cols.length >= 6) {
          return `${cols[0].trim()} ${cols[1].trim()} ${cols[2].trim()} ${cols[3].trim()} on ${cols[4].trim()} for ${cols[5].trim()}`;
        }
        return line;
      })
      .join('\n');
  }

  const DEBUG_JUNK = false;

  // 1. Initial split by newline and trim each line.
  //    This provides a basic array of lines as they appear in the input.
  let lines = rawText.split(/\r?\n+/).map(line => line.trim());
  // console.log("DEBUG keepOrderLines - Initial split & trimmed lines:", JSON.parse(JSON.stringify(lines)));

  // 2. Apply EMR-specific 3-line merging.
  //    This function should now receive lines that are only split by original newlines.
  lines = mergeEMRLines(lines);
  // console.log("DEBUG keepOrderLines - After mergeEMRLines:", JSON.parse(JSON.stringify(lines)));

  // 3. Now, apply further cleaning and other processing to each (potentially merged) line.
  let processedLines = lines.map(line => {
    // The logic from the old STEP-SPLITMULTI (handling commas, semicolons, 'and')
    // is now applied to *each individual line string* after EMR merging.
    // Importantly, it replaces these separators with a SPACE, not a newline,
    // to avoid re-splitting merged lines.
    let modifiedLine = line.replace(/(?:,|;|\band\b)/gi, ' ');
    modifiedLine = modifiedLine.replace(/\s{2,}/g, ' '); // Collapse multiple spaces that might result

    // Then, apply the cleanLine function to this modifiedLine.
    return cleanLine(modifiedLine.trim()); // cleanLine also trims
  });
  // console.log("DEBUG keepOrderLines - After comma/semicolon/and replacement and cleanLine map:", JSON.parse(JSON.stringify(processedLines)));

  // 4. Split lines that might themselves contain two distinct orders (e.g., "Drug A ... Drug B")
  //    This function expects to operate on single strings.
  //processedLines = processedLines.flatMap(splitConcatOrders);
  // console.log("DEBUG keepOrderLines - After splitConcatOrders:", JSON.parse(JSON.stringify(processedLines)));

  // 5. Final filter for valid-looking order lines
  const finalFilteredLines = processedLines.filter(line => {
    const keep =
      line.trim() && // Ensure line is not just whitespace after all processing
      isLikelyOrderLine(line) &&
      (containsKnownMedication(line) ||
        /\d+\s*(mg|mcg|g|mL|units|tablet|capsule|puff|drop)\b/i.test(line)) &&
      /\d/.test(line);
    if (!keep && DEBUG_JUNK && line.trim()) console.log('🗑️ Final filter dropping line:', line);
    return keep;
  });
  // console.log("DEBUG keepOrderLines - Final output:", JSON.parse(JSON.stringify(finalFilteredLines)));
  return finalFilteredLines;
}
//=== END STEP 1 ============================================

    function cleanLine(line) {
  	// 1) drop any “number.” or “number)” at the start
  	line = line.replace(/^\s*\d+[\.\)]\s*/, '');
  	// 2) remove trailing non-alphanumeric junk and trim
  	return line.replace(/[^a-z0-9]+$/i, '').trim();
}

// ——— remove trailing junk from merged lines ———
function pruneLine(line) {
  // keep dose → form → route → freq → PRN → “for … pain” or “moderate pain”
  // only strip off trailing garbage like “;” or OCR noise, but preserve any
  // remaining words (e.g. “for hypertension” or “heart failure”)
  return line.trim();
 }

    function isLikelyOrderLine(line) {
      //=== STEP 3  stricter test
if (line.length < 5) return false;
const good = (line.match(/[a-z0-9]/gi) || []).length;
return good / line.length >= 0.5;
//=== END STEP 3
    }

function containsKnownMedication(line) {
  const lower = line.toLowerCase();

  // 1) Critical meds always match
  if (criticalMeds.some(med => lower.includes(med))) return true;

  // 2) Any brand name in commonMedications also counts
  if (commonMedications.some(m =>
        m.brands.some(b => lower.includes(b.toLowerCase()))
      )) return true;

  // 3) Generic names or dose patterns as before
  return commonMedications.some(med => lower.includes(med.generic))
      || /\d+\s*(?:mg|mcg|units|puffs|tabs?|tablets?|capsules?)\b/.test(lower);
}

    // ——— Text normalizer — no more stat inside statin ———
function normalizeText(str) {
  let text = (str || '').toLowerCase()

    // your existing expansions…
    .replace(/\bnow\b/g, 'immediately')
    // only match "stat" when it's not embedded in another word
    .replace(/(?<![a-z])stat(?![a-z])/g, 'immediately')
    .replace(/\bqhs\b/g, 'at bedtime')
    .replace(/\bnightly\b/g, 'at bedtime')
    // NEW – map the common abbreviation
    .replace(/\bsob\b/g, 'shortness of breath')
    // …all the rest of your shorthand/frequency → full-text rules…

  // final cleanup:
  return text
    .replace(/\s+/g, ' ')
    .trim();
}

function normalizeIndicationText(txt = '') {
  let s = txt.toLowerCase()
             .replace(/[.;,]+/g, ' ')
               .replace(/\bstart\s*date.*$/g,'')
              .replace(/\b(?:start|date)\b/g,'')
              .replace(/\b(?:spray|inject|inhale|use|apply|puff|inhalations?|contents|device|handihaler|respimat|flexpen|each|per|in|via|of|one|two)\b/gi,'')
             .replace(/\s+/g,' ')
             .trim();

  const synonyms = {
    'afib': 'atrial fibrillation',
    'af': 'atrial fibrillation',
    'a fib': 'atrial fibrillation',
    'atrial fib': 'atrial fibrillation',
    'sob':'breathing difficulty',
    'shortness of breath':'breathing difficulty',
    'anxious':'anxiety',
    'wheezing':'breathing difficulty',
    'nerve pain':'neuropathy',
    'neuropathy':'neuropathy'
  };
  if (synonyms[s]) s = synonyms[s];
    return s;
}

function normalizeIndication(txt) {
  if (!txt) return '';

  txt = txt
    .toLowerCase()
    .replace(/[.;,]+/g, ' ')
    .replace(/\bstart\s*date.*$/i, '');

  const painDescriptors = ['mild pain', 'moderate pain', 'severe pain'];
  const tokens = {};
  painDescriptors.forEach(desc => {
    const token = `_pain_${desc.replace(/\s+/g, '_')}_`;
    tokens[desc] = token;
    txt = txt.replace(new RegExp(`\\b${desc}\\b`, 'g'), token);
  });

  txt = txt
    .replace(/\b(type\s*2\s*)?diabetes\b/g, 'diabetes')
    .replace(/\b(htn|hypertension|high blood pressure)\b/g, 'hypertension')
    .replace(/\bhigh cholesterol\b/g, 'cholesterol')
    .replace(/\bhyperlipidemia\b/g, 'cholesterol')
    .replace(/\banxious\b/g, 'anxiety')
    .replace(/\bas needed\b/g, 'prn')
    .replace(/\bfor sleep\b/i, 'sleep');

  txt = txt
    .replace(/\banticoag(ulation)? clinic\b/gi, '')
    .replace(/\binr\s*\d+(?:\.\d+)?\s*-\s*\d+(?:\.\d+)?\b/gi, '')
    .replace(/\b(no\s+)?taper\b/gi, '');

  const fillerRE =
    /\b(?:po|by mouth|orally|tablet?s?|tab|daily|every day|in evening|evening|at bedtime|morning|stop|no taper|taper|for \d+\s*days?)\b/gi;
  txt = txt
    .replace(fillerRE, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  const synonyms = {
    'shortness of breath': 'breathing difficulty',
    sob: 'breathing difficulty',
    wheezing: 'breathing difficulty',
    'nerve pain': 'neuropathy',
    neuropathy: 'neuropathy',
    afib: 'atrial fibrillation',
    af: 'atrial fibrillation',
    'a fib': 'atrial fibrillation',
    'atrial fib': 'atrial fibrillation'
  };
  if (synonyms[txt]) txt = synonyms[txt];

  // Map common INR monitoring instructions to unique tokens
  let processedTxt = txt.toLowerCase();
  if (/\badjust\s+(?:per\s+)?inr\b/.test(processedTxt)) {
    processedTxt = processedTxt.replace(/\badjust\s+(?:per\s+)?inr\b/g, '_unique_inr_adjust_protocol_');
  }
  if (/\bcheck\s+inr\s+weekly\b/.test(processedTxt)) {
    processedTxt = processedTxt.replace(/\bcheck\s+inr\s+weekly\b/g, '_unique_inr_check_weekly_protocol_');
  } else if (/\bcheck\s+inr\b/.test(processedTxt)) {
    processedTxt = processedTxt.replace(/\bcheck\s+inr\b/g, '_unique_inr_check_protocol_');
  }

  txt = processedTxt;

  Object.entries(tokens).forEach(([desc, token]) => {
    txt = txt.replace(new RegExp(token, 'g'), desc);
  });

  return txt.replace(/\s+/g, ' ').trim();
}

function normalizeTimeOfDay(t) {
  if (!t) return '';
    const aliases = {
      morning: 'morning',
      qam: 'morning',
      am: 'morning',
      'every am': 'morning',
      'every morning': 'morning',
      'in morning': 'morning',
      'in the morning': 'morning',
      'daily in morning': 'morning',
      evening: 'bedtime',
      evenings: 'bedtime',
      pm: 'bedtime',
      qpm: 'bedtime',
      'every evening': 'bedtime',
      'daily in evening': 'bedtime',
      'in evening': 'bedtime',
      'in the evening': 'bedtime',
      'in the evenings': 'bedtime',
      'in the pm': 'bedtime',
      bedtime: 'bedtime',
      night: 'bedtime',
      qhs: 'bedtime',
      nightly: 'bedtime',
      'at bedtime': 'bedtime',
      'at night': 'bedtime',
      'every night': 'bedtime',
      noon: 'noon',
      midday: 'noon',
      'at noon': 'noon'
    };
  t = t.toLowerCase().trim();
  if (aliases[t]) return aliases[t];
  for (const key in aliases) {
    if (t.includes(key)) return aliases[key];
  }
  return t;
}

// Determine if the time of day changed between two orders
function todChanged(orig, updated) {
  // Normalize any explicit time-of-day token (qam, morning, evening, qhs …)
  const norm = s => normalizeTimeOfDay(s || '').trim(); // "" if none

  const oTok = norm(orig.timeOfDay || orig.frequency);
  const uTok = norm(updated.timeOfDay || updated.frequency);

  if (!oTok && !uTok) return false; // neither specifies TOD
  return oTok !== uTok; // tokens differ → TOD shift
}

// Compare two indication strings using the existing normalization logic.
// If either side is blank after normalization, they're considered equal.
function sameIndication(a, b) {
  const i1 = normalizeIndication(a);
  const i2 = normalizeIndication(b);
  if (!i1 || !i2) return true;
  return i1 === i2;
}

function getFrequencyMap() {
  return {
    'once daily': 'daily',
    'once a day': 'daily',
    '1 times daily': 'daily',
    daily: 'daily',
    od: 'daily',
    qd: 'daily',
    'every morning': 'daily',
    'daily in morning': 'daily',
    'daily in the morning': 'daily',
    'daily in evening': 'daily',
    'daily in the evening': 'daily',
    'daily at noon': 'daily',
    'daily in noon': 'daily',
    'twice daily': 'bid',
    '2 times daily': 'bid',
    '2 times a day': 'bid',
    'two times daily': 'bid',
    'two times a day': 'bid',      // NEW alias → BID
    'twice a day': 'bid',
    bid: 'bid',
    'twice a day with meals': 'bid',
    'twice daily with meals': 'bid',
    'three times daily': 'tid',
    'three times a day': 'tid',
    '3 times daily': 'tid',
    tid: 'tid',
    tidac: 'tid',
    'before meals': 'tid',
    'with meals': 'tid',
    'before breakfast lunch dinner': 'tid',
    'four times daily': 'qid',
    'four times a day': 'qid',
    '4 times daily': 'qid',
    qid: 'qid',
    'every other day': 'every other day',
    qod: 'every other day',
    'every 4-6 hours': 'q4-6h',
    'every 4 to 6 hours': 'q4-6h',
    stat: 'immediately',
    now: 'immediately',
    immediately: 'immediately',
    weekly: 'weekly',
    'once a week': 'weekly',
    'once per week': 'weekly',
    monthly: 'monthly',
    'once a month': 'monthly'
  };
}

function normalizeFrequency(str) {
  if (!str) return '';
  str = str.toLowerCase().trim();
  // replace numeric words with digits so "three times" => "3 times"
  str = str.replace(/\b(one|two|three|four|five|six|seven|eight|nine|ten)\b/g,
    w => String(numericWord(w))
  );
  const freqMap = getFrequencyMap();
  const sorted = Object.keys(freqMap).sort((a, b) => b.length - a.length);
  for (const key of sorted) {
    const pattern = new RegExp(`\\b${key.replace(/\s+/g, '\\s+')}\\b`, 'i');
    if (pattern.test(str)) return freqMap[key];
  }
  const numTimes = str.match(/(\d+)\s*times?\s*(?:a|per)?\s*day\b/);
  if (numTimes) {
    const n = parseInt(numTimes[1], 10);
    if (n === 2) return 'bid';
    if (n === 3) return 'tid';
    if (n === 4) return 'qid';
    return str;
  }
  const weeklyRE = /once\s+(per\s+)?week(ly)?/i;
  if (weeklyRE.test(str)) return 'weekly';
  return str;
}

// Map frequency phrases to a numeric occurrences-per-day value
function freqNumeric(freqStr) {
  if (!freqStr) return 1; // treat blank as daily
  const f = normalizeFrequency(freqStr);
  const map = {
    daily: 1,
    bid: 2,
    tid: 3,
    qid: 4,
    weekly: 1 / 7,
    monthly: 1 / 30,
    'every other day': 0.5,
    immediately: 0,
    qam: 1,
    qpm: 1,
    qhs: 1,
    hs: 1,
    nightly: 1
  };

  /* every N hours or N-M hours → treat first number as the interval */
  const ev = f.match(/\bevery\s*(\d+)(?:\s*-\s*(\d+))?\s*hours?\b/i);
  if (ev) return 24 / parseInt(ev[1], 10);
  const range = /^q(\d+)-(\d+)h$/i.exec(f);
  if (range) {
    const min = Number(range[1]);
    const max = Number(range[2]);
    const avg = (min + max) / 2;
    return 24 / avg;
  }
  const qh = /^q(\d+)h$/i.exec(f);
  if (qh) return 24 / Number(qh[1]);
  const qd = /^q(\d+)d$/i.exec(f);
  if (qd) return 1 / Number(qd[1]);
  const times = /(\d+)\s*times?\s*(?:a|per)?\s*day\b/.exec(f);
  if (times) return Number(times[1]);
  return map[f] != null ? map[f] : null;
}

// Numeric occurrences per day helper (wrapper around freqNumeric)
const perDay = f => {
  const n = freqNumeric(f);
  return n == null ? null : n;
};

/* ---------- simple word→number helper (one-ten) ---------- */
function numericWord(w) {
  return (
    {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10
    }[w.toLowerCase()] ?? null
  );
}

// ---------- QUANTITY PARSER ----------
function parseQuantity(str){
  // matches "2 tabs", "one tablet", "½ tab", etc.
  const m = str.match(/(\d+\/\d+|[\u00bc-\u00be]|\d+(?:\.\d+)?|\w+)\s*(tabs?|caps?|tablets?|capsules?)/i);
  if(!m) return null;
  const raw = m[1];
  const num = fractionToDecimal(raw);
  if(!Number.isNaN(num)) return num;
  return numericWord(raw) ?? null;
}

function quantitiesMatch(o1,o2){
  // treat null === 1 (implicit single tablet)
  const q1=o1.quantity??1, q2=o2.quantity??1;
  return q1===q2;
}

function canonFormulation(f) {
  if (!f) return '';
  return f
    .toLowerCase()
    .replace(/\b(?:extended[- ]?release|xl|xr|sr|cr)\b/g, 'er')
    .trim();
}

function normalizeAdministration(str) {
  if (!str) return '';
  str = str.toLowerCase().replace(/\s+/g, ' ').trim();
  if (/\bwith\s+(?:orange\s*juice|food|meals?|dinner|supper)\b/.test(str)) {
    return 'with food';
  }
  if (/\b(between\s+meals|without\s+(food|meal)s?|empty\s*stomach)\b/.test(str)) {
    return 'between meals';
  }
  return str.trim();
}

function inhaled(parsedOrder) {
    if (!parsedOrder) return false;
    const route = (parsedOrder.route || '').toLowerCase();
    const form = (parsedOrder.form || '').toLowerCase();

    // Primary check: route is 'inhalation'
    if (route === 'inhalation') {
        return true;
    }

    // Secondary check: form implies inhalation
    const inhalationForms = ['inhaler', 'puff', 'nebule', 'mdi', 'dpi', 'aerosol', 'aer'];
    if (inhalationForms.includes(form)) {
        return true;
    }

    return false;
}

const benignBrandSet = new Set(['k-dur', 'hctz']);

const coreName = n => (n||'')
  .toLowerCase()
  .replace(/[\/-]/g, ' ')
  .replace(/[^a-z0-9\s]/g, '')         // strip punctuation
  .replace(/\b(?:tablet|tab|capsule|cap|hfa|inhaler|respiclick|pen)\b/g, '')
  .replace(/\s+/g, ' ')
  .trim();

// Compare two raw drug strings using brandToGenericMap and normalized core names
function sameDrugCore(a, b) {
  const stripStrength = s =>
    (s || '').replace(/\b\d+(?:\.\d+)?\s*(?:mg|mcg|g|mEq|iu|units?|unit|ml)\b/gi, '').trim();
  const x = coreName(stripStrength(a));
  const y = coreName(stripStrength(b));
  if (x === y) return true;
  if (brandToGenericMap[x] && brandToGenericMap[x] === y) return true;
  if (brandToGenericMap[y] && brandToGenericMap[y] === x) return true;
  return false;
}

function sameFrequency(f1, f2) {
  /* true when the two orders convey the same numeric schedule
     (e.g. “daily” vs “qHS”, “BID” vs “two times a day”).        */
  const n1 = freqNumeric(f1);    // null if unparsable
  const n2 = freqNumeric(f2);
  if (n1 != null && n2 != null) return n1 === n2;

  // fall back to canonical string compare
  return normalizeFrequency(f1) === normalizeFrequency(f2);
}

// ——— What changed? ———
function getChangeReason(orig, updated) {
  const DEBUG_CHANGE_REASON = false;
  if (DEBUG_CHANGE_REASON) {
    console.log('DEBUG getChangeReason: orig.drug=', orig.drug, 'updated.drug=', updated.drug);
    console.log('DEBUG getChangeReason: orig Parsed=', JSON.stringify(orig));
    console.log('DEBUG getChangeReason: updated Parsed=', JSON.stringify(updated));
  }

  if (!orig || !updated) return 'Misc. Change';

  let changes = [];
  const add = lbl => { if (!changes.includes(lbl)) changes.push(lbl); };

  const stripStrength = s =>
    s.toLowerCase().replace(/\b\d+(?:\.\d+)?\s*(?:mg|mcg|g|mEq|iu|units?|unit|ml)\b/g, '').trim();

  const base1 = stripStrength(orig.drug);
  const base2 = stripStrength(updated.drug);

  const leftHasBrand =
    (orig.brandTokens || []).some(t => !benignBrandSet.has(t.toLowerCase())) ||
    Boolean(brandToGenericMap[coreName(base1)]);
  const rightHasBrand =
    (updated.brandTokens || []).some(t => !benignBrandSet.has(t.toLowerCase())) ||
    Boolean(brandToGenericMap[coreName(base2)]);


  const generic1 = brandToGenericMap[base1] || coreDrugName(base1);
  const generic2 = brandToGenericMap[base2] || coreDrugName(base2);

  if (
    generic1 === generic2 &&
    base1 !== base2 &&
    (leftHasBrand || rightHasBrand) &&
    !changes.includes('Brand/Generic changed')
  ) {
    changes.push('Brand/Generic changed');
  }

  const gen1 = coreName(base1);
  const gen2 = coreName(base2);
  if (
    sameDrugCore(orig.drug, updated.drug) &&
    gen1 !== gen2 &&
    (leftHasBrand || rightHasBrand) &&
    !changes.includes('Brand/Generic changed')
  ) {
    changes.push('Brand/Generic changed');
  }

  /* Capture Brand ↔ Generic when the underlying substance matches
     (e.g. ProAir ↔ Albuterol).  Use core names so salts/HFA/etc. are
     ignored. */
  const substance1 = brandToGenericMap[gen1] || gen1;
  const substance2 = brandToGenericMap[gen2] || gen2;
  if (
    substance1 === substance2 &&
    leftHasBrand !== rightHasBrand &&
    !changes.includes('Brand/Generic changed')
  ) {
    add('Brand/Generic changed');
  }

  const norm = s => (s || '').toLowerCase().trim().replace(/\s+/g, ' ');
  // --- 2. Frequency: normalise “daily” variants ---
  const canon = (f, raw = '') => {
    f = norm(f);
    const rawNorm = norm(raw);
    if (f === '' || f === 'daily' || f === 'q24h') return 'daily';
    if (['tid', 'tidac', 'three times daily'].includes(f)) return 'tid';
    if (
      /(?:before|with) meals/.test(f) ||
      /before breakfast lunch dinner/.test(f) ||
      /(?:before|with) meals/.test(rawNorm) ||
      /before breakfast lunch dinner/.test(rawNorm) ||
      /with food/.test(f) ||
      /with food/.test(rawNorm)
    ) {
      const stripped = rawNorm
        .replace(/(?:before|with) meals/g, '')
        .replace(/before breakfast lunch dinner/g, '')
        .trim();
      const nf = normalizeFrequency(stripped);
      if (stripped && nf !== stripped) return nf;
      return 'tid';
    }
    return f;
  };

  // --- Initial properties from parsed objects ---
  const origDrugNameRaw = orig.rawDrug || orig.drug; // Preserve pre-normalization if available
  const updatedDrugNameRaw = updated.rawDrug || updated.drug;

  const { name: origDrugNorm } = normalizeMedicationName(orig.drug); // Fully normalized name for substance matching
  const { name: updatedDrugNorm } = normalizeMedicationName(updated.drug);
  const drug = origDrugNorm;

  // --- Comparisons ---
  const drugNameMatchStrict = origDrugNorm === updatedDrugNorm; // Based on fully normalized names (substance match)
  // New: direct raw-name comparison for certain brand/generic swaps
  const rawNamesDiffer = norm(origDrugNameRaw) !== norm(updatedDrugNameRaw);

  /* ---------- extra brand/generic guard ---------- */
  if (!changes.includes('Brand/Generic changed')) {
    const sameGeneric = norm(orig.drug) === norm(updated.drug);
    const lt = (orig.brandTokens || [])[0] || '';
    const rt = (updated.brandTokens || [])[0] || '';
    if (
      rawNamesDiffer &&
      sameGeneric &&
      (leftHasBrand || rightHasBrand) &&
      !benignBrandSet.has(lt) &&
      !benignBrandSet.has(rt)
    ) {
      changes.push('Brand/Generic changed');
    }
  }

  const sameMgStrength = (a, b) => {
    const grab = s => {
      const m = (s || '').match(/(\d+(?:\.\d+)?)\s*mg\b/i);
      return m ? Number(m[1]) : null;
    };
    let n1 = grab(a);
    let n2 = grab(b);
    if (n1 === null) n1 = grab(orig.originalRaw);
    if (n2 === null) n2 = grab(updated.originalRaw);
    return n1 !== null && n1 === n2;
  };

  // --- 1. Brand vs generic ---
  const coumBrand =
    /\bwarfarin\b/i.test(`${origDrugNameRaw} ${updatedDrugNameRaw}`) &&
    /\bcoumadin\b/i.test(`${origDrugNameRaw} ${updatedDrugNameRaw}`);

  if (coumBrand && !changes.includes('Brand/Generic changed'))
    add('Brand/Generic changed');

  if (rawNamesDiffer && drugNameMatchStrict && leftHasBrand !== rightHasBrand) {
    const leftTok = (orig.brandTokens || [])[0] || '';
    const rightTok = (updated.brandTokens || [])[0] || '';
    if (!benignBrandSet.has(leftTok) && !benignBrandSet.has(rightTok)) {
      add('Brand/Generic changed');
    }
  }
  // Detect brand substitution when both sides specify different brand tokens
  if (
    generic1 === generic2 &&
    leftHasBrand &&
    rightHasBrand
  ) {
    const set1 = new Set((orig.brandTokens || []).map(t => t.toLowerCase()));
    const set2 = new Set((updated.brandTokens || []).map(t => t.toLowerCase()));
    let brandDiff = false;
    if (set1.size !== set2.size) {
      brandDiff = true;
    } else {
      for (const t of set1) {
        if (!set2.has(t)) { brandDiff = true; break; }
      }
    }
    if (brandDiff) {
      const lt = (orig.brandTokens || [])[0] || '';
      const rt = (updated.brandTokens || [])[0] || '';
      if (!benignBrandSet.has(lt) && !benignBrandSet.has(rt)) {
        add('Brand/Generic changed');
      }
    }
  }
  const same = (a,b) => (!a && !b) || a===b;
  const sameRoute = (r1, r2) => {
    const normalize = s => (s || '').toLowerCase().trim();
    const eq = x =>
      x.replace(/\b(by )?mouth\b/, 'inhalation')
       .replace(/\b(respir(ator|iclick)|hfa|mdi)\b/, 'inhaler');
    return normalize(eq(r1)) === normalize(eq(r2));
  };
  function valuesEqual(v1, v2) {
    if (Array.isArray(v1) && Array.isArray(v2)) {
      if (v1.length !== v2.length) return false;
      for (let i = 0; i < v1.length; i++) {
        if (Number(v1[i]) !== Number(v2[i])) return false;
      }
      return true;
    }
    return v1 === v2;
  }

  function canonUnit(u) {
    return (u || '').toLowerCase().replace(/\bgram\b/, 'g');
  }

  const doseValueMatch = valuesEqual(orig.dose?.value, updated.dose?.value);
  // Compare total dose, defaulting quantity to 1 when missing
  const qty1 = orig.qty == null ? 1 : orig.qty;
  const qty2 = updated.qty == null ? 1 : updated.qty;
  const tot1 = (orig.dose?.value ?? 0) * qty1;
  const tot2 = (updated.dose?.value ?? 0) * qty2;
  const doseTotalMatch = tot1 === tot2;
  const doseUnitMatch =
    canonUnit(orig.rawUnit || orig.dose?.unit) ===
    canonUnit(updated.rawUnit || updated.dose?.unit);
  let frequencyMatch = canon(orig.frequency, orig.originalRaw) ===
    canon(updated.frequency, updated.originalRaw);
  const freqNum1 = perDay(canon(orig.frequency, orig.originalRaw));
  const freqNum2 = perDay(canon(updated.frequency, updated.originalRaw));
  let freqSameNum =
    freqNum1 !== null && freqNum2 !== null && freqNum1 === freqNum2;
  // Allow inhaler brand swaps and daily orders with only a time-of-day change
  // to mark frequencies as equivalent before evaluating frequency changes.
  if (inhaled(orig) && inhaled(updated)) {
    frequencyMatch = true;
    freqSameNum = true;
  }
  if (
    canon(orig.frequency, orig.originalRaw) === 'daily' &&
    canon(updated.frequency, updated.originalRaw) === 'daily' &&
    todChanged(orig, updated)
  ) {
    frequencyMatch = true;
    freqSameNum = true;
  }
  const tokensEqual = (a,b) => {
    a = (a || []).map(norm).sort();
    b = (b || []).map(norm).sort();
    if (a.length !== b.length) return false;
    for (let i=0; i<a.length; i++) if (a[i] !== b[i]) return false;
    return true;
  };
  const scheduleMatch = tokensEqual(orig.scheduleTokens, updated.scheduleTokens);
  const mealsTokens = ['tidac','before meals','with meals','before breakfast lunch dinner'];
  const containsMeals = tokens => (tokens||[]).map(norm).some(t => mealsTokens.includes(t));
  let timeOfDayMatch =
    normalizeTimeOfDay(orig.timeOfDay) === normalizeTimeOfDay(updated.timeOfDay);
  if (
    canon(orig.frequency, orig.originalRaw) === 'weekly' &&
    canon(updated.frequency, updated.originalRaw) === 'weekly'
  ) {
    timeOfDayMatch = true;
  }
  const timeOfDayRawMatch = same(
    norm(orig.timeOfDayOriginal),
    norm(updated.timeOfDayOriginal)
  );
  let formMatch = same(norm(orig.form), norm(updated.form));
  function canonForm(f) {
    return (f || '')
      .toLowerCase()
      .replace(/\b(tabs?|tablets?)\b/, 'tablet');
  }
  if (
    !formMatch &&
    (
      (canonForm(orig.form) === 'tablet' && updated.form === '') ||
      (canonForm(updated.form) === 'tablet' && orig.form === '')
    )
  ) {
    formMatch = true;
    changes = changes.filter(c => c !== 'Form changed');
  }
  if (!formMatch &&
      orig.form === 'pen' && updated.form === 'pen') {
    formMatch = true;
    changes = changes.filter(c => c !== 'Form changed');
  }
  // --- 3. Formulation (ER/XR/SR/extended-release) ---
  const origFormCanon = canonFormulation(orig.formulation);
  const updatedFormCanon = canonFormulation(updated.formulation);
  let formulationMatch = same(norm(origFormCanon), norm(updatedFormCanon));
  // --- 4. Ignore benign salts (besylate, mesylate, etc.) ---
  const normForm = f =>
    canonFormulation((f || '').replace(trivialSalts, '').replace(/\s{2,}/g, ''))
      .trim();
  if (!formulationMatch && normForm(orig.formulation) === normForm(updated.formulation)) {
    formulationMatch = true;
    // remove the tag if it was added earlier
    changes = changes.filter(c => c !== 'Formulation changed');
  }
  const hasCanonER = f => /\ber\b/i.test(canonFormulation(f));
  const stripER = f => canonFormulation(f).replace(/\ber\b/gi, '').trim();
  if (
    !formulationMatch &&
    stripER(origFormCanon) === stripER(updatedFormCanon) &&
    hasCanonER(origFormCanon) === hasCanonER(updatedFormCanon)
  ) {
    formulationMatch = true;
    changes = changes.filter(c => c !== 'Formulation changed');
  }
  if (
    !formulationMatch &&
    origFormCanon === updatedFormCanon
  ) {
    formulationMatch = true;
    changes = changes.filter(c => c !== 'Formulation changed');
  }
  let routeMatch = sameRoute(orig.route, updated.route);
  if (!routeMatch) {
    const r1 = norm(orig.route);
    const r2 = norm(updated.route);
    if ((r1 === 'po' && !r2) || (r2 === 'po' && !r1)) {
      routeMatch = true;
    }
    // Treat inhaler brand swaps with 'by mouth' as inhalation
    if (!routeMatch && inhaled(orig) && inhaled(updated)) {
      if ((r1 === 'po' && r2 === 'inhalation') || (r2 === 'po' && r1 === 'inhalation')) {
        routeMatch = true;
      }
    }
  }
  const prnMatch = same(orig.prn, updated.prn);
  const ind1 = normalizeIndication(orig.indication);
  const ind2 = normalizeIndication(updated.indication);
  const indicationDiff = ind1 !== ind2;
  if (indicationDiff) add('Indication changed');
  const startDateMatch = same(orig.startDate, updated.startDate);
  const endDateMatch = same(orig.endDate, updated.endDate);
  const qtyMatch = same(orig.qty ?? 1, updated.qty ?? 1); // Default to 1 if null for comparison
  const qtySame = (orig.qty ?? 1) === (updated.qty ?? 1);
  const taperDiff =
    orig.taperFlag !== null &&
    updated.taperFlag !== null &&
    orig.taperFlag !== updated.taperFlag;
  const courseDiff =
    /\bx\d+\s*days?\b/i.test(orig.originalRaw || '') !==
    /\bx\d+\s*days?\b/i.test(updated.originalRaw || '');


  // --- Logging for debug ---
  if (DEBUG_CHANGE_REASON) {
    console.log('DEBUG getChangeReason - Comparisons:');
    console.log('  drugNameMatchStrict (normalized substance):', drugNameMatchStrict, `(${origDrugNorm} vs ${updatedDrugNorm})`);
    console.log('  origDrugNameRaw:', origDrugNameRaw, 'updatedDrugNameRaw:', updatedDrugNameRaw);
    console.log('  formulationMatch:', formulationMatch, `(orig: ${norm(orig.formulation)} vs upd: ${norm(updated.formulation)})`);
    console.log('  doseValueMatch (per unit):', doseValueMatch, `(orig: ${orig.dose?.value} vs upd: ${updated.dose?.value})`);
    console.log('  doseTotalMatch:', doseTotalMatch, `(orig: ${orig.dose?.total ?? orig.dose?.value} vs upd: ${updated.dose?.total ?? updated.dose?.value})`);
    console.log('  doseUnitMatch:', doseUnitMatch, `(orig: ${orig.dose?.unit} vs upd: ${updated.dose?.unit})`);
    console.log('  qtyMatch:', qtyMatch, `(orig: ${(orig.qty ?? 1)} vs upd: ${(updated.qty ?? 1)})`);
    console.log(
      '  frequencyMatch:',
      frequencyMatch,
      `(orig: ${canon(orig.frequency, orig.originalRaw)} vs upd: ${canon(updated.frequency, updated.originalRaw)})`
    );
    console.log('  timeOfDayMatch:', timeOfDayMatch, `(orig: ${norm(orig.timeOfDay)} vs upd: ${norm(updated.timeOfDay)})`);
    console.log('  timeOfDayRawMatch:', timeOfDayRawMatch, `(orig: ${norm(orig.timeOfDayOriginal)} vs upd: ${norm(updated.timeOfDayOriginal)})`);
    console.log('  formMatch:', formMatch, `(orig: ${norm(orig.form)} vs upd: ${norm(updated.form)})`);
    console.log('  routeMatch:', routeMatch, `(orig: ${norm(orig.route)} vs upd: ${norm(updated.route)})`);
    console.log('  prnMatch:', prnMatch, `(orig: ${orig.prn} vs upd: ${updated.prn})`);
    console.log('  indicationDiff:', indicationDiff, `(${normalizeIndication(orig.indication)} vs ${normalizeIndication(updated.indication)})`);
    console.log('  startDateMatch:', startDateMatch, `(orig: ${orig.startDate || ""} vs upd: ${updated.startDate || ""})`);
    console.log('  endDateMatch:', endDateMatch, `(orig: ${orig.endDate || ""} vs upd: ${updated.endDate || ""})`);
  }

 // --- End Debugging Conditions ---

// --- Start/End Date Changes ---
  if (!startDateMatch) add('Date changed');
  if (!endDateMatch) add('End Date changed');

  // --- Formulation Change ---
  if (!formulationMatch) {
      // Do not flag a formulation change when both orders lack a formulation and the
      // core drug names match strictly. This avoids false positives such as
      // "Vitamin D3" vs "Cholecalciferol" where neither mentions a formulation.
      if (drugNameMatchStrict && !orig.formulation && !updated.formulation) {
          // nothing
      } else if (orig.formulation || updated.formulation) {
          // Avoid if Brand/Generic already implies this (e.g. Lopressor vs Metoprolol Tartrate)
          // This needs careful thought. For now, if drugNameMatchStrict is true AND formulations differ, it's a formulation change.
          // If drugNameMatchStrict is false, it might be a different drug OR a salt form change handled by B/G.
          if (drugNameMatchStrict || (!changes.includes("Brand/Generic changed") && (norm(orig.formulation) !== norm(updated.formulation))) ) {
               add('Formulation changed');
          }
      }
  }

  // --- Brand/Generic Change ---
  if (drugNameMatchStrict && leftHasBrand !== rightHasBrand) {
    const lt = (orig.brandTokens || [])[0] || '';
    const rt = (updated.brandTokens || [])[0] || '';
    if (!benignBrandSet.has(lt) && !benignBrandSet.has(rt)) {
      add('Brand/Generic changed');
    }
  }
  if (drugNameMatchStrict) {
    const leftFull  = `${origDrugNameRaw} ${orig.formulation || ''}`.trim();
    const rightFull = `${updatedDrugNameRaw} ${updated.formulation || ''}`.trim();
    const saltSwap = importantSaltPairs.some(([a, b]) =>
      (leftFull.includes(a) && rightFull.includes(b)) ||
      (leftFull.includes(b) && rightFull.includes(a))
    );
    if (!formulationMatch && saltSwap && !changes.includes('Formulation changed')) {
      changes.push('Formulation changed');
    }
    if (!leftHasBrand && !rightHasBrand) {
      changes = changes.filter(c => c !== 'Brand/Generic changed');
    }
  }

    // Quantity-only difference (dose strength identical)
    const quantityOnlyDiff =
      (qtyMatch === false || taperDiff || courseDiff) &&
      doseValueMatch === true &&
      doseUnitMatch === true &&
      doseTotalMatch === false;

    if (quantityOnlyDiff) {
      // Remove any existing Dose-change flag
      changes = changes.filter(c => c !== 'Dose changed');
      if (!changes.includes('Quantity changed')) {
        changes.push('Quantity changed');
      }
    }

  // --- Dose/Quantity Changes ---
  // Only flag a dose change when the per-unit amount or unit differs, or when the
  // total differs without a quantity change. This prevents "Dose changed" when
  // the strength per spray/tablet is identical but the quantity varies.

  if (!quantityOnlyDiff) {
    let actualDoseDifference = false;
    if (!doseUnitMatch || !doseValueMatch) {
      actualDoseDifference = true;
    } else {
      if (Array.isArray(orig.dose?.value)) {
        if (!qtyMatch) actualDoseDifference = true;
      } else if (!doseTotalMatch) {
        actualDoseDifference = true;
      }
    }

    if (actualDoseDifference) {
      add('Dose changed');
    }
  }

  // If totals are equal (quantity defaults to 1) and we added the dose flag, it
  // likely came from a frequency-only change, so remove it.
const sameStrength =
  doseValueMatch &&
  doseUnitMatch &&
  !Array.isArray(orig.dose?.value) &&
  !Array.isArray(updated.dose?.value);
const sameQty = qtyMatch || (orig.qty == null && updated.qty == null);
if (sameStrength && sameQty && changes.includes('Dose changed')) {
  changes = changes.filter(c => c !== 'Dose changed');
}
if (!doseValueMatch && !changes.includes('Dose changed')) {
  add('Dose changed');
}
// Quantity differences are reflected in the dose when totals differ, but still
// list them separately to highlight dispensing changes.
if (!qtyMatch || taperDiff || courseDiff) {
  add('Quantity changed');
}

  if ((drug === 'ferrous sulfate' || drug === 'iron sulfate') &&
      doseValueMatch && changes.includes('Dose changed')) {
    changes = changes.filter(c => c !== 'Dose changed');
  }

  // Before checking frequency changes, see if numeric values match exactly.
  const freqSame =
    freqNumeric(orig.frequency) !== null &&
    freqNumeric(orig.frequency) === freqNumeric(updated.frequency);

  // Treat numeric equivalence as "same", even if wording differs.
  if (freqSame) {
    frequencyMatch = true;
    freqSameNum = true;
  }

  // Inhaler brand swaps with equal numeric frequency should not flag a change
  if (
    inhaled(orig) &&
    inhaled(updated) &&
    freqNumeric(orig.frequency) === freqNumeric(updated.frequency)
  ) {
    frequencyMatch = true;
    freqSameNum = true;
  }

  // Daily vs daily with only time-of-day difference shouldn't flag frequency
  if (
    canon(orig.frequency, orig.originalRaw) === 'daily' &&
    canon(updated.frequency, updated.originalRaw) === 'daily' &&
    todChanged(orig, updated)
  ) {
    frequencyMatch = true;
    freqSameNum = true;
  }

// --- Frequency Change ---
let freqChange = false;
if (!freqSameNum) {
  freqChange = true;
} else if (
  !tokensEqual(orig.frequencyTokens, updated.frequencyTokens) &&
  (containsMeals(orig.frequencyTokens) || containsMeals(updated.frequencyTokens))
) {
  if (
    !(
      canon(orig.frequency, orig.originalRaw) === 'tid' &&
      canon(updated.frequency, updated.originalRaw) === 'tid'
    )
  ) {
    freqChange = true;
  }
} else if (

  /* Skip wording-only frequency flags unless BOTH sides already
     have a non-blank frequency string.  If either side is blank
     (implicit daily) but the numeric schedules are equal, handle
     it purely as a time-of-day shift. */
  orig.frequency && updated.frequency &&
  normalizeFrequency(orig.frequency) !==
  normalizeFrequency(updated.frequency) &&

  /* Only count a wording-only difference when *both* sides
     actually specify a frequency string.  This prevents a
     spurious "Frequency changed" when one side is blank
     (implicitly daily) and the other says "daily in the evening". */
  orig.frequency &&
  updated.frequency &&
  normalizeFrequency(orig.frequency) !== normalizeFrequency(updated.frequency) &&

  todChanged(orig, updated)
) {
  freqChange = true;
}
if (
  freqChange &&
  freqSameNum &&
  normalizeFrequency(orig.frequency) ===
    normalizeFrequency(updated.frequency) &&
  todChanged(orig, updated) &&
  tokensEqual(orig.frequencyTokens, updated.frequencyTokens)
) {
  freqChange = false;
}
if (
  freqSameNum &&
  normalizeFrequency(orig.frequency) === normalizeFrequency(updated.frequency) &&
  todChanged(orig, updated)
) {
  freqChange = false;
}
// If the schedules are numerically the same, never call it a frequency change
if (sameFrequency(orig.frequency, updated.frequency)) {
  freqChange = false;
}
// drop frequency flag when schedules are numerically equal
// and the only difference is a TOD shift
if (freqChange) {
  const numSame = sameFrequency(orig.frequency, updated.frequency);
  const todShift = todChanged(orig, updated);
  if (numSame && todShift) freqChange = false;
}
if (!freqChange) changes = changes.filter(c => c !== 'Frequency changed');
if (freqChange) add('Frequency changed');

// --- Time of Day Change ---
if (!timeOfDayMatch && (norm(orig.timeOfDay) || norm(updated.timeOfDay))) {
  add('Time of day changed');
}
if (!scheduleMatch && orig.scheduleTokens.length && updated.scheduleTokens.length) {
  add('Time of day changed');
}

// --- Form Change (tablet, capsule, etc.) ---
if (!formMatch && (norm(orig.form) || norm(updated.form))) {
    add('Form changed');
}

// --- Route Change ---
if (!routeMatch && (norm(orig.route) || norm(updated.route))) { // Only if routes specified and different
     add('Route changed');
}

// --- Administration Change ---
if (orig.administration && updated.administration &&
    orig.administration !== updated.administration) {
    add('Administration changed');
}

// --- PRN logic ---
if (orig.prn !== updated.prn) {
  changes.push('PRN changed');
}
if (
  orig.prn &&
  updated.prn &&
  normalizeIndication(orig.prnCondition) !==
    normalizeIndication(updated.prnCondition)
) {
  changes.push('Indication changed');
}
// --- end PRN logic ---

// --- Indication Change (general catch-all if different) ---
if (indicationDiff) {
    // Only add if it's not the *only* change that would otherwise make it "Unchanged"
    // This avoids flagging minor indication wording differences if everything else is identical.
    // The primary "Indication-only" check is below. This is a broader catch.
    let otherChangesPresent = changes.filter(c => c !== 'Indication changed').length > 0;
    if (otherChangesPresent ||
        !drugNameMatchStrict || !doseTotalMatch || !doseUnitMatch || !frequencyMatch || !routeMatch ||
        !formMatch || !formulationMatch || !prnMatch || !startDateMatch || !endDateMatch || !qtyMatch
       ) {
        add('Indication changed');
    }
}
 
  // 2) **Indication-only**  (keep critical tags)
  if (
    indicationDiff &&
    drugNameMatchStrict &&
    doseTotalMatch &&      // totals identical
    doseUnitMatch &&
    qtyMatch &&
    frequencyMatch &&
    timeOfDayMatch &&
    formMatch &&
    formulationMatch &&
    routeMatch &&
    prnMatch &&
    startDateMatch &&
    endDateMatch
  ) {
    /* Keep any critical change we already flagged (e.g. Brand/Generic or
       Formulation) instead of wiping them out.  If nothing critical
       remains, fall back to a plain “Indication changed”. */
    const critical = new Set(['Brand/Generic changed', 'Formulation changed']);
    changes = changes.filter(c => critical.has(c));

    if (changes.length === 0) changes = ['Indication changed'];

    if (DEBUG_CHANGE_REASON)
      console.log('DEBUG: Indication-only block ->', JSON.stringify(changes));
  }

  // ——— 3) Time-of-day-only, but allow QOD→daily ———
  const isQodToDaily =
    canon(orig.frequency, orig.originalRaw) === 'every other day' &&
    canon(updated.frequency, updated.originalRaw) === 'daily';

  if (
    !timeOfDayMatch &&
    drugNameMatchStrict &&
    doseTotalMatch &&
    doseUnitMatch &&
    qtyMatch &&
    (frequencyMatch || isQodToDaily) &&
    formMatch &&
    formulationMatch &&
    routeMatch &&
    prnMatch &&
    startDateMatch &&
    endDateMatch &&
    normalizeIndication(orig.indication) === normalizeIndication(updated.indication)
  ) {
    if (DEBUG_CHANGE_REASON)
      console.log("--- BLOCK #3 CONDITION MET --- Returning 'Time of day changed'");
    if (changes.length === 0) {
      changes = ['Time of day changed'];
    } else if (!changes.includes('Time of day changed')) {
      changes.push('Time of day changed');
    }
  } else {
    if (DEBUG_CHANGE_REASON)
      console.log('--- BLOCK #3 CONDITION FAILED for explicit Time of Day return ---');
  }


  if (changes.includes('Dose changed') && coumBrand) {
    if (doseTotalMatch || sameMgStrength(origDrugNameRaw, updatedDrugNameRaw)) {
      changes = changes.filter(c => c !== 'Dose changed');
    }
  }
  if (
    changes.includes('Frequency changed') &&
    coumBrand &&
    freqSameNum
  ) {
    changes = changes.filter(c => c !== 'Frequency changed');
  }

  // collapse trivial TOD/freq double-hit
  if (
    changes.includes('Frequency changed') &&
    changes.includes('Time of day changed') &&
    freqSameNum &&
    !todChanged(orig, updated)
  ) {
    changes = changes.filter(c => c !== 'Frequency changed');
  }
  if (
    changes.includes('Quantity changed') &&
    changes.includes('Time of day changed') &&
    qtySame &&
    !todChanged(orig, updated)
  ) {
    changes = changes.filter(c => c !== 'Quantity changed');
  }
  if (
    changes.includes('Time of day changed') &&
    canon(orig.frequency, orig.originalRaw) === 'daily' &&
    canon(updated.frequency, updated.originalRaw) === 'daily' &&
    ((orig.brandTokens || []).includes('lasix') ||
      (updated.brandTokens || []).includes('lasix'))
  ) {
    changes = changes.filter(c => c !== 'Time of day changed');
  }

  // ── NEW CLEANUP: drop redundant Time-of-day flag ────────────────
  if (
    changes.includes('Frequency changed') &&
    changes.includes('Time of day changed')
  ) {
    const onceDaily = ['daily', 'qam', 'qpm', 'qhs', 'hs', 'nightly'];
    const f1 = canon(orig.frequency);
    const f2 = canon(updated.frequency);
    if (!onceDaily.includes(f1) || !onceDaily.includes(f2)) {
      changes = changes.filter(c => c !== 'Time of day changed');
    }
  }

  /* ——— NEW: drop a bogus Frequency-changed when both sides normalise
              to the *same* frequency ——— */
  if (
    changes.includes('Frequency changed') &&
    normalizeFrequency(orig.frequency) === normalizeFrequency(updated.frequency)
  ) {
    changes = changes.filter(c => c !== 'Frequency changed');
  }
  // ────────────────────────────────────────────────────────────────
  // collapse inhaler form/route double-hit
  if (changes.includes('Form changed') && changes.includes('Route changed') && inhaled(orig) && inhaled(updated)) { // check if both are inhaled
    changes = changes.filter(c => c !== 'Route changed'); // or form, depending on preference
  }

  /* --- CRITICAL TIME-OF-DAY RULE ------------------------------------ */
  const criticalTodDrug =
    ['warfarin','coumadin','apixaban','eliquis','rivaroxaban','xarelto',
     'dabigatran','pradaxa','edoxaban','lixiana',
     'heparin','enoxaparin','lovenox'].some(d =>
       generic1 === d || generic2 === d
     );

  if (criticalTodDrug &&
      !changes.includes('Time of day changed') &&
      todChanged(orig, updated)) {
    changes.push('Time of day changed');
  }
  /* -------------------------------------------------------------------- */

// --- New Rule for Stat/Immediately vs. Timed Dosing ---
  const origFreqIsImmediately = norm(orig.frequency) === 'immediately';
  const updatedFreqIsDaily =
    canon(updated.frequency, updated.originalRaw) === 'daily';
  const origTODIsEmpty = norm(orig.timeOfDay) === '';
  const updatedTODIsSet = norm(updated.timeOfDay) !== '';

  if (
    changes.includes('Frequency changed') &&
    changes.includes('Time of day changed') &&
    origFreqIsImmediately &&
    updatedFreqIsDaily &&
    origTODIsEmpty &&
    updatedTODIsSet
  ) {
    changes = changes.filter(c => c !== 'Time of day changed');
    if (sameIndication(orig.indication, updated.indication)) {
      changes = changes.filter(c => c !== 'Indication changed');
    }
  }
// --- End of New Rule ---
  const refillsDiff = orig.refills != null && updated.refills != null && orig.refills !== updated.refills;
  if (refillsDiff) add("Refills changed");

  if (DEBUG_CHANGE_REASON) console.log('DEBUG: changes array before final formatting:', JSON.stringify(changes));

  // Consolidate: If "Brand/Generic changed" and "Formulation changed" are both present,
  // and the formulation is part of the brand name (e.g. Metoprolol Tartrate vs Lopressor),
  // "Brand/Generic changed" might be sufficient. This is complex, for now, list both if detected.

  /* ——— FINAL sweep: drop a bogus Frequency-changed when canonical
       frequencies are identical ——— */
  if (
    changes.includes('Frequency changed') &&
    normalizeFrequency(orig.frequency) ===
      normalizeFrequency(updated.frequency)
  ) {
    changes = changes.filter(c => c !== 'Frequency changed');
  }

  /* ---------- ULTIMATE TOD ↔ FREQUENCY CLEAN-UP ---------- */
  (() => {
    const todShifted   = todChanged(orig, updated) && !timeOfDayMatch;
    const freqNumeric1 = freqNumeric(orig.frequency);
    const freqNumeric2 = freqNumeric(updated.frequency);

    /* 1️⃣  – ALWAYS strip a redundant “Frequency changed” flag when:
          • numeric schedules are equal  OR
          • one side is missing but the other is plainly “daily”  */
    const equalFreq =
          sameFrequency(orig.frequency, updated.frequency) ||
          ( (freqNumeric1 === 1 || freqNumeric2 === 1) &&
            (freqNumeric1 == null || freqNumeric2 == null) );

    if (equalFreq)
      changes = changes.filter(c => c !== 'Frequency changed');

    /* 2️⃣  – If an explicit TOD token was added or removed, ensure the tag: */
    if (todShifted) {
      if (!changes.includes('Time of day changed'))
        changes.push('Time of day changed');
    } else {
      changes = changes.filter(c => c !== 'Time of day changed');
    }
  })();
  /* ------------------------------------------------------- */

  // ── FINAL Coumadin/Warfarin frequency guard ─────────────
  if (coumBrand && changes.includes('Frequency changed')) {
    const n1 = freqNumeric(orig.frequency);
    const n2 = freqNumeric(updated.frequency);
    if (n1 != null && n2 != null && n1 === n2) {
      changes = changes.filter(c => c !== 'Frequency changed');
    }
  }
  // ─────────────────────────────────────────────────────────

  /* ---------- FINAL sanity strip for accidental freq flag ---------- */
  (() => {
    if (changes.includes('Frequency changed')) {
      const sameNum = sameFrequency(orig.frequency, updated.frequency);
      if (sameNum) {
        changes = changes.filter(c => c !== 'Frequency changed');
      }
    }
  })();
  /* ----------------------------------------------------------------- */

  /* ----- final sweep: kill bogus Frequency tag after TOD shift ----- */
  (() => {
    const num1 = freqNumeric(orig.frequency);
    const num2 = freqNumeric(updated.frequency);
    const numericUnchanged =
      num1 === num2 ||
      ((num1 === 1 || num2 === 1) && (num1 == null || num2 == null));

    if (todChanged(orig, updated) && numericUnchanged) {
      changes = changes.filter(c => c !== 'Frequency changed');
    }
  })();

  // FINAL guard – numeric schedule identical, only TOD shifted
  if (changes.includes('Frequency changed')) {
    const numSame = sameFrequency(orig.frequency, updated.frequency);
    if (numSame && todChanged(orig, updated)) {
      changes = changes.filter(c => c !== 'Frequency changed');
    }
  }


  if (changes.length === 0) return 'Unchanged'; // Default to Unchanged if no specific diffs were added
  // --- format final tag list ---
  if (changes.length === 1) return changes[0];

  const priority = [
    'Dose changed',
    'Frequency changed',
    'Formulation changed',
    'Brand/Generic changed',
    'Quantity changed',
    'Route changed',
    'Form changed',
    'Time of day changed',
    'Administration changed',
    'Indication changed',
    'Date changed',
    'End Date changed'
  ];

  changes.sort((a, b) =>
    (priority.indexOf(a) === -1 ? 999 : priority.indexOf(a)) -
    (priority.indexOf(b) === -1 ? 999 : priority.indexOf(b))
  );

  // If more than four changes were detected, show a generic label
  if (changes.length > 4) {
    return 'Multiple changes';
  } else {
    // Show all detected changes when there are up to four
    return changes.join(', ');
  }
}

  const qtyWords = [
    'tabs', 'tab', 'tablets',
    'caps', 'capsules', 'caplets',
    'puff', 'puffs',
    'spray', 'sprays',
    'drop', 'drops',
    'lozenge', 'lozenges',
    'patch', 'patches'
  ];

  function fractionToDecimal(str) {
    const map = { '½': 0.5, '¼': 0.25, '¾': 0.75 };
    if (map[str]) return map[str];
    const frac = str.match(/^(\d+)\s*\/\s*(\d+)$/);
    if (frac) return parseFloat(frac[1]) / parseFloat(frac[2]);
    return parseFloat(str);
  }

  function extractPrn(str, order) {
    const painPattern = '(?:[a-zA-Z]+(?:\\s+[a-zA-Z]+)*)?\\s*pain';
    const prnCondWords = `(?:anxious|anxiety|${painPattern}|nausea|vomiting|sob|shortness\\s+of\\s+breath|itching|fever|dizzy|headache)`;
    let m = str.match(new RegExp(`\\bprn\\s+(?:for\\s+)?(${prnCondWords})\\b`, 'i'));
    if (!m) m = str.match(new RegExp(`\\bas\\s+needed\\s+(?:for\\s+)?(${prnCondWords})\\b`, 'i'));
    if (!m) m = str.match(new RegExp(`\\bif\\s+(${prnCondWords}|needed)\\b`, 'i'));
    if (!m) m = str.match(/\b(?:prn|as\s+needed|if\s+needed)\b/i);
    if (m) {
      order.prn = true;
      if (m[1]) order.prnCondition = normalizeIndication(m[1]);
      str = str.replace(m[0], '').trim();
    }
    return str;
  }

  function extractIndication(str, order) {
    const painPattern = '(?:[a-zA-Z]+(?:\\s+[a-zA-Z]+)*)?\\s*pain';
    const forIndicationRegex = /\bfor\s+([a-zA-Z0-9\s\/.-]+)/i;
    const m = str.match(forIndicationRegex);
    if (m && m[1]) {
      order.indication = normalizeIndication(m[1].trim().toLowerCase());
      str = str.replace(m[0], '').trim();
    }
    if (!order.indication) {
      const painIndicRegex = new RegExp(`\\b(${painPattern})\\b`, 'i');
      const pm = str.match(painIndicRegex);
      if (pm && pm[0] && pm.index > 0) {
        order.indication = normalizeIndication(pm[0].trim().toLowerCase());
        str = str.replace(pm[0], '').trim();
      }
    }
    if (!order.indication) {
      const sobMatch = str.match(/\bshortness of breath\b/i);
      if (sobMatch) {
        order.indication = normalizeIndication('shortness of breath');
        str = str.replace(sobMatch[0], '').trim();
      }
    }
    if (!order.indication && order.prnCondition) {
      order.indication = order.prnCondition;
    }
    return str;
  }

  function extractQuantity(str, order) {
    const word2num = {
      one: 1,
      two: 2,
      three: 3,
      four: 4,
      five: 5,
      six: 6,
      seven: 7,
      eight: 8,
      nine: 9,
      ten: 10
    };
    const wordRegex = new RegExp(`\\b(${Object.keys(word2num).join('|')})\\b`, 'gi');
    str = str.replace(wordRegex, w => String(word2num[w.toLowerCase()]));
    const qtyRegex = new RegExp(
      `(?:\\b(?:take|give|administer|inhale|inject|apply|use)\\s+)?((?:\\d+\\/\\d+|[\\u00bc-\\u00be]|\\d+(?:\\.\\d+)?))\\s*(${qtyWords.join('|')})(?:s)?\\b`,
      'i'
    );
    const m = str.match(qtyRegex);
    if (m) {
      order.qty = fractionToDecimal(m[1]);
      const unit = m[2].toLowerCase();
      if (['tablet', 'tab', 'tablets', 'tabs'].includes(unit) && !order.form) order.form = 'tablet';
      else if (['capsule', 'caps', 'caplet', 'capsules'].includes(unit) && !order.form) order.form = 'capsule';
      else if (['puff', 'puffs'].includes(unit) && !order.form) order.form = 'puff';
      str = str.replace(m[0], '').trim();
    }
    return str;
  }

  function extractDates(str) {
    let startDate = '';
    let endDate = '';
    let dateFound = false;
    const explicitStartDateRegex = /\b(?:start|started|on)\s*:\s*(\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4}))\b/i;
    const startMatch = str.match(explicitStartDateRegex);
    if (startMatch) {
      startDate = startMatch[1];
      str = str.replace(startMatch[0], '').trim();
      dateFound = true;
    }
    const explicitEndDateRegex = /\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?)\s*:\s*(\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4}))\b/i;
    const endMatch = str.match(explicitEndDateRegex);
    if (endMatch) {
      endDate = endMatch[1];
      str = str.replace(endMatch[0], '').trim();
    }
    if (!dateFound) {
      const genericDateRegex = /(?<!\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?)\s*:\s*)(\b\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4})\b)/i;
      const genericDateMatch = str.match(genericDateRegex);
      if (genericDateMatch && genericDateMatch[1]) {
        const nearbyEnd = /\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?)\s*:\s*\d{1,2}\/\d{1,2}\/((?:\d{2}|\d{4}))\b/i.test(str.substring(genericDateMatch.index));
        if (!nearbyEnd || !endDate) {
          startDate = genericDateMatch[1];
          str = str.replace(genericDateMatch[0], '').trim();
        }
      }
    }
    const endDateRegex = /\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?):\s*(\d{1,2}\/\d{1,2}\/\d{4})\b/i;
    const endDateMatchResult = str.match(endDateRegex);
    if (endDateMatchResult) {
      endDate = endDateMatchResult[1];
      str = str.replace(endDateMatchResult[0], '').trim();
    }
    return { cleanedStr: str, startDate, endDate };
  }
  function extractRefills(str, order) {
    const m = str.match(/\b(\d+)\s*refills?\b/i);
    if (m) {
      order.refills = parseInt(m[1], 10);
      str = str.replace(m[0], "").trim();
    }
    return str;
  }


  function handleBrandGeneric(order, finalDrugName) {
    const drugStr = finalDrugName
      .replace(/[^a-zA-Z0-9\/\s\-\.#]+/g, ' ')
      .replace(/\s\s+/g, ' ')
      .trim()
      .toLowerCase();
    order.rawDrug = drugStr;
    const { name: drugName, brandTok } = normalizeMedicationName(drugStr);
    order.drug = drugName;
    order.brandTokens = brandTok;
  }

  function applyFinalNormalizations(order, troughNote, originalRaw) {
    if (!order.form) {
      const raw = (originalRaw || '').toLowerCase();
      if (/\btab(lets?)?\b/.test(raw)) {
        order.form = 'tablet';
      } else if (/\bcap(sules?|lets?)?\b/.test(raw)) {
        order.form = 'capsule';
      }
    }
    const deviceRE = /\b(solostar|flexpen|kwikpen|pen)\b/gi;
    if (order.form) {
      order.form = order.form.replace(deviceRE, '').trim() || 'pen';
    } else if (deviceRE.test((originalRaw || '').toLowerCase())) {
      order.form = 'pen';
    }
    const injMatch = (originalRaw || '').match(/inject\s*(\d+(?:\.\d+)?)\s*u(?:nits?)?\b/i);
    if (injMatch && /u\s*\/\s*ml/i.test(originalRaw)) {
      const units = parseFloat(injMatch[1]);
      order.dose.value = units;
      order.dose.unit = 'unit';
      order.dose.total = units;
    }
    const oralFormsForPo = ['tablet','capsule','caplet','softgel','lozenge','syrup','solution','suspension','elixir','liquid','oral disintegrating tablet'];
    if (!order.route && oralFormsForPo.includes(order.form)) {
      order.route = 'po';
    }
    order.frequency = normalizeFrequency(order.frequency);
    order.timeOfDay = normalizeTimeOfDay(order.timeOfDay);
    if (!order.indication && troughNote) order.indication = troughNote;
    order.indication = normalizeIndication(order.indication);
    order.formulation = canonFormulation(order.formulation);
    const schedRe = /\b(?:m\/?w\/?f|m\s*w\s*f|mwf|tu\/?th\/?sa\/?su|ttsu)\b/gi;
    order.scheduleTokens = (originalRaw.match(schedRe) || []).map(t => t.toLowerCase());
  }


    function parseOrder(orderStr, ocrConfidenceValue) {
  // Keep a copy of the original input for debugging if needed at the very end
  // const originalInputToParseOrder = orderStr;
  const originalRaw = orderStr;   // keep untouched copy
  let parsingConfidence = 100;
  orderStr = orderStr.replace(/[\u2010\u2011\u2012\u2013\u2014\u2015\u2212]/g, '-');
  orderStr = normalizeText(orderStr); // Normalizes "qhs" to "at bedtime", etc.
  // Capture trailing trough monitoring notes before removing them
  let troughNote = null;
  const troughMatch = orderStr.match(/-\s*((?:target\s+)?trough.*)$/i);
  if (troughMatch) troughNote = troughMatch[1].trim();
  // Strip trailing trough comments so numeric targets don't get parsed as doses
  orderStr = orderStr.replace(/-\s*(?:target\s+)?trough.*$/i, '').trim();

  let order = {
    drug: "",
    dose: { value: null, unit: '', total: null },
    qty: null,
    route: "",
    frequency: "",
    frequencyTokens: [],
    timeOfDay: "",
    timeOfDayOriginal: "",
    administration: "",
    prn: false,
    prnCondition: "",
    startDate: "",
    endDate: "",
    form: "",
    formulation: "",
    indication: "",
    brandTokens: [],
    rawDrug: "",
    rawUnit: "",
    taperFlag: null,
    refills: null,
    originalRaw
  };
// Store the initially cleaned drug string for later Brand/Generic comparison
  const initialCleanedDrugString = orderStr;

  // Record presence of taper/no taper for quantity comparisons
  if (/\bno\s+taper\b/i.test(originalRaw)) {
    order.taperFlag = 0;
  } else if (/\btaper\b/i.test(originalRaw)) {
    order.taperFlag = 1;
  }

const dates = extractDates(orderStr);
orderStr = dates.cleanedStr;
order.startDate = dates.startDate;
order.endDate = dates.endDate;
orderStr = extractRefills(orderStr, order);

  // 1. Extract Time-of-Day and common morning/evening/night shorthands
//    Also sets frequency if implied by the shorthand (e.g., qam is daily)
const timeOfDayMappings = [
  // --- NEW: Prioritize "every other X" and specific daily patterns before general ones ---
  { regex: /\bevery\s+other\s+morning\b/i, timeOfDay: 'morning', frequency: 'every other day', originalTermRegexPos: 0 },
  { regex: /\bevery\s+other\s+evening\b/i, timeOfDay: 'evening', frequency: 'every other day', originalTermRegexPos: 0 },
  { regex: /\bevery\s+other\s+night\b/i, timeOfDay: 'bedtime', frequency: 'every other day', originalTermRegexPos: 0 },
  { regex: /\bdaily\s+in\s+(the\s+)?evening\b/i, timeOfDay: 'evening', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bdaily\s+(at\s+)?night\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bdaily\s+(at\s+)?bedtime\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTermRegexPos: 0 },

  { regex: /\bdaily\s+in\s+(the\s+)?morning\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bqam\b/i, timeOfDay: 'morning', frequency: 'daily', originalTerm: 'qam' },
  { regex: /\bevery\s+am\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bevery\s+morning\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },
  // General "morning" - its frequency will be defaulted to 'daily' later if not set by a more specific rule above
  { regex: /\b(in\s+the\s+)?morning\b/i, timeOfDay: 'morning', originalTermRegexPos: 0 },

  { regex: /\b(?:at\s+)?(?:noon|midday)\b/i, timeOfDay: 'noon', frequency: 'daily', originalTermRegexPos: 0 },

  { regex: /\bqpm\b/i, timeOfDay: 'evening', frequency: 'daily', originalTerm: 'qpm' },
  { regex: /\bevery\s+evening\b/i, timeOfDay: 'evening', frequency: 'daily', originalTermRegexPos: 0 },
  // General "evening" - its frequency will be defaulted to 'daily' later
  { regex: /\b(in\s+the\s+)?evening\b/i, timeOfDay: 'evening', originalTermRegexPos: 0 },

  { regex: /\bqhs\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTerm: 'qhs' },
  { regex: /\bhs\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTerm: 'hs' },
  { regex: /\bnightly\b/i,  timeOfDay: 'bedtime', frequency: 'daily', originalTerm: 'nightly' },
  { regex: /\bevery\s+night\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bat\s+night\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTermRegexPos: 0 }, // Specific "at night"
  // General "bedtime" - its frequency will be defaulted to 'daily' later
  { regex: /\b(at\s+)?bedtime\b/i, timeOfDay: 'bedtime', originalTermRegexPos: 0 },
  // General "night" as a fallback for bedtime - its frequency will be defaulted to 'daily' later
  { regex: /\bnight\b/i, timeOfDay: 'bedtime', originalTermRegexPos: 0 }
];

let todProcessed = false;
for (const mapping of timeOfDayMappings) {
  const match = orderStr.match(mapping.regex);
  if (match) {
    order.timeOfDay = mapping.timeOfDay;
    order.timeOfDayOriginal = (mapping.originalTerm || match[0]).toLowerCase().trim();
    const entirePhraseToRemove = match[0];
    orderStr = orderStr.replace(entirePhraseToRemove, "").trim();

    if (mapping.frequency && !order.frequency) {
      order.frequency = mapping.frequency;
    } else if (!mapping.frequency && !order.frequency && /\bdaily\b/i.test(entirePhraseToRemove) && !/\bevery\s+other\b/i.test(entirePhraseToRemove)) {
      order.frequency = 'daily';
    }
    todProcessed = true;
    // console.log(`DEBUG parseOrder Step 1 (TimeShorthand): tod="${order.timeOfDay}", freq="${order.frequency}", orderStr="${orderStr}"`);
    break; // Processed one, move on
  }
}

// If a time of day was found (e.g. "morning") but frequency wasn't set by a specific shorthand (like qam, every morning)
// then check for weekly-style phrases before assuming it's a daily frequency.
if (order.timeOfDay && !order.frequency) {
    const weeklyPattern = /\b(?:once\s+weekly|once\s+a\s+week|weekly|every\s+(?:mon(?:day)?|tue(?:sday)?|wed(?:nesday)?|thu(?:rsday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?))\b/i;
    const weeklyMatch = orderStr.match(weeklyPattern);
    if (weeklyMatch) {
        order.frequency = 'weekly';
        order.frequencyTokens.push(weeklyMatch[0].toLowerCase());
        orderStr = orderStr.replace(weeklyMatch[0], '').trim();
    } else {
        order.frequency = 'daily';
    }
    // console.log(`DEBUG parseOrder Step 1 (Implied Freq): tod="${order.timeOfDay}", freq="${order.frequency}"`);
}
// After handling weekly vs daily, catch phrases like "2 times a day"
if (!order.frequency) {
  const m = orderStr.match(/(\d)\s*times\s+(?:a|per)\s+(?:day|daily)\b/i);
  if (m) {
    const map = { 1: 'daily', 2: 'bid', 3: 'tid', 4: 'qid' };
    order.frequency = map[m[1]] || '';
    order.frequencyTokens.push(m[0].toLowerCase());
    orderStr = orderStr.replace(m[0], '').trim();
  }
}
/* ——— NEW: capture “before / after breakfast|lunch|dinner”
          with an optional numeric offset ——— */
if (!order.timeOfDay) {
  const mealFreqMatch = orderStr.match(/\b(?:before|with)\s+meals\b/i);
  if (mealFreqMatch) {
    if (!order.frequency) order.frequency = 'tid';
    orderStr = orderStr.replace(mealFreqMatch[0], '').trim();
  }
}
if (!order.timeOfDay) {
  const explicitMeals = orderStr.match(/\bbefore\s+breakfast\s+lunch\s+dinner\b/i);
  if (explicitMeals) {
    if (!order.frequency) order.frequency = 'tid';
    orderStr = orderStr.replace(explicitMeals[0], '').trim();
  }
}
if (!order.timeOfDay) {
  const mealTiming =
    orderStr.match(/\b(?:\d+\s*(?:min(?:ute)?s?|hr|hrs?|hours?)\s*)?(before|after)\s+(breakfast|lunch|dinner)\b/i);
  if (mealTiming) {
    order.timeOfDay = mealTiming[0].replace(/\s+/g, ' ').trim();
    order.timeOfDayOriginal = mealTiming[0].toLowerCase().replace(/\s+/g, ' ').trim();
    if (!order.frequency) order.frequency = 'daily';      // give it a default
    orderStr = orderStr.replace(mealTiming[0], '').trim(); // strip the phrase

    /* ——— ALSO strip a trailing “daily” so it doesn’t sink into the drug name ——— */
    orderStr = orderStr.replace(/\bdaily\b/i, '').trim();
  }
}

// only strip “every” for time-of-day phrases
  orderStr = orderStr
    .replace(/\bevery\s+(morning|evening|night)\b/gi, '$1')
    .trim();

  // ── NEW: explicit clock-time → TOD mapping
  if (!todProcessed) {
    const clockRE =
      /\b(?:at\s*)?(\d{1,2})(?::(\d{2}))?\s*(?:\s?[ap]m)?\b|\b(\d{4})\b/gi;
    let cMatch = null;
    for (const m of orderStr.matchAll(clockRE)) {
      if (/[ap]m/i.test(m[0]) || m[0].includes(':') || m[3]) {
        cMatch = m;
        break;
      }
    }
    if (cMatch) {
      let hour;
      if (cMatch[3]) {
        const hh = parseInt(cMatch[3].slice(0, 2), 10);
        const mm = parseInt(cMatch[3].slice(2), 10);
        if (hh >= 0 && hh < 24 && mm >= 0 && mm < 60) {
          hour = hh;
        } else {
          hour = null;
        }
      } else {
        hour = parseInt(cMatch[1], 10);
        if (/pm/i.test(cMatch[0]) && hour < 12) hour += 12;
        if (/am/i.test(cMatch[0]) && hour === 12) hour = 0;
      }
      if (hour != null && (hour >= 21 || hour <= 3)) {
        order.timeOfDay = 'bedtime';
        order.timeOfDayOriginal = cMatch[0].toLowerCase();
        if (!order.frequency && /\bdaily\b/i.test(orderStr)) {
          order.frequency = 'daily';
          orderStr = orderStr.replace(/\bdaily\b/i, '').trim();
        }
        orderStr = orderStr.replace(cMatch[0], '').trim();
        todProcessed = true;
      }
    }
  }

  // 2. Extract Administration (with/without food/water)
  const adminMatch = orderStr.match(
    /\b(?:(with(?:out)?|w\/o?|before|after|between)\s*(orange\s*juice|meals?|meal|food|water|juice|liquid|supper|breakfast|lunch|dinner)|empty\s*stomach)\b/i
  );

  if (adminMatch) {
    let phrase = '';
    if (/empty\s*stomach/i.test(adminMatch[0])) {
      phrase = 'between meals';
    } else {
      const prefixRaw = adminMatch[1] || '';
      const noun = (adminMatch[2] || '').toLowerCase();
      let prefix = prefixRaw.toLowerCase();
      if (prefix === 'w/') prefix = 'with';
      if (prefix === 'w/o') prefix = 'without';
      phrase = `${prefix} ${noun}`.trim();
    }
    order.administration = normalizeAdministration(phrase);
    if (!order.frequency && /(?:before|with|between)\s+meals?/i.test(order.administration)) {
      order.frequency = 'tid';
    }
    orderStr = orderStr.replace(adminMatch[0], '').trim();
    // console.log(`DEBUG parseOrder Step 2 (Admin): order.administration="${order.administration}", orderStr="${orderStr}"`);
  }

// In parseOrder, START of new formulation parsing block (replaces old one)
const formulationKeywords = [
    'modified release', 'modified-release',
    'delayed release', 'delayed-release',
    'extended release', 'extended-release',
    'controlled release', 'controlled-release', // Multi-word first and hyphenated variants
    'xr', 'er', 'sr', 'la', 'xl', 'cr', 'dr',
    'succinate', 'tartrate', 'maleate', 'fumarate', 'besylate', 'camsylate', 'mesylate',
    'acetate', 'phosphate', 'carbonate', 'gluconate', 'propionate', 'sodium', 'hydrochloride'
].sort((a, b) => b.length - a.length); // Sort by length, longest first is crucial

let processedOrderStrForFormulation = orderStr; // Work on a copy
const foundFormulations = [];

for (const keyword of formulationKeywords) {
    const keywordRegex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
    let match;
    // Find all matches of the current keyword
    const matches = Array.from(processedOrderStrForFormulation.matchAll(keywordRegex));

    for (const currentMatch of matches.reverse()) { // Process matches from right to left to handle indices correctly
        const drugNameIfKeywordRemoved = (
            processedOrderStrForFormulation.substring(0, currentMatch.index) +
            processedOrderStrForFormulation.substring(currentMatch.index + currentMatch[0].length)
        ).trim().toLowerCase();

        let isSafeToExtract = true;
        if (drugNameIfKeywordRemoved.length < 2 && !/\d/.test(drugNameIfKeywordRemoved)) {
             // Avoid extracting if it leaves almost nothing sensible or just numbers
             isSafeToExtract = false;
        }
        // Further check: if the keyword itself is a common drug (e.g. "phosphate" as in "sodium phosphate")
        // and removing it leaves something that doesn't look like another drug, it might be part of the core name.
        // This is tricky; a good keyword list is key.
        // For example, we don't want to extract "phosphate" from "sodium phosphate" if "sodium" alone isn't the intended drug.
        // The current formulationKeywords list is mostly suffixes or release types, which is safer.

        if (isSafeToExtract) {
            foundFormulations.push({ text: currentMatch[0].toLowerCase(), index: currentMatch.index });
            // Temporarily replace to avoid re-matching parts of already found longer formulations by shorter ones
            processedOrderStrForFormulation =
                processedOrderStrForFormulation.substring(0, currentMatch.index) +
                " ".repeat(currentMatch[0].length) + // Replace with spaces to keep indices for other keywords
                processedOrderStrForFormulation.substring(currentMatch.index + currentMatch[0].length);
        }
    }
}

if (foundFormulations.length > 0) {
    // Sort found formulations by their original index to maintain order
    foundFormulations.sort((a, b) => a.index - b.index);
    order.formulation = foundFormulations.map(f => f.text).join(" ").trim();

    // Now, actually remove the extracted formulations from the original orderStr
    // Rebuild orderStr by removing all extracted formulation parts
    let tempStr = orderStr;
    for (const formulationPart of order.formulation.split(' ')) {
        if (formulationPart) { // Ensure part is not empty
             // Use a regex that matches the whole word formulation part
             const partRegex = new RegExp(`\\b${formulationPart.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
             tempStr = tempStr.replace(partRegex, '');
        }
    }
    orderStr = tempStr.replace(/\s\s+/g, ' ').trim();
}
orderStr = orderStr.trim();

// Remove boilerplate phrases that might remain attached to the drug name
orderStr = orderStr.replace(/\bcombination\b/i, '').trim();
orderStr = orderStr.replace(/\bmay\s+increase\s+to.*$/i, '').trim();

// console.log(`DEBUG parseOrder (Formulation): formulation="<span class="math-inline">\{order\.formulation\}", orderStr\="</span>{orderStr}"`);
// END of new formulation parsing block

    // 3. Extract PRN information
    orderStr = extractPrn(orderStr, order);

    // 4. Extract Indications
    orderStr = extractIndication(orderStr, order);

    // Extract Quantity (e.g., "2 tabs") before dose, as it might be part of the dose string
    orderStr = extractQuantity(orderStr, order);

  // 5. Extract Dose (mg/kg, combo-dose, then general unit parsing)
  // Strip parenthetical elemental-iron note
  orderStr = orderStr.replace(
    /\((?:\s*\d+\s*mg\s*elemental[^)]*)\)/i,
    ''
  ).trim();
  const weightMatch = orderStr.match(/(\d+(?:\.\d+)?)\s*mg\/kg\b/i);
  if (weightMatch) {
    order.dose = { value: parseFloat(weightMatch[1]), unit: 'mg/kg', total: null }; // total might need patient weight
    orderStr = orderStr.replace(weightMatch[0], '').trim();
  } else {
        const comboMatch = orderStr.match(/(\d+(?:\.\d+)?)\s*(?:mg)?\s*(?:-|\/|\+)\s*(\d+(?:\.\d+)?)\s*mg\b/i);
    if (comboMatch) {
      order.dose = {
                value: [parseFloat(comboMatch[1]), parseFloat(comboMatch[2])],
        unit: 'mg',
        total: null
      };
      orderStr = orderStr.replace(comboMatch[0], '').trim();
    } else {
      const multiMgMatches = [...orderStr.matchAll(/(\d+(?:\.\d+)?)\s*mg\b/ig)];
      if (multiMgMatches.length >= 2) {
        order.dose = {
          value: multiMgMatches.map(m => parseFloat(m[1])),
          unit: 'mg',
          total: null
        };
        multiMgMatches.forEach(m => { orderStr = orderStr.replace(m[0], '').trim(); });
      } else {

      // General dose unit parsing
const allUnits = Object.values(unitVariants).flat();
let unitMatchesFound = [];
for (let u of allUnits) {
  if (typeof u !== 'string' || !u) continue;
  const re = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*${u.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}\\b`, 'ig');
  let m;
  while ((m = re.exec(orderStr)) !== null) {
    const normUnit = u.toLowerCase() === "gram" ? "g" : u.toLowerCase();
    unitMatchesFound.push({ idx: m.index, qty: +m[1], rawUnit: normUnit, matchStr: m[0] });
  }
}

if (unitMatchesFound.length > 0) {
  const precedence = ['mcg','mg','g','mEq','unit','mL',
                      'tablet','capsule','patch','puff','spray','drop'];

  const hits = unitMatchesFound.map(m => {
    const stdUnit = Object.entries(unitVariants)
          .find(([std, arr]) => arr.includes(m.rawUnit))?.[0] || m.rawUnit;
    return { ...m, stdUnit, score: precedence.indexOf(stdUnit) };
  });

  hits.sort((a, b) => {
    if (a.score !== b.score) return a.score - b.score;  // better unit first
    return a.idx - b.idx;                               // tie → earlier hit
  });

  const bestMatch = hits[0];
  const sprayHit = hits.find(h => h.stdUnit === 'spray');
  let unitLower = bestMatch.stdUnit.toLowerCase();
  if (unitLower === "gram") unitLower = "g";
  order.rawUnit = unitLower; // store pre-normalization unit
  order.dose = { value: bestMatch.qty,
                 unit:  unitLower,
                 total: bestMatch.qty };

  if (sprayHit && order.qty === null) {
    order.qty = sprayHit.qty;
  }
  if (bestMatch.stdUnit === 'spray' && order.qty === null) {
    order.qty = bestMatch.qty;
  }
  if (order.qty !== null) {
    order.dose.total = bestMatch.qty * order.qty;
  }

  orderStr = orderStr.replace(bestMatch.matchStr, '').trim();
  // Capture trailing formulation tokens that may follow the strength (e.g. "1000 mg ER")
  let trailingForm = orderStr.match(/^[-\s]*(xr|er|sr|la|xl|cr|dr)\b/i);
  if (trailingForm) {
    order.formulation = (order.formulation ? order.formulation + ' ' : '') + trailingForm[1].toLowerCase();
    orderStr = orderStr.replace(trailingForm[0], '').trim();
  }
  // …and drop any leftover verb that preceded the dose phrase
  orderStr = orderStr.replace(/\b(?:give|take|administer)\b\s*/i, '').trim();
// If the best dose unit implies a form, set it if not already set
  if (bestMatch.stdUnit === 'tablet' && !order.form) order.form = 'tablet';
  else if (bestMatch.stdUnit === 'capsule' && !order.form) order.form = 'capsule';
  else if (bestMatch.stdUnit === 'puff' && !order.form) order.form = 'puff';
}
// Fallback if unitMatchesLoop didn't set a dose value but a number is present

      else if (!order.dose.value) {
         const doseUnitsForFallback = ['mcg','mg','g','ml','cc','unit','units','tsp','tbsp','drop','spray','puff','patch','lozenge','suppository','tablet','capsule','each','dose'];
         const fallbackDoseRegex = new RegExp(`(\\d+(?:\\.\\d+)?)(?:\\s*(${doseUnitsForFallback.join('|')})(?:s|es)?\\b)?`, 'i');
         // This regex tries to find a number, optionally followed by a unit.
         // Example: "1", "1 tablet", "10 mg"
         const fallbackMatch = orderStr.match(fallbackDoseRegex);
         if (fallbackMatch && fallbackMatch[1]) {
            const qty = parseFloat(fallbackMatch[1]);
            let unit = (fallbackMatch[2] || '').toLowerCase();
            let formFromUnit = "";

            if (unit) {
                // Normalize unit from unitVariants
                const foundStdUnit = Object.entries(unitVariants).find(([std, arr])=> arr.includes(unit));
                if(foundStdUnit) unit = foundStdUnit[0].toLowerCase();
                if (unit === "gram") unit = "g";

                // Check if this "unit" is actually a form
                if (unitVariants.tablet.includes(unit)) { formFromUnit = 'tablet'; unit = 'tablet';} // or keep unit as 'tablet'
                else if (unitVariants.capsule.includes(unit)) { formFromUnit = 'capsule'; unit = 'capsule';}
                // ... (add other form-like units)

                order.dose = { value: qty, unit: unit, total: qty };
                orderStr = orderStr.replace(fallbackMatch[0], '').trim();
                if(formFromUnit && !order.form) order.form = formFromUnit;
                 let trailingForm2 = orderStr.match(/^[-\s]*(xr|er|sr|la|xl|cr|dr)\b/i);
                if (trailingForm2) {
                    order.formulation = (order.formulation ? order.formulation + ' ' : '') + trailingForm2[1].toLowerCase();
                    orderStr = orderStr.replace(trailingForm2[0], '').trim();
                }
                // console.log(`DEBUG parseOrder Step 5 (Dose - fallbackDoseRegex): dose=${JSON.stringify(order.dose)}, orderStr="${orderStr}"`);
            }
         }
      }
    }
  }

  // Normalize dose units (mcg/g to mg) AFTER all dose parsing attempts
  if (order.dose.value !== null && typeof order.dose.value === 'number') { // Check if value is a number
    if (order.dose.unit === 'mcg') {
      order.dose.value = order.dose.value / 1000;
      order.dose.unit = 'mg';
      order.rawUnit = 'mg';
      order.dose.total = order.dose.value * (order.qty || 1);
    } else if (order.dose.unit === 'g') {
      order.dose.value = order.dose.value * 1000;
      order.dose.unit = 'mg';
      order.rawUnit = 'mg';
      order.dose.total = order.dose.value * (order.qty || 1);
    }
    // Round mg values
    if (order.dose.unit === 'mg') {
      order.dose.value = Math.round(order.dose.value * 1000) / 1000;
      if (order.dose.total != null) {
        order.dose.total = Math.round(order.dose.total * 1000) / 1000;
      }
    }
    // alias full word units
    if (order.dose.unit === 'gram') order.dose.unit = 'g';
  }
  // console.log(`DEBUG parseOrder: After dose normalization: dose=${JSON.stringify(order.dose)}, orderStr="${orderStr}"`);

  // Calculate total dose if qty is present
if (order.qty === null) { // If qty not parsed by qtyRegexEarly
    // Try to find qty from originalRaw if it wasn't stripped with dose/form, e.g. "Drug 50mg 2 tablets"
    const qtyLatePattern = new RegExp(`(?:^|\\s)((?:\\d+\\/\\d+|[\\u00bc-\\u00be]|\\d+(?:\\.\\d+)?))\\s*(${qtyWords.join('|')})(?:s)?\\b`, 'i');
    const qtyMatchLate = originalRaw.match(qtyLatePattern);
    if (qtyMatchLate) {
        // Check if this qty is not the same as dose.value to avoid double capture if unit was like 'tablet'
        const potentialQty = fractionToDecimal(qtyMatchLate[1]);
        if (!order.dose.value || Math.abs(order.dose.value - potentialQty) > 0.001 || order.dose.unit !== qtyMatchLate[2].toLowerCase().replace(/s$/,'') ) {
             if (orderStr.includes(qtyMatchLate[0])) { // If it's still in orderStr, remove it
                 orderStr = orderStr.replace(qtyMatchLate[0], '').trim();
             }
             order.qty = potentialQty;
        }
    }
}

if (order.dose.value !== null && typeof order.dose.value === 'number' && order.qty !== null && typeof order.qty === 'number') {
    order.dose.total = order.dose.value * order.qty;
} else if (order.dose.value !== null) {
    order.dose.total = order.dose.value; // Default total to value if qty is not applicable/found
}

// If dose unit itself is 'tablet' or 'capsule' and value is set, this implies qty if qty is still null
if (order.qty === null && (order.dose.unit === 'tablet' || order.dose.unit === 'capsule' || order.dose.unit === 'puff' || order.dose.unit === 'spray')) {
    if (order.dose.value && order.dose.value > 0) { // ensure value is a positive number
        order.qty = order.dose.value;
        if (order.dose.total === null) { // if total wasn't set by previous block
             order.dose.total = order.dose.value * order.qty; // This would be qty*qty, should be value is strength
        }
        // If the drug name itself likely contains the strength, this logic is fine.
        // Example: "Drug 50mg 1 tablet" -> dose.value=1, dose.unit=tablet, qty=1. Total=1.
        // Example: "Drug 2 puffs" -> dose.value=2, dose.unit=puff, qty=2. Total=4 (if value isn't # of puffs).
        // This needs care: if dose.value was *already* the count of units, then total is just value.
        // Let's assume if unit is tablet/capsule/puff, dose.value IS the count for that unit.
        if (order.dose.unit === 'tablet' || order.dose.unit === 'capsule' || order.dose.unit === 'puff' || order.dose.unit === 'spray') {
             order.dose.total = order.dose.value; // The "value" is the number of these items
        }
    }
}

// 6. Extract Form (override generic forms with specific terms if found)
{
  // New, more specific form words list - longest phrases first
  const formDefinitions = [
    { term: 'extended-release tablet', canonical: 'extended-release tablet' },
    { term: 'delayed-release tablet', canonical: 'delayed-release tablet' },
    { term: 'chewable tablet', canonical: 'chewable tablet' },
    { term: 'effervescent tablet', canonical: 'effervescent tablet' },
    { term: 'sublingual tablet', canonical: 'sublingual tablet' },
    { term: 'oral disintegrating tablet', canonical: 'oral disintegrating tablet' },
    { term: 'odt', canonical: 'oral disintegrating tablet' }, // ODT
    { term: 'tablet', canonical: 'tablet' },
    { term: 'extended-release capsule', canonical: 'extended-release capsule' },
    { term: 'delayed-release capsule', canonical: 'delayed-release capsule' },
    { term: 'capsule', canonical: 'capsule' },
    { term: 'caplet', canonical: 'caplet' },
    { term: 'softgel', canonical: 'softgel' },
    { term: 'patch', canonical: 'patch' }, { term: 'patches', canonical: 'patch' },
    { term: 'lozenge', canonical: 'lozenge' },
    { term: 'suppository', canonical: 'suppository' },
    { term: 'spray', canonical: 'spray' },
    { term: 'puff', canonical: 'puff' },
    { term: 'drop', canonical: 'drop' }, { term: 'drops', canonical: 'drop' },
    { term: 'suspension', canonical: 'suspension' },
    { term: 'solution', canonical: 'solution' },
    { term: 'elixir', canonical: 'elixir' },
    { term: 'syrup', canonical: 'syrup' },
    { term: 'liquid', canonical: 'liquid' },
    { term: 'cream', canonical: 'cream' },
    { term: 'ointment', canonical: 'ointment' },
    { term: 'gel', canonical: 'gel' },
    { term: 'inhaler', canonical: 'inhaler' },
    { term: 'mdi', canonical: 'inhaler' },
          { term: 'flexpen', canonical: 'pen' },
          { term: 'solostar', canonical: 'pen' },
          { term: 'respimat', canonical: 'respimat' },
          { term: 'handihaler', canonical: 'handihaler' },
    { term: 'nebule', canonical: 'nebule' }, { term: 'nebulizer solution', canonical: 'nebule'}
  ];

  // Build regex from sorted form terms (longest first to ensure correct matching)
  const sortedFormTerms = formDefinitions.map(fd => fd.term).sort((a, b) => b.length - a.length);
  // Escape terms for regex and join with |
  const formRegexPattern = sortedFormTerms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
  const formRegex = new RegExp(`\\b(${formRegexPattern})\\b`, 'i');
  const formMatch = orderStr.match(formRegex);

  if (formMatch && formMatch[1]) {
    const matchedTerm = formMatch[1].toLowerCase();
    // Find the definition again using the matched term (case-insensitive find)
    const definition = formDefinitions.find(fd => fd.term.toLowerCase() === matchedTerm);
    if (definition) {
      if (!order.form || ["tablet","capsule","caplet","softgel"].includes(order.form)) {
        order.form = definition.canonical;
      }
      orderStr = orderStr.replace(formMatch[0], "").trim();
      // console.log(`DEBUG parseOrder Step 6 (Form): order.form="${order.form}", orderStr="${orderStr}"`);
    }
  }
} 

  // 7. Extract Route
  const routes = [
    { standard: "po", variations: ["po", "oral", "orally", "by mouth"] }, { standard: "sl", variations: ["sl", "sublingual", "sublingually"] },
    { standard: "buccal", variations: ["buccal"] }, { standard: "pr", variations: ["pr", "rectal", "rectally"] },
    { standard: "ng", variations: ["ng", "nasogastric", "ng tube"] }, { standard: "og", variations: ["og", "orogastric"] },
    { standard: "gastrostomy", variations: ["gastrostomy", "g-tube", "peg tube"] }, { standard: "jejunostomy", variations: ["jejunostomy", "j-tube"] },
    { standard: "iv", variations: ["iv", "intravenous", "intravenously"] }, { standard: "im", variations: ["im", "intramuscular", "intramuscularly"] },
    { standard: "subq", variations: ["subq", "sc", "subcutaneous", "subcutaneously"] }, { standard: "id", variations: ["id", "intradermal"] },
    { standard: "io", variations: ["io", "intraosseous"] }, { standard: "intrathecal", variations: ["intrathecal"] },
    { standard: "epidural", variations: ["epidural"] }, { standard: "topical", variations: ["topical", "topically", "apply to skin"] },
    { standard: "transdermal", variations: ["transdermal"] }, { standard: "ophthalmic", variations: ["ophthalmic", "in eye", "eye drop"] },
    { standard: "otic", variations: ["otic", "in ear", "ear drop"] }, { standard: "nasal", variations: ["nasal", "intranasal", "in nose", "nasal spray"] },
    { standard: "vaginal", variations: ["vaginal", "vaginally"] }, { standard: "urethral", variations: ["urethral"] },
    { standard: "intrauterine", variations: ["intrauterine"] }, { standard: "inhalation", variations: ["inhalation", "inhalations", "inhaled", "inh", "inhale", "mdi", "dpi", "nebulized", "neb", "handihaler", "respimat"] },
    { standard: "intraperitoneal", variations: ["intraperitoneal"] }, { standard: "intraarticular", variations: ["intraarticular", "intra-articular"] },
    { standard: "intrapleural", variations: ["intrapleural"] }, { standard: "intravesical", variations: ["intravesical"] },
    { standard: "implantable", variations: ["implantable"] }
  ];
  if (!order.route) {
    for (const routeDef of routes) {
      for (const variation of routeDef.variations) {
        const routeRegex = new RegExp(`\\b${variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
        if (routeRegex.test(orderStr)) {
          order.route = routeDef.standard;
          orderStr = orderStr.replace(routeRegex, '').trim();
          break;
        }
      }
      if (order.route) break;
    }
    // console.log(`DEBUG parseOrder Step 7 (Route): order.route="${order.route}", orderStr="${orderStr}"`);
  }

  // 8. Extract Frequency

// Explicitly check for "immediately" first, as it's a specific frequency from "stat" or "now"
const immediatelyPattern = /\bimmediately\b/i;
if (!order.frequency && immediatelyPattern.test(orderStr)) {
    order.frequency = "immediately";
    order.frequencyTokens.push('immediately');
    orderStr = orderStr.replace(immediatelyPattern, '').trim();
    // console.log(`DEBUG parseOrder Step 8a (Immediately): order.frequency="<span class="math-inline">\{order\.frequency\}", orderStr\="</span>{orderStr}"`);
}
// Now proceed with other frequency checks if not "immediately"
  // Try to detect primary frequency terms before other clauses override them
  if (!order.frequency) {
    // Try to find primary frequencies (daily, bid, tid, qid) if they are clearly part of the main instruction
    // This regex looks for these terms, possibly preceded by common verbs like "take", "po", "by mouth"
    // and NOT followed by words that might indicate it's part of a different clause (like 'for', 'if', 'until', 'check', 'adjust')
    const primaryFreqPattern = /(?:\b(?:take|give|po|by mouth|orally)\s+)?\b(daily|bid|tid|qid)\b(?!\s+(?:for|if|until|check|adjust)\b)/i;
    const primaryMatch = orderStr.match(primaryFreqPattern);

    if (primaryMatch && primaryMatch[1]) {
      const preceding = orderStr.slice(0, primaryMatch.index).trim();
      const numWordRE = /(once|twice|thrice|one|two|three|four|five|six|seven|eight|nine|ten|\d+)\s*(?:x|times?|time)?\s*$/i;
      if (!numWordRE.test(preceding)) {
        const matchedFreq = primaryMatch[1].toLowerCase();
        // Ensure it's a canonical frequency term before assigning
        const canonicalMap = { daily: 'daily', bid: 'bid', tid: 'tid', qid: 'qid' };
        if (canonicalMap[matchedFreq]) {
          order.frequency = canonicalMap[matchedFreq];
          // Use primaryMatch[0] for removal to remove the whole matched segment e.g., "PO daily" or just "daily"
          if (DEBUG)
            console.log(
              `parseOrder Step 8 (Primary Freq Match): Matched "${primaryMatch[0]}" for frequency "${order.frequency}"`
            );
          order.frequencyTokens.push(primaryMatch[0].toLowerCase().trim());
          orderStr = orderStr.replace(primaryMatch[0], '').trim();
        }
      }
    }
  }

  // — Prefer the main dose frequency over monitoring verbs —
  // Look for daily / bid / tid / qid that are linked to the *take* clause;
  // ignore ones attached to ‘check / monitor / adjust’.
  if (!order.frequency) {
    const primaryFreqRE =
      /(?:\b(?:take|give|inject|inhale|apply|use|po|by\s+mouth|orally)\s+)?\b(daily|bid|tid|qid)\b(?!\s+(?:for|if|until|check|monitor|adjust)\b)/i;
    const m = orderStr.match(primaryFreqRE);
    if (m) {
      const preceding = orderStr.slice(0, m.index).trim();
      const numWordRE = /(once|twice|thrice|one|two|three|four|five|six|seven|eight|nine|ten|\d+)\s*(?:x|times?|time)?\s*$/i;
      if (!numWordRE.test(preceding)) {
        const map = { daily: 'daily', bid: 'bid', tid: 'tid', qid: 'qid' };
        order.frequency = map[m[1].toLowerCase()];
        order.frequencyTokens.push(m[0].toLowerCase().trim());
        orderStr = orderStr.replace(m[0], '').trim();
      }
    }
  }
  if (!order.frequency) {
  
  const qhMatch = orderStr.match(/\bq(\d+)h\b/i);
  if (qhMatch) {
    order.frequency = `q${qhMatch[1]}h`;
    order.frequencyTokens.push(qhMatch[0].toLowerCase());
    orderStr = orderStr.replace(qhMatch[0], '').trim();
  } else {
    
    // *** NEW CHECK FOR qXhrs ***
    const qhrsMatch = orderStr.match(/\bq(\d+)(?:hrs|hr)\b/i); // Match q<number>hrs or q<number>hr
    if (qhrsMatch) {
        order.frequency = `q${qhrsMatch[1]}h`; // Normalize to qXh
        order.frequencyTokens.push(qhrsMatch[0].toLowerCase());
        orderStr = orderStr.replace(qhrsMatch[0], '').trim();
        // console.log(`DEBUG parseOrder Step 8b (qXhrs): freq="<span class="math-inline">\{order\.frequency\}", orderStr\="</span>{orderStr}"`);
    } else { // This 'else' means qXhrs also failed
        const everyHours = orderStr.match(/\bevery\s*(\d+)\s*(?:hours?|h|hr|hrs)\b/i);
        if (everyHours) {
          order.frequency = `q${everyHours[1]}h`;
          order.frequencyTokens.push(everyHours[0].toLowerCase());
          orderStr = orderStr.replace(everyHours[0], '').trim();
        } else {
          const freqMapping = getFrequencyMap();
          const sortedFreqKeys = Object.keys(freqMapping).sort((a, b) => b.length - a.length);
          for (const key of sortedFreqKeys) {
            const pattern = new RegExp(`\\b${key.replace(/\s+/g, '\\s+')}\\b`, 'i');
            // Check !order.frequency again inside the loop
            if (!order.frequency && pattern.test(orderStr)) {
              const m = orderStr.match(pattern);
              order.frequency = freqMapping[key];
              if (m) order.frequencyTokens.push(m[0].toLowerCase());
              orderStr = orderStr.replace(pattern, '').trim();
              break;
            }
          }
        }
	}
    }
}
}
// ... (end of Step 8 for frequency parsing)
  if (!order.frequency && order.timeOfDay) {
    order.frequency = 'daily';
  }
  order.frequency = normalizeFrequency(order.frequency);
  if (
    order.frequency === 'tid' &&
    /twice\s+(?:a|per)?\s*day\s+with\s+meals/i.test(originalRaw)
  ) {
    order.frequency = 'bid';
  }
  if (
    order.frequency === 'tid' &&
    /\bbid\s+with\s+meals/i.test(originalRaw)
  ) {
    order.frequency = 'bid';
  }
  // console.log(`DEBUG parseOrder Step 8 (Frequency): order.frequency="${order.frequency}", orderStr="${orderStr}"`);

// 9. Final Drug Name and Indication Assignment from remaining orderStr

orderStr = orderStr.trim();
// Add a console log to see what orderStr looks like before this final step
// console.log(`DEBUG parseOrder Step 9 - Initial orderStr for drug/indication: "${orderStr}"`);

// Aggressively try to remove known non-drug components that might still be attached
// This is a safety net; ideally, earlier parsing steps should have removed these.

// Remove fully parsed dates again if they were missed (using the populated order.startDate/endDate)
if (order.startDate) {
    const sdPattern = new RegExp(`\\b(?:start|started|on)\\s*:\\s*${order.startDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi');
    orderStr = orderStr.replace(sdPattern, '').trim();
    orderStr = orderStr.replace(new RegExp(`\\b${order.startDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim(); // Remove standalone date too
}
if (order.endDate) {
    const edPattern = new RegExp(`\\b(?:end|ended|stop|stopped|dc|d\\/c|discontinue(?:d)?)\\s*:\\s*${order.endDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi');
    orderStr = orderStr.replace(edPattern, '').trim();
    orderStr = orderStr.replace(new RegExp(`\\b${order.endDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim();
}
// Remove generic date patterns again
orderStr = orderStr.replace(/\b\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4})\b/g, '').trim();

// Remove common instruction prefixes/suffixes if they are still glued
const instructionWords = ['take', 'give', 'inhale', 'inject', 'apply', 'use', 'place', 'administer', 'chew', 'dissolve', 'spray', 'sprinkle', 'one', 'two', 'three', 'tablet', 'capsule', 'cap', 'tab', 'pill'];
instructionWords.forEach(word => {
    orderStr = orderStr.replace(new RegExp(`^${word}\\s+`, 'i'), '').trim();
    orderStr = orderStr.replace(new RegExp(`\\s+${word}$`, 'i'), '').trim();
});


      if (!order.frequency) {
          const abbr = orderStr.match(/\b(qd|bid|tid|qid)\b/i);
          if (abbr) {
              const map = { qd: 'daily', bid: 'bid', tid: 'tid', qid: 'qid' };
              order.frequency = map[abbr[1].toLowerCase()];
              orderStr = orderStr.replace(abbr[0], '').trim();
          }
      }
// Remove common route/frequency/formulation remnants if they are at the very end or beginning
const trailingRemnants = [
  'po',
  'by mouth',
  'oral',
  'sublingual',
  'sl',
  'iv',
  'im',
  'sc',
  'subq',
  'topical',
  'daily',
  'bid',
  'tid',
  'qid',
  'qhs',
  'prn',
  'er',
  'xr',
  'sr',
  'dr',
  'odt',
  'solution',
  'suspension',
  'ointment',
  'cream',
  'gel',
  'patch',
  'inhaler',
  'for',
  'with',
  'at',
  'and',
  'as needed',
  'if needed',
  'in morning',
  'in evening',
  'at bedtime',
  'at noon',
  'unit',
  'units',
  'mcg',
  'mg',
  'ml',
  'meq',
  'iu'
];
trailingRemnants.forEach(remnant => {
    // Regex to match whole word at start or end, mindful of multi-word remnants
    const remnantPatternStart = new RegExp(`^${remnant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\s+|\\b|$)`, 'i');
    const remnantPatternEnd = new RegExp(`(\\s+|\\b|^)${remnant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i');
    orderStr = orderStr.replace(remnantPatternStart, '').trim();
    orderStr = orderStr.replace(remnantPatternEnd, '').trim();
});

orderStr = orderStr.replace(/[.,;]$/, '').trim(); // Remove trailing punctuation
orderStr = orderStr.replace(/^[.,;]/, '').trim();  // Remove leading punctuation
orderStr = orderStr.replace(/\s\s+/g, ' ').trim(); // Collapse multiple spaces
// Remove stray leading or trailing hyphens introduced by formatting
orderStr = orderStr.replace(/^\s*-\s*/, '').replace(/\s*-\s*$/, '').trim();
// Remove trailing solitary prepositions like "in" or "at"
orderStr = orderStr.replace(/\b(?:in|at|on)\s*$/i, '').trim();

// console.log(`DEBUG parseOrder Step 9 - orderStr after targeted cleanup: "${orderStr}"`);

let finalDrugName = "";

if (orderStr.length > 0) {
    // Attempt to identify known medication names (longest first) from the beginning of orderStr
    let knownMedNamesForExtraction = [];
    commonMedications.forEach(m => {
        knownMedNamesForExtraction.push(m.generic.toLowerCase());
        m.brands.forEach(b => knownMedNamesForExtraction.push(b.toLowerCase()));
    });
    criticalMeds.forEach(cm => { // Add critical meds as they are important to identify correctly
        if (!knownMedNamesForExtraction.includes(cm)) {
            knownMedNamesForExtraction.push(cm);
        }
    });
    knownMedNamesForExtraction = [...new Set(knownMedNamesForExtraction)].sort((a, b) => b.length - a.length);

    let matchedKnownName = "";
    for (const knownName of knownMedNamesForExtraction) {
        if (orderStr.toLowerCase().startsWith(knownName)) {
            // Check if the match is a whole word or followed by typical drug name extenders (XR, ER, HCTZ, numbers for strength)
            const afterMatch = orderStr.substring(knownName.length).trim();
            const nextWord = afterMatch.split(' ')[0].toLowerCase();
            const knownSuffixes = ['xr', 'er', 'sr', 'hcl', 'sodium', 'potassium', 'maleate', 'tartrate', 'succinate', 'acetate', 'phosphate', 'carbonate', 'hydrochloride', 'hctz', 'plus', 'dm', 'pm', 'forte'];
            
            if (afterMatch === "" || !/^[a-zA-Z]/.test(afterMatch) || knownSuffixes.includes(nextWord) || /^\d/.test(nextWord) || /^\//.test(afterMatch) || /^-/.test(afterMatch)) {
                 // It's likely the end of the drug name or followed by a strength/formulation
                let tempDrugName = orderStr.substring(0, knownName.length);
                let tempRemainder = afterMatch;

                // Try to grab common extenders like XR, numbers, or combo parts
                if (tempRemainder) {
                    const comboPartRegex = /^\s*([\/\-]\s*[a-zA-Z0-9\s.]+|(?:xr|er|sr|dr|hctz|hcl|sodium|potassium|\d+(\.\d+)?(?:mg|mcg|g|units)?)(?:\s+|$))/i;
                    const comboMatch = tempRemainder.match(comboPartRegex);
                    if (comboMatch && comboMatch[0]) {
                        tempDrugName += comboMatch[0];
                        tempRemainder = tempRemainder.substring(comboMatch[0].length).trim();
                    }
                }
                matchedKnownName = tempDrugName.trim();
                break;
            }
        }
    }

    if (matchedKnownName) {
        finalDrugName = matchedKnownName;
    } else {
        // Fallback: if no known drug name matches, take first 1-3 words as drug.
        // This is a heuristic and might be wrong for new/uncommon drugs.
        const words = orderStr.split(/\s+/);
        if (words.length > 0) {
            if (words.length <= 2) {
                finalDrugName = words.join(" ");
            } else { // If more than 2 words, take first 2 if they seem like a drug, else first 1.
                const firstTwo = words[0] + " " + words[1];
                // Simple check: if first two words are not just numbers or very short common words
                if (!/^\d+$/.test(words[0]) && !/^\d+$/.test(words[1]) && (words[0].length > 2 || words[1].length > 2) ) {
                    finalDrugName = firstTwo;
                    
                } else {
                    finalDrugName = words[0];
                    
                }
            }
        }
    }
}

// Strip common inhaler device terms that can trail the drug name
const deviceWords = /\b(respimat|handihaler|actuation|flexpen|kwikpen|solostar|pen|diskus)\b/i;
orderStr = orderStr.replace(deviceWords, '').replace(/\/\s*$/, '').trim();
finalDrugName = finalDrugName.replace(deviceWords, '').replace(/\/\s*$/, '').trim();

// Assign to order object
const drugStr = finalDrugName
  .replace(/[^a-zA-Z0-9\/\s\-\.#]+/g, ' ') // Allow # for Tylenol #3
  .replace(/\s\s+/g, ' ')
  .trim()
  .toLowerCase();
order.rawDrug = drugStr;
const { name: drugName, brandTok } = normalizeMedicationName(drugStr);
order.drug = drugName;
order.brandTokens = brandTok;

// --- Indication catcher (only if the token 'for' is present) ---
  const indMatch = orderStr.match(/\bfor\s+(.+?)$/i);
  if (indMatch) {
    order.indication = normalizeIndication(indMatch[1].trim());
    orderStr = orderStr.replace(indMatch[0], '').trim();
  }
  if (!order.indication) {
    const leftover = orderStr.match(/\ballergies\b/i);
    if (leftover) {
      order.indication = 'allergies';
      orderStr = orderStr.replace(leftover[0], '').trim();
    }
  }

  // Additional check for INR-related instructions if indication still empty
  if (!order.indication || order.indication.trim() === '') {
    const orderStrLower = orderStr.toLowerCase();

    let inrInstruction = '';
    let matchedPattern = null;

    const adjustInrPattern = /\badjust\s+(?:per\s+)?inr\b/i;
    const checkInrWeeklyPattern = /\bcheck\s+inr\s+weekly\b/i;
    const checkInrPattern = /\bcheck\s+inr\b/i;

    if (adjustInrPattern.test(orderStrLower)) {
      inrInstruction = 'Adjust per INR';
      matchedPattern = adjustInrPattern;
    } else if (checkInrWeeklyPattern.test(orderStrLower)) {
      inrInstruction = 'Check INR weekly';
      matchedPattern = checkInrWeeklyPattern;
    } else if (checkInrPattern.test(orderStrLower)) {
      inrInstruction = 'Check INR';
      matchedPattern = checkInrPattern;
    }

    if (inrInstruction) {
      order.indication = inrInstruction;
      const matchResult = orderStr.match(matchedPattern);
      if (matchResult && matchResult[0]) {
        if (DEBUG)
          console.log(
            `parseOrder: Extracted INR instruction "${matchResult[0]}" into order.indication as "${order.indication}"`
          );
        orderStr = orderStr.replace(matchResult[0], '').trim();
      }
    }
  }

// If order.drug ended up empty from the above, try a last resort from initialCleanedDrugString
if (!order.drug && initialCleanedDrugString) {
    let fallbackDrug = initialCleanedDrugString;
    // Remove known non-drug parts from this fallback too
    if (order.startDate) fallbackDrug = fallbackDrug.replace(new RegExp(`\\b(?:start|started|on)\\s*:\\s*${order.startDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim();
    if (order.endDate) fallbackDrug = fallbackDrug.replace(new RegExp(`\\b(?:end|ended|stop|stopped|dc|d\\/c|discontinue(?:d)?)\\s*:\\s*${order.endDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim();
    fallbackDrug = fallbackDrug.replace(/\b\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4})\b/g, '').trim();
    // Take first 1-2 words as a very basic fallback
    order.drug = fallbackDrug.split(/\s+/).slice(0, 2).join(' ').replace(/[^a-zA-Z0-9\/\s\-\.#]+/g, ' ').replace(/\s\s+/g, ' ').trim().toLowerCase();
    // console.log(`DEBUG parseOrder Step 9 - Fallback to initial string for drug name: "${order.drug}"`);
}
// console.log(`DEBUG parseOrder Step 9 - Final drug: "${order.drug}", Final indication: "${order.indication}"`);

// Ensure drug field isn't empty if orderStr had content originally and nothing else was parsed
if (!order.drug && initialCleanedDrugString &&
    !order.startDate && !order.endDate &&
    !order.timeOfDay && !order.frequency &&
    !order.indication && !order.form && !order.formulation &&
    !order.route && !order.dose.value && !order.qty &&
    initialCleanedDrugString.trim().length > 0
) {
    // If orderStr contained something but nothing specific was parsed from it,
    // it's likely the drug name itself.
    order.drug = initialCleanedDrugString.trim().toLowerCase();
}

applyFinalNormalizations(order, troughNote, originalRaw);
  // calculate parsing confidence
  if (!order.drug || /^(medication|tablet)$/i.test(order.drug)) {
    parsingConfidence -= 35;
  }
  if (order.dose.value === null) {
    parsingConfidence -= 30;
  }
  if (order.dose.value !== null && !order.dose.unit) {
    parsingConfidence -= 15;
  }
  if (!order.frequency && !order.prn) {
    parsingConfidence -= 15;
  }
  if (!order.route) {
    parsingConfidence -= 10;
  }

  const origLen = (originalRaw || '').replace(/\s+/g, '').length || 1;
  const leftoverLen = (orderStr || '').replace(/\s+/g, '').length;
  const ratio = leftoverLen / origLen;
  if (ratio > 0.3) {
    parsingConfidence -= 25;
  } else if (ratio > 0.15) {
    parsingConfidence -= 15;
  }

  if (ocrConfidenceValue !== undefined && ocrConfidenceValue !== null) {
    if (ocrConfidenceValue < 0.6) {
      parsingConfidence -= 20;
    } else if (ocrConfidenceValue < 0.8) {
      parsingConfidence -= 10;
    }
  }

  parsingConfidence = Math.max(0, Math.min(100, Math.round(parsingConfidence)));

  // console.log('FINAL DEBUG Parsed order:', { parsed: order });
  return { parsed: order, confidence: parsingConfidence, originalRaw };
}

    function levenshteinDistance(a, b) {
      const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
      for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
      for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
          matrix[j][i] = Math.min(
            matrix[j][i - 1] + 1,
            matrix[j - 1][i] + 1,
            matrix[j - 1][i - 1] + indicator
          );
        }
      }
      return matrix[b.length][a.length];
    }

    // ------------------------------------------------------------------
// ------------------------------------------------------------------
//  String-similarity helper  (Levenshtein, normalised 0–1 score)
// ------------------------------------------------------------------
function similarity(a, b) {
  if (a === b) return 1;               // perfect match
  const maxLen = Math.max(a.length, b.length);
  if (maxLen === 0) return 1;          // two empty strings
  const distance = levenshteinDistance(a, b);
  return 1 - distance / maxLen;        // 0 = no overlap, 1 = identical
}

// ===========================================================
  // Find every contra‑indicated pair present in the full list
  // ===========================================================
function findContraIndications(allOrders) {
  const medsFound  = allOrders
        .map(o => coreDrugName(o.parsed.drug))   // << one canonical key
        .filter(Boolean);                        // drop blanks / junk
  const uniqueMeds = [...new Set(medsFound)];
  const warnings = [];

  uniqueMeds.forEach(med => {
    const badList = drugContraindications[med];
    if (!badList || badList.length === 0) return;

    badList.forEach(bad => {
      if (uniqueMeds.includes(bad)) {
        const key = [med, bad].sort().join(' + ');   // avoid duplicates A+B / B+A
        if (!warnings.find(w => w.key === key)) {
          warnings.push({ key, a: med, b: bad });
        }
      }
    });
  });

  return warnings;          // array like [{key:'atorvastatin + gemfibrozil', a:'atorvastatin', b:'gemfibrozil'}]
}

    function ordersAreEqual(a, b) {
	const norm = s => (s || '').toLowerCase().trim().replace(/\s+/g, ' ');
  // — NEW: orders with different startDates should _not_ be treated as equal
  if ((a.startDate || "") !== (b.startDate || "")) {
    return false;
  }

// Compare endDates (Fix 3.2)
  if ((a.endDate || "") !== (b.endDate || "")) {
    return false;
  }

  // 1) drug name and formulation
  const { name: normDrugA } = normalizeMedicationName(a.drug); // Substance name
  const { name: normDrugB } = normalizeMedicationName(b.drug); // Substance name
  const formulationA = norm(a.formulation);
  const formulationB = norm(b.formulation);

  // For two orders to be considered "equal" for the "Unchanged" category,
  // their substance name AND formulation should ideally match strictly.
  if (normDrugA !== normDrugB) return false;
  if (formulationA !== formulationB) return false;

  // 2) dose, total dose, and quantity
  const totalA = (a.dose.total != null ? a.dose.total : a.dose.value); // Prioritize total
  const totalB = (b.dose.total != null ? b.dose.total : b.dose.value); // Prioritize total

  if (totalA !== totalB || a.dose.unit !== b.dose.unit) return false;
  // If total dose and unit are same, also ensure quantity per administration is the same for strict equality
  if ((a.qty ?? 1) !== (b.qty ?? 1)) return false; // Default qty to 1 if null

  // 3) route
  if (a.route !== b.route) return false;

    /// 4) frequency  — treat “daily”, “q24h”, and blank as the same
	const canonFreq = f => {
 	 f = (f || '').toLowerCase().trim();
 	 return (f === '' || f === 'daily' || f === 'q24h') ? 'daily' : f;
	};

	const fA = canonFreq(a.frequency);
	const fB = canonFreq(b.frequency);

	// exact “qNh” forms (q4h, q6h, …) must match numerically
	const qA = fA.match(/^q(\d+)h$/);
	const qB = fB.match(/^q(\d+)h$/);

	if (qA && qB) {
  	if (+qA[1] !== +qB[1]) return false;
	} else if (fA !== fB) {
  	// fall back to fuzzy text similarity for phrases like “twice daily”
  	const freqSim = similarity(fA, fB);
  	if (freqSim < 0.85) return false;
}

  // ─── normalize time-of-day equivalence ───
  if (normalizeTimeOfDay(a.timeOfDay) !== normalizeTimeOfDay(b.timeOfDay)) {
    return false;
  }
  // ────────────────────────────────────────────

  // 5) dosage form must match …
  if ((a.form || '') !== (b.form || '')) return false;
  // 6) PRN flag …
  if (a.prn !== b.prn) return false;

// ——— ENSURE PAIN INDICATION MATCHES (NORMALIZED) ——— (Fix 1C)
{
  const ind1 = normalizeIndicationText(a.indication || '');
  const ind2 = normalizeIndicationText(b.indication || '');
  if (ind1 && ind2 && ind1 !== ind2) {
    return false;
  }
}
// ——————————————————————————————

  // 7) quantity per dose
  const qtyA = a.qty ?? 1;
  const qtyB = b.qty ?? 1;
  if (qtyA !== qtyB) return false;

  return true;
}

    function compareOrders(list1, list2) {
      let unchanged = [];
      let removed = [];
      let added = [];
      let matched2 = new Array(list2.length).fill(false);
      for (let orderObj1 of list1) {
        let found = false;
        for (let i = 0; i < list2.length; i++) {
          if (!matched2[i] && ordersAreEqual(orderObj1.parsed, list2[i].parsed)) {
            matched2[i] = true;
            unchanged.push({             //  ← NEW: remember BOTH originals
                              orig: orderObj1,           //     from the facility list
                              new : list2[i]             //     from the hospital list
                              });
            found = true;
            break;
          }
        }
        if (!found) removed.push(orderObj1);
      }
      for (let i = 0; i < list2.length; i++) {
        if (!matched2[i]) added.push(list2[i]);
      }
//=== STEP‑MERGESAME  ⬇︎ stop double‑counting identical meds =============
for (let i = removed.length - 1; i >= 0; i--) {
  const r = removed[i];
  const j = added.findIndex(a => ordersAreEqual(r.parsed, a.parsed));
  if (j !== -1) {
    unchanged.push({ orig: r, new: added[j] });
    removed.splice(i, 1);          // pull it from “removed”
    added.splice(j, 1);            // pull it from “added”
  }
}
//=== END STEP‑MERGESAME ===============================================

      return { unchanged, removed, added };
    }

    function diffRows(listA, listB) {
      const parseList = str =>
        (str || '')
          .split(/\r?\n/)
          .map(s => s.trim())
          .filter(Boolean)
          .map(line => ({ original: line, parsed: parseOrder(line) }));

      const arrA = parseList(listA);
      const arrB = parseList(listB);

      const { unchanged, removed, added } = compareOrders(arrA, arrB);

      const rows = [];
      unchanged.forEach(pair => {
        const reason = getChangeReason(pair.orig.parsed, pair.new.parsed);
        const label = reason === 'Misc. Change' ? 'Unchanged' : reason;
        rows.push({
          orig: pair.orig.original,
          new: pair.new.original,
          changes: label === 'Unchanged' ? [] : [label]
        });
      });
      removed.forEach(r => {
        rows.push({ orig: r.original, new: '', changes: ['Removed'] });
      });
      added.forEach(a => {
        rows.push({ orig: '', new: a.original, changes: ['Added'] });
      });

      rows.sort((a, b) => {
        const aUnchanged = a.changes.length === 0;
        const bUnchanged = b.changes.length === 0;
        if (aUnchanged === bUnchanged) return 0;
        return aUnchanged ? 1 : -1;
      });

      return rows;
    }

    if (typeof module !== 'undefined') module.exports.diffRows = diffRows;
    if (typeof window !== 'undefined') window.diffRows = diffRows;

    function isCriticalOrder(orderObj) {
      const text = orderObj.original.toLowerCase();
      return criticalMeds.some(med => text.includes(med));
    }

    function showScreen(screenId) {
      // Attempt to blur active text inputs to help with mobile zoom reset
      const ta1 = document.getElementById('photo1-text-input');
      if (ta1) ta1.blur();
      const ta2 = document.getElementById('photo2-text-input');
      if (ta2) ta2.blur();

      document.getElementById('error-message').textContent = '';
      document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
      updateProgress(screenId);
      const scroller = document.querySelector('.main-scroll');
      if (scroller) scroller.scrollTop = 0;
      window.scrollTo(0, 0);
    }

    function updateProgress(screenId) {
        // reset steps & lines
  ['step1','step2','step3','step4'].forEach(id=>{
    document.getElementById(id).classList.remove('filled','current');
  });
  ['line1-2','line2-3','line3-4'].forEach(id=>{
    document.getElementById(id).classList.remove('filled');
  });

      if (screenId === 'disclaimer-screen') {
        document.getElementById('step1').classList.add('current');
      } else if (screenId === 'photo1-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
      } else if (screenId === 'photo2-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
      } else if (screenId === 'results-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('filled');
        document.getElementById('step4').classList.add('filled');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
        document.getElementById('line3-4').classList.add('filled');
      }
    }

    function showLoading(msg) {
      const ld = document.getElementById('loading'),
            lt = document.getElementById('loading-text');
      ld.style.display = 'flex';
      lt.textContent = msg;
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(msg) {
      document.getElementById('error-message').textContent = msg;
    }

    // Hide upload controls after a list is finalized
    function showProcessedState(screenId) {
      const screen = document.getElementById(screenId);
      if (!screen) return;
      const h = screen.querySelector('h2');
      if (h && !h.dataset.orig) h.dataset.orig = h.textContent;
      if (h) h.textContent = 'List saved. Continue below or start over.';

      screen
        .querySelectorAll('[id^="initial-"], [id^="additional-"], .text-input-container, .upload-instructions')
        .forEach(el => {
          el.style.display = 'none';
        });
    }

    function acknowledgeDisclaimer() {
      showScreen('photo1-screen');
    }

    function handlePhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
    }

    function handleAdditionalPhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
      document.getElementById('photo1-capture2').value = "";
      document.getElementById('photo1-upload2').value = "";
    }

    function updatePhoto1UI() {
  // 1) grab the “You can take a photo…” paragraph
  const instr1 = document.querySelector('#photo1-screen .upload-instructions');
  // 2) hide it as soon as you've added ≥1 photo OR used the text‐paste path
  instr1.style.display = (photo1Files.length > 0 || hasTextInput1)
    ? 'none'
    : 'block';

  // Update count & Next-button state:
  document.getElementById('photo1-status').textContent =
    photo1Files.length + (photo1Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo1-next').disabled =
    photo1Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo1-preview', photo1Files, 1);

  if (photo1Files.length > 0) {
    // Show prompt with **Next** bold:
    const prompt1 = document.getElementById('photo1-prompt');
    prompt1.style.display = 'block';
    prompt1.innerHTML =
      `Photo ${photo1Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Next</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo1-options').style.display = 'none';
    document.getElementById('additional-photo1-option').style.display = 'flex';
  } else {
    // No photos → back to start
    document.getElementById('photo1-prompt').style.display = 'none';
    document.getElementById('initial-photo1-options').style.display = 'flex';
    document.getElementById('additional-photo1-option').style.display = 'none';
  }

  // Clear file inputs so you can re-select the same file if needed:
  document.getElementById('photo1-capture').value = "";
  document.getElementById('photo1-upload').value = "";
}

    function handlePhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
    }

    function handleAdditionalPhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
      document.getElementById('photo2-capture2').value = "";
      document.getElementById('photo2-upload2').value = "";
    }

    function updatePhoto2UI() {
    // 1) grab the “You can take a photo…” paragraph on screen 2
  const instr2 = document.querySelector('#photo2-screen .upload-instructions');
  // 2) hide it as soon as you've added ≥1 photo OR used the paste path
  instr2.style.display = (photo2Files.length > 0 || hasTextInput2)
    ? 'none'
    : 'block';

  // Update count & Compare-button state:
  document.getElementById('photo2-status').textContent =
    photo2Files.length + (photo2Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo2-compare').disabled =
    photo2Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo2-preview', photo2Files, 2);

  if (photo2Files.length > 0) {
    // Show prompt with **Compare** bold:
    const prompt2 = document.getElementById('photo2-prompt');
    prompt2.style.display = 'block';
    prompt2.innerHTML =
      `Photo ${photo2Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Compare</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo2-options').style.display = 'none';
    document.getElementById('additional-photo2-option').style.display = 'flex';
  } else {
    // No photos → back to start
    document.getElementById('photo2-prompt').style.display = 'none';
    document.getElementById('initial-photo2-options').style.display = 'flex';
    document.getElementById('additional-photo2-option').style.display = 'none';
  }

  // Clear file inputs
  document.getElementById('photo2-capture').value = "";
  document.getElementById('photo2-upload').value = "";
}

    function updatePreview(previewId, files, listNumber) {
      const container = document.getElementById(previewId);
      container.innerHTML = "";
      files.forEach((file, index) => {
        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.className = 'thumbnail-container';
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '<span class="material-icons">close</span>';
        deleteBtn.onclick = () => deletePhoto(listNumber, index);
        thumbnailDiv.appendChild(img);
        thumbnailDiv.appendChild(deleteBtn);
        container.appendChild(thumbnailDiv);
      });
    }

    function deletePhoto(listNumber, index) {
      if (listNumber === 1) {
        photo1Files.splice(index, 1);
        updatePhoto1UI();
      } else if (listNumber === 2) {
        photo2Files.splice(index, 1);
        updatePhoto2UI();
      }
    }

    function handleTextInput1() {
  const rawPastedText = document.getElementById('photo1-text-input').value; // Get raw text
  if (!rawPastedText.trim()) {
    showError('Please paste a medication list before submitting.');
    return;
  }
  document.getElementById('photo1-status').textContent = 'Processing pasted list...';
  hasTextInput1 = true;

  // Use keepOrderLines to process the pasted text.
  // keepOrderLines handles splitting, cleaning, merging (including EMR), and filtering.
  let processedOrderStrings = keepOrderLines(rawPastedText);

  if (DEBUG) console.log('handleTextInput1 - Processed Order Strings by keepOrderLines:', processedOrderStrings);

  if (processedOrderStrings.length === 0) {
    showError('No valid medication orders detected in the pasted list. Please try again.');
    document.getElementById('photo1-status').textContent = 'No orders found.';
    hasTextInput1 = false; // Reset if no orders found
    return;
  }

  meds1 = processedOrderStrings.map(medStr => {
    try {
      const result = parseOrder(medStr);
      if (!result || typeof result !== 'object') {
        console.warn('Parse failed for (handleTextInput1):', medStr, 'returning default object');
        return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
      }
      return { original: medStr, parsed: result.parsed, confidence: result.confidence };
    } catch (e) {
      console.error('Error parsing line (handleTextInput1):', medStr, e.stack || e);
      return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
    }
  });

  if (DEBUG) console.log('handleTextInput1 - Meds1 (parsed objects):', meds1);
  document.getElementById('photo1-status').textContent = '';
  document.getElementById('initial-photo1-options').style.display = 'none';
  document.getElementById('additional-photo1-option').style.display = 'none';
  document.getElementById('photo1-preview').innerHTML = "";
  photo1Files = [];
  document.getElementById('photo1-prompt').style.display = 'none';
  showError('');
  showProcessedState('photo1-screen');
  showScreen('photo2-screen');
}

    function handleTextInput2() {
  const rawPastedText = document.getElementById('photo2-text-input').value; // Get raw text
  if (!rawPastedText.trim()) {
    showError('Please paste a medication list before submitting.');
    return;
  }
  document.getElementById('photo2-status').textContent = 'Processing pasted list...';
  hasTextInput2 = true;

  // Use keepOrderLines to process the pasted text.
  let processedOrderStrings = keepOrderLines(rawPastedText);

  if (DEBUG) console.log('handleTextInput2 - Processed Order Strings by keepOrderLines:', processedOrderStrings);

  if (processedOrderStrings.length === 0) {
    showError('No valid medication orders detected in the pasted list. Please try again.');
    document.getElementById('photo2-status').textContent = 'No orders found.';
    hasTextInput2 = false; // Reset if no orders found
    return;
  }

  meds2 = processedOrderStrings.map(medStr => {
    try {
      const result = parseOrder(medStr);
      if (!result || typeof result !== 'object') {
        console.warn('Parse failed for (handleTextInput2):', medStr, 'returning default object');
        return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
      }
      return { original: medStr, parsed: result.parsed, confidence: result.confidence };
    } catch (e) {
      console.error('Error parsing line (handleTextInput2):', medStr, e.stack || e);
      return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
    }
  });

  if (DEBUG) console.log('handleTextInput2 - Meds2 (parsed objects):', meds2);
  document.getElementById('photo2-status').textContent = '';
  document.getElementById('photo2-compare').disabled = false; // Enable compare button
  document.getElementById('initial-photo2-options').style.display = 'none';
  document.getElementById('additional-photo2-option').style.display = 'none'; // Usually, after text input, we don't add more photos for that list.
  document.getElementById('photo2-preview').innerHTML = "";
  photo2Files = [];
  document.getElementById('photo2-prompt').style.display = 'block';
  document.getElementById('photo2-prompt').innerHTML = 'Click <strong>Compare</strong> to continue, or Start Over to reset.';
  showError('');
  showProcessedState('photo2-screen');
}

    async function goToPhoto2() {
      if (!hasTextInput1 && (!photo1Files || photo1Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput1) {
        showLoading('Processing first image(s)...');
        try {
      // processFiles now returns an array of objects { text, confidence }
      let processedOrderStrings = await processFiles(photo1Files);

      if (DEBUG) console.log('goToPhoto2 - Processed Order Strings from OCR:', processedOrderStrings);

      if (processedOrderStrings.length === 0) {
        hideLoading();
        showError('No valid medication orders detected in the first photos. Please try again.');
        return;
      }

      meds1 = processedOrderStrings.map(obj => {
        const medStr = obj.text;
        try {
          const result = parseOrder(medStr, obj.confidence);
          if (!result || typeof result !== 'object') {
            console.warn('Parse failed for (goToPhoto2 OCR):', medStr, 'returning default object');
            return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
          }
          return { original: medStr, parsed: result.parsed, confidence: result.confidence };
        } catch (e) {
          console.error('Error parsing line (goToPhoto2 OCR):', medStr, e.stack || e);
          return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
        }
      });

      if (DEBUG) console.log('goToPhoto2 - Meds1 (parsed objects from OCR):', meds1);
      hideLoading();
      showProcessedState('photo1-screen');
      showScreen('photo2-screen');
    } catch (err) { // This catch is for errors from processFiles or the mapping
      console.error('Error in goToPhoto2 OCR processing:', err);
      hideLoading();
      showError('Error processing text from the first photos. Please try again.');
    }
      }
    }

    async function comparePhotos() {
      if (!hasTextInput2 && (!photo2Files || photo2Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput2) {
        showLoading('Processing second image(s)...');
        try {
      // processFiles now returns an array of objects { text, confidence }
      let processedOrderStrings = await processFiles(photo2Files);

      if (DEBUG) console.log('comparePhotos - Processed Order Strings from OCR:', processedOrderStrings);

      if (processedOrderStrings.length === 0) {
        hideLoading();
        showError('No valid medication orders detected in the second photos. Please try again.');
        return;
      }

      meds2 = processedOrderStrings.map(obj => {
        const medStr = obj.text;
        try {
          const result = parseOrder(medStr, obj.confidence);
          if (!result || typeof result !== 'object') {
            console.warn('Parse failed for (comparePhotos OCR):', medStr, 'returning default object');
            return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
          }
          return { original: medStr, parsed: result.parsed, confidence: result.confidence };
        } catch (e) {
          console.error('Error parsing line (comparePhotos OCR):', medStr, e.stack || e);
          return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' }, confidence: 0 };
        }
      });

      if (DEBUG) console.log('comparePhotos - Meds2 (parsed objects from OCR):', meds2);
      hideLoading();
      showProcessedState('photo2-screen');
      compareAndShowResults();
    } catch (err) { // This catch is for errors from processFiles or the mapping
      console.error('Error in comparePhotos OCR processing:', err);
      hideLoading();
      showError('Error processing text from the second photos. Please try again.');
    }
      } else {
        compareAndShowResults();
      }
    }

// === CORE‑DRUG helper (global) ===
// Return the canonical medication name using the same logic as
// normalizeMedicationName().  This avoids duplicating brand/generic
// replacements here and keeps coreDrugName in sync with parsing logic.
const coreDrugName = n => {
  return normalizeMedicationName(n).name;
};

function compareAndShowResults() {
    let { unchanged, removed, added } = compareOrders(meds1, meds2);
        
//=== STEP-MERGE-REMOVED-ADDED (enhanced) ======================
const merged = [];
const addedMap = Object.create(null);

// --- START DEBUG LOGS FOR addedMap POPULATION ---
if (DEBUG) console.log("--- Building addedMap (Primary Merge Step) ---");
added.forEach(a => {
  const originalDrugString = a.original; // For logging
  const parsedDrugField = a.parsed.drug;
  // Use the first word of the normalized generic name as the primary key
  const primaryKey = normalizeMedicationName(parsedDrugField).name.split(' ')[0].trim();
  if (primaryKey) { // Ensure the key is not empty
      if (DEBUG) console.log(`  [addedMap]: Adding: Original Str: "<span class="math-inline">\{originalDrugString\}" \-\-\> Parsed Drug\: "</span>{parsedDrugField}" --> Primary Key: "${primaryKey}"`);
      addedMap[primaryKey] = a;
  } else {
      if (DEBUG) console.log(`  [addedMap]: SKIPPING ADD due to empty primaryKey. Original Str: "<span class="math-inline">\{originalDrugString\}", Parsed Drug\: "</span>{parsedDrugField}"`);
  }
});

if (DEBUG) console.log("--- Finished building addedMap. Keys: ", Object.keys(addedMap));
if (DEBUG) console.log("addedMap after build:", addedMap);
// --- END DEBUG LOGS FOR addedMap POPULATION ---

// --- START DEBUG LOGS FOR removed.filter (Primary Merge Step) ---
if (DEBUG) console.log("--- Filtering 'removed' list (Primary Merge Step) ---");
removed = removed.filter(r => {
  const originalRemovedDrugString = r.original;
  const parsedRemovedDrugField    = r.parsed.drug;

  // Use the first word of the normalized generic name for lookup
  const primaryLookupKey = normalizeMedicationName(parsedRemovedDrugField).name.split(' ')[0].trim();
  let match = undefined;
  let usedKey = "";

  if (primaryLookupKey) {
      if (DEBUG)
      console.log(
        `  [removed.filter]: Processing Removed: "<span class="math-inline">\{originalRemovedDrugString\}" → drug\="</span>{parsedRemovedDrugField}" → Primary Lookup Key: "${primaryLookupKey}"`
      );
      match = addedMap[primaryLookupKey];
      usedKey = primaryLookupKey;
  } else {
      if (DEBUG)
      console.log(
        `  [removed.filter]: SKIPPING LOOKUP due to empty primaryLookupKey for Removed: "<span class="math-inline">\{originalRemovedDrugString\}", Parsed Drug\: "</span>{parsedRemovedDrugField}"`
      );
  }

  if (!match) {
    if (DEBUG) console.log(`     NO MATCH for Primary Lookup Key: "${primaryLookupKey}" → keep in removed`);
    return true; // Keep in removed if no match
  }

  if (!match) {
    if (DEBUG) console.log(`    NO MATCH for either "${lookupKey}" or "${usedKey}" → keep in removed`);
    return true;
  }

  if (DEBUG)
  console.log(
    `    MATCH FOUND for key "${usedKey}" (merged with added original="${match.original}")`
  );
 
// Determine the reason using the comprehensive getChangeReason function,
// which now correctly accumulates multiple changes.
const reason = getChangeReason(r.parsed, match.parsed);

merged.push({ orig: r, new: match, reason });

    // purge every key in addedMap that still points to this matched entry:
  Object.keys(addedMap).forEach(k => {
    if (addedMap[k] === match) {
      delete addedMap[k];
    }
  });

  return false;
});

if (DEBUG) console.log("--- Finished filtering 'removed' list ---");

added = Object.values(addedMap);
if (DEBUG) console.log("Remaining addedMap keys (will appear as ‘Added’ rows):", Object.keys(addedMap));

//=== END STEP-MERGE-REMOVED-ADDED ==============================

//=== STEP‑FIX  skip any blank or junk entries =========================
const notBlank = obj =>
  obj && obj.original && obj.original.trim().length > 0;

unchanged = unchanged.filter(pair => notBlank(pair.orig) && notBlank(pair.new));
removed   = removed  .filter(notBlank);
added     = added    .filter(notBlank);
//=== END STEP‑FIX ======================================================

// ---------------------------------------------
//  CI scan **only** on the ACTIVE (hospital) list
// ---------------------------------------------
const activeOrders =
      meds2
      .concat( unchanged.map(p => p.new) );

const ciAlerts = findContraIndications(activeOrders);

/* build a highlight-set containing BOTH
   the raw names *and* their stripped cores */
const ciSet = new Set(
  ciAlerts.flatMap(w => {
    return [
      w.a,              // e.g. "simvastatin"
      w.b,              // e.g. "ketoconazole"
      coreDrugName(w.a),// e.g. "simvastatin"
      coreDrugName(w.b) // e.g. "ketoconazole"
    ];
  })
);

const finalResults = [];

// ---------------------------------------------

    // Process removed orders (potential changes or removals)

// ‑‑‑ FIRST: show the neatly‑merged pairs ‑‑‑
merged.forEach(pair => {
  const rowConfidence = Math.min(pair.orig.confidence, pair.new.confidence);
  finalResults.push({
    orig: pair.orig,
    new: pair.new,
    label: pair.reason,
    critical: isCriticalOrder(pair.new) && pair.reason !== 'Unchanged',
    ci: ciSet.has(coreDrugName(pair.orig.parsed.drug)) ||
        ciSet.has(coreDrugName(pair.new.parsed.drug)),
    changes: pair.reason === 'Unchanged' ? [] : [pair.reason],
    rowConfidence
  });
});
    
removed.forEach(r => {
        if (DEBUG) console.group(`🔍 Comparing removed: ${r.original}`);
        if (DEBUG) console.log('   current added[]:', added.map(a => a.original));
        const lowerRem = r.original.toLowerCase();
        let match = null;
        let changeType = null;

        // 1) Brand → generic?
        const brandKey = Object.keys(brandToGenericMap).find(b => lowerRem.includes(b));
        if (brandKey) {
            changeType = 'Generic Medication';
            const gen = brandToGenericMap[brandKey];
            match = added.find(a => normalizeMedicationName(a.parsed.drug).name === gen);
        }

        // 2) Generic → brand?
        if (!match) {
            const genKey = normalizeMedicationName(r.parsed.drug).name;
            const brandList = genericToBrandMap[genKey] || [];
            for (let brand of brandList) {
                const regex = new RegExp(`\\b${brand}\\b`, 'i');
                const found = added.find(a => regex.test(a.original));
                if (found) {
                    changeType = 'Brand Medication';
                    match = found;
                    break;
                }
            }
        }

        // 3) Substring match (fallback, less precise)
if (!match) {
    const drugName = r.parsed.drug.toLowerCase();
    match = added.find(a => a.original.toLowerCase().includes(drugName));
    if (match) {
        changeType = getChangeReason(r.parsed, match.parsed);
        if (DEBUG) console.log(`   → substring matched "${drugName}" to`, match.original);
    }
}  // <-- closes the if(!match) block correctly

        const crit = false;         // removed orders aren’t active any more

           // 4) Brand ↔ generic swap (also catch an indication tweak)
   if (match && (changeType === 'Generic Medication' || changeType === 'Brand Medication')) {
     // build a list of reasons
     const reasons = [ changeType ];
     const ind1 = normalizeIndicationText((r.parsed.indication || '').toLowerCase().trim());
     const ind2 = normalizeIndicationText((match.parsed.indication || '').toLowerCase().trim());
     if (ind1 !== ind2) {
       reasons.push('Indication changed');
     }
           finalResults.push({
              orig: r,
              new: match,
              label: reasons.join(', '),
              critical: false,
              ci: ciSet.has(coreDrugName(r.parsed.drug)) ||
                  (match && ciSet.has(coreDrugName(match.parsed.drug))),
              changes: reasons,
              rowConfidence: Math.min(r.confidence, match.confidence)
            });
     added = added.filter(a => a !== match);
     if (DEBUG) console.groupEnd();
     return;
   }

        // 5) Dose / freq / form / route / PRN / admin reasons
        if (match) {
            // Use getChangeReason to determine the specific change
            const reason = getChangeReason(r.parsed, match.parsed);
           finalResults.push({
                orig: r,
                new: match,
                label: reason,
                critical: crit,
                ci: false,
                changes: reason === 'Unchanged' ? [] : [reason],
                rowConfidence: Math.min(r.confidence, match.confidence)
            });
            added = added.filter(a => a !== match);
            if (DEBUG) console.groupEnd();
            return;
        }

        // 6) Same-drug match
        const sameDrug = added.find(a =>
            sameDrugCore(a.parsed.drug, r.parsed.drug)
        );
        if (sameDrug) {
            const reason = getChangeReason(r.parsed, sameDrug.parsed);
           finalResults.push({
                orig: r,
                new: sameDrug,
                label: reason,
                critical: crit,
                ci: false,
                changes: reason === 'Unchanged' ? [] : [reason],
                rowConfidence: Math.min(r.confidence, sameDrug.confidence)
            });
            added = added.filter(a => a !== sameDrug);
            if (DEBUG) console.groupEnd();
            return;
        }

        // 7) Pure removal
       finalResults.push({
            orig: r,
            new: null,
            label: 'Removed',
            critical: crit,
            ci: false,
            changes: ['Removed'],
            rowConfidence: r.confidence
        });
        if (DEBUG) console.groupEnd();
    });

    // Unchanged ‑‑→ now re‑evaluate for brand/generic etc.
   unchanged.forEach(u => {
      const reason = getChangeReason(u.orig.parsed, u.new.parsed);
      const label  = (reason === 'Misc. Change') ? 'Unchanged' : reason;

      finalResults.push({
        orig: u.orig,
        new: u.new,
        label,
        critical: label !== 'Unchanged' && (isCriticalOrder(u.orig) || isCriticalOrder(u.new)),
        ci: ciSet.has(coreDrugName(u.orig.parsed.drug)) ||
            ciSet.has(coreDrugName(u.new.parsed.drug)),
        changes: label === 'Unchanged' ? [] : [label],
        rowConfidence: Math.min(u.orig.confidence, u.new.confidence)
      });
     });

        // Added orders
   added.forEach(a => {
      const crit = isCriticalOrder(a);
      finalResults.push({
        orig: null,
        new: a,
        label: 'Added',
        critical: crit,
        ci: ciSet.has(coreDrugName(a.parsed.drug)),
        changes: ['Added'],
        rowConfidence: a.confidence
      });
    });

    finalResults.sort((a, b) => {
      const aUnchanged = (a.changes?.length === 0);
      const bUnchanged = (b.changes?.length === 0);
      if (aUnchanged === bUnchanged) return 0;
      return aUnchanged ? 1 : -1;
    });

    let html = `
        <table class="changes-table">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Original Order (Facility)</th>
                    <th>New Order (Hospital)</th>
                    <th>Suspected Change</th>
                    <th>Confidence <span class="tooltip">? <span class="tooltip-text">System's confidence in parsing accuracy. Lower scores warrant closer review.</span></span></th>
                </tr>
            </thead>
            <tbody>`;

    finalResults.forEach((row, i) => {
      const confClass = row.rowConfidence >= 85 ? 'confidence-high'
                        : row.rowConfidence >= 60 ? 'confidence-medium'
                        : 'confidence-low';
      html += `
        <tr class="${row.critical ? 'critical' : ''} ${row.ci ? 'ci-row' : ''}">
          <td>${i + 1}</td>
          <td>${row.orig ? row.orig.original : ''}</td>
          <td>${row.new ? row.new.original : ''}</td>
          <td>${row.label}</td>
          <td class="${confClass}">${row.rowConfidence}%</td>
        </tr>`;
    });

    html += `
            </tbody>
        </table>
    `;

    // ─── Append CI block below the table ───
    if (ciAlerts.length) {
      html += `
        <h3 style="margin-top:1.5rem; color: red; font-weight: bold;">
      Potential Contraindications
    </h3>
        <ul>
          ${ciAlerts.map(w =>
            `<li><strong>${w.a}</strong> should NOT be used with <strong>${w.b}</strong></li>`
          ).join('')}
        </ul>
        <p style="font-size:0.85rem;">
          These flags are a quick screen and do <em>not</em> replace clinical judgment.
        </p>
      `;
    }

    document.getElementById('results-content').innerHTML = html;
   
 // make the current CI list available for exportToPDF()
    window.currentContraAlerts = ciAlerts;

    showScreen('results-screen');
}

    async function exportToPDF() {
  // 1) grab your table
  const table = document.querySelector('.changes-table');
  // 2) init jsPDF
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });

  // 3) optional: add a title
  pdf.setFontSize(14);
  pdf.text('Comparison Results', 40, 40);

  // 4) render the table with AutoTable
  pdf.autoTable({
    html: table,
    startY: 60,
    theme: 'grid',
    headStyles: { fillColor: [240,240,240] },
    styles: {
      fontSize: 9,
      cellPadding: 4,
      overflow: 'linebreak'
    },
    // ensure no row ever splits across pages:
    pageBreak: 'avoid',
    didDrawPage: (data) => {
      // here you could add page numbers, headers, etc.
    }
  });

  // ——— Draw the CI header & list below the table ———
  const finalY = pdf.lastAutoTable.finalY + 20;
  if (window.currentContraAlerts?.length) {
    // 1) Section title
    pdf.setFontSize(12);
    pdf.text("Potential Contra-Indications", 40, finalY);

    // 2) Each warning item
    pdf.setFontSize(10);
    window.currentContraAlerts.forEach((w, i) => {
      pdf.text(
        `• ${w.a} should NOT be used with ${w.b}`,
        40,
        finalY + 15 + i * 12
      );
    });

    // 3) Footnote
    pdf.setFontSize(9);
    pdf.text(
      "These flags are a quick screen and do not replace clinical judgment.",
      40,
      finalY + 15 + window.currentContraAlerts.length * 12 + 10
    );
  }

  // 5) save the PDF
  pdf.save('MedRec_Report.pdf');
}

function printResults() {
  // 1) make sure we’re on the results screen
  showScreen('results-screen');

  // 2) give the browser a moment to apply your @media print CSS
  setTimeout(() => {
    window.print();
  }, 100);
}

    function startOver() {
      document.querySelectorAll('[data-orig]').forEach(h => {
        h.textContent = h.dataset.orig;
      });

      ['photo1-screen','photo2-screen'].forEach(id => {
        const s = document.getElementById(id);
        if (!s) return;
        s.querySelectorAll('[id^="initial-"]').forEach(el => el.style.display = 'flex');
        s.querySelectorAll('[id^="additional-"]').forEach(el => el.style.display = 'none');
        s.querySelectorAll('.text-input-container').forEach(el => el.style.display = 'flex');
        s.querySelectorAll('.upload-instructions').forEach(el => el.style.display = 'block');
      });
      photo1Files = [];
      photo2Files = [];
      meds1 = [];
      meds2 = [];
      hasTextInput1 = false;
      hasTextInput2 = false;
      document.getElementById('photo1-capture').value = '';
      document.getElementById('photo1-upload').value = '';
      document.getElementById('photo1-capture2').value = '';
      document.getElementById('photo1-upload2').value = '';
      document.getElementById('photo2-capture').value = '';
      document.getElementById('photo2-upload').value = '';
      document.getElementById('photo2-capture2').value = '';
      document.getElementById('photo2-upload2').value = '';
      document.getElementById('photo1-text-input').value = '';
      document.getElementById('photo2-text-input').value = '';
      document.getElementById('photo1-status').textContent = '';
      document.getElementById('photo2-status').textContent = '';
      document.getElementById('photo1-next').disabled = true;
      document.getElementById('photo2-compare').disabled = true;
      document.getElementById('results-content').innerHTML = '';
      document.getElementById('photo1-preview').innerHTML = "";
      document.getElementById('photo2-preview').innerHTML = "";
      document.getElementById('photo1-prompt').style.display = 'none';
      document.getElementById('initial-photo1-options').style.display = 'flex';
      document.getElementById('additional-photo1-option').style.display = 'none';
      document.getElementById('photo2-prompt').style.display = 'none';
      document.getElementById('initial-photo2-options').style.display = 'flex';
      document.getElementById('additional-photo2-option').style.display = 'none';
      showScreen('disclaimer-screen');
    }

    // Tooltip toggle for mobile
    document.querySelectorAll('.tooltip').forEach(tooltip => {
      tooltip.addEventListener('click', (e) => {
        e.stopPropagation();
        const isActive = tooltip.classList.contains('active');
        document.querySelectorAll('.tooltip').forEach(t => t.classList.remove('active'));
        if (!isActive) {
          tooltip.classList.add('active');
        }
      });
    });

    document.addEventListener('click', () => {
      document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.classList.remove('active');
      });
    });

    document.addEventListener('DOMContentLoaded', () => {
      hideLoading();
      updateProgress('disclaimer-screen');
    });
  </script>

</body>
</html>

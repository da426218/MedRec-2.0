<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MedRec 2.0</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    /* Basic Layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      background-color: #007bff;
      color: white;
      text-align: center;
      padding: 0.5rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      height: 185px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      box-sizing: border-box;
    }
    main {
      flex: 1;
      padding: 1rem;
      max-width: 600px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .screen {
      display: none;
      width: 100%;
      text-align: center;
    }
    .screen.active {
      display: block;
    }
    /* Card Styling */
    .card {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid #ddd;
      padding: 1rem;
      margin: 0.5rem 0;
      width: 100%;
      box-sizing: border-box;
    }
    /* Buttons & Inputs */
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      margin: 0.5rem 0;
      cursor: pointer;
      border-radius: 15px;
      width: 100%;
      max-width: 300px;
      display: block;
      font-weight: 600;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: box-shadow 0.2s ease;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #0056b3;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    /* Hide native file inputs */
    input[type="file"] {
      display: none;
    }
    .photo-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      margin: 1rem 0;
      width: 100%;
    }
    .photo-actions button {
      width: 100%;
      max-width: 300px;
      margin: 0;
    }
    .disclaimer-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1rem 0;
      width: 100%;
    }
    .disclaimer-actions button {
      width: 100%;
      max-width: 300px;
    }
    .upload-instructions {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #555;
    }
    .upload-prompt {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #333;
    }
    .preview-container {
      text-align: center;
      margin: 0.5rem 0 1rem;
    }
    .thumbnail-container {
      position: relative;
      display: inline-block;
      margin: 0.25rem;
    }
    .thumbnail-container img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    /* ============== delete (close) chip ============== */
    .delete-btn {
      position: absolute;
      top: -6px;                   /* sticks out a little */
      right: -6px;
      width: 24px;                 /* exact circle */
      height: 24px;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #ff4d4d;         /* red chip */
      color: #fff;                 /* white ‚ÄúX‚Äù */
      font-size: 18px;             /* icon size */
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.25);
      transition: background .15s ease;
      padding: 0;                  /* override global button padding */
    }
    .delete-btn:hover {
      background: #d73838;         /* darker on hover */
    }
    /* make the glyph a touch smaller and centred */
    .delete-btn .material-icons {
      font-size: 18px;             /* icon ‚âà 75 % of circle */
      line-height: 1;
    }
    #error-message {
      color: red;
      text-align: center;
      margin: 1rem 0;
    }
    .critical {
      color: red;
      font-weight: bold;
    }
/* ========= New table styling ========== */
table.changes-table {
  width: auto;
  margin: 1rem auto;    /* center horizontally */
  border-collapse: collapse;
  font-size: 0.9rem;
}
/* allow horizontal scroll on narrow viewports */
#results-content {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
table.changes-table th,
table.changes-table td {
  border: 1px solid #ddd;
  padding: 0.5rem;
  text-align: left;
}
table.changes-table th {
  background-color: #f0f0f0;
}
/* Prevent splitting rows across PDF pages */
.changes-table,
.changes-table thead,
.changes-table tbody,
.changes-table tr,
.changes-table th,
.changes-table td {
  page-break-inside: avoid !important;
}


    .progress-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0.5rem 0;
      margin-top: -40px;
      position: relative;
    }
    .progress-step {
      width: 30px;
      height: 30px;
      background-color: #cccccc;
      border: 1px solid #999;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      transition: all 0.3s ease;
    }
    .progress-step.filled {
      background-color: #66b0ff;
      border: 1px solid #0056b3;
      color: white;
    }
    .progress-step.current {
      background-color: #007bff;
      border: 3px solid #0056b3;
      color: white;
    }
    .progress-line-container {
      position: absolute;
      top: 50%;
      left: 15px;
      right: 15px;
      height: 2px;
      z-index: 0;
      display: flex;
      justify-content: space-between;
    }
    .progress-line {
      flex: 1;
      height: 2px;
      background-color: #cccccc;
      margin: 0 5px;
    }
    .progress-line.filled {
      background-color: #66b0ff;
    }
    #loading {
      display: none;
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 0.5rem;
      text-align: center;
      z-index: 2000;
    }
    #loading-text {
      margin-bottom: 0.25rem;
    }
    #loading-progress {
      width: 80%;
      max-width: 300px;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin: 0.5rem 0;
    }
    h3 {
      margin-top: 1rem;
    }
    p.disclaimer-text {
      text-align: justify;
      max-width: 500px;
      margin: 0 auto;
    }
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: pointer;
      color: #007bff;
      margin-left: 5px;
      font-size: 0.9rem;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #333;
      color: white;
      text-align: center;
      border-radius: 5px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltip-text,
    .tooltip.active .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    #medrec-logo {
      height: 180px;
      width: auto;
      display: block;
      margin: 0 auto;
      position: relative;
      top: -10px;
      z-index: 1001;
    }
    /* New styles for text input */
    .text-input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      width: 100%;
    }
    textarea {
      width: 100%;
      max-width: 300px;
      height: 100px;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      resize: none;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
    }
    textarea:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    }
    
    @media print {
  /* hide everything but the results screen */
  header, button, .photo-actions, .progress-bar, #loading,
  .screen:not(#results-screen) {
    display: none !important;
  }
  #results-screen { display: block !important; }

  /* allow the table to grow and show all columns */
  #results-content {
    overflow: visible !important;
    -webkit-overflow-scrolling: auto !important;
    width: auto !important;
    margin: 0 !important;
  }
  table.changes-table {
    width: 100% !important;
    border-collapse: collapse !important;
  }
  table.changes-table th,
  table.changes-table td {
    border: 1px solid #ddd !important;
    padding: 8px !important;
  }
}

main { /* Add padding to main element */
  padding-bottom: 4rem; /* Add space at bottom before footer */
}

footer {
  text-align: center;
  padding: 1rem;
  margin-top: auto; /* Helps push footer down */
  font-size: 0.8rem;
  color: #6c757d; /* Muted grey color */
  background-color: #f4f4f4; /* Match body background */
}

footer a {
  color: #0056b3; /* Link color */
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

  </style>

</head>
<body>
  <header>
    <img src="MedRec%20Logo.png" alt="MedRec 2.0 Logo" id="medrec-logo">
    <div class="progress-bar">
      <div class="progress-line-container">
        <div class="progress-line" id="line1-2"></div>
        <div class="progress-line" id="line2-3"></div>
        <div class="progress-line" id="line3-4"></div>
      </div>
      <div class="progress-step" id="step1">1</div>
      <div class="progress-step" id="step2">2</div>
      <div class="progress-step" id="step3">3</div>
      <div class="progress-step" id="step4">4</div>
    </div>
  </header>
  <main>
    <div id="error-message"></div>
    <!-- Disclaimer Screen -->
    <div id="disclaimer-screen" class="screen active">
      <h2>Disclaimer</h2>
      <div class="card">
        <p class="disclaimer-text">
          <strong>HIPAA Warning: DO NOT UPLOAD IMAGES CONTAINING IDENTIFIABLE INFORMATION.</strong> This app is intended for use by personnel authorized to handle Protected Health Information (PHI). While MedRec 2.0 is a HIPAA compliant application, users are responsible for ensuring full compliance with HIPAA regulations, including safeguarding resident/patient data and restricting access to authorized personnel only. Unauthorized disclosure of PHI may result in disciplinary action and legal consequences.
<br><br>
          <em>Note:</em> MedRec 2.0 is a support tool and does not guarantee 100% accuracy in identifying medication discrepancies. Final verification must be completed by qualified clinical personnel.
        </p>
      </div>
      <div class="disclaimer-actions">
        <button onclick="acknowledgeDisclaimer()">I Understand</button>
      </div>
    </div>
    <!-- Photo 1 Screen -->
    <div id="photo1-screen" class="screen">
      <div class="card">
        <h2>Enter Medications Before Hospital Stay</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo1-options" class="photo-actions">
          <button onclick="document.getElementById('photo1-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo1-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo1-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput1()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo1-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo1-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo1-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo1-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-upload" accept="image/*" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto1(this.files)">
      <input type="file" id="photo1-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto1(this.files)">
      <div id="photo1-preview" class="preview-container"></div>
      <p id="photo1-status"></p>
      <p id="photo1-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo1-next" onclick="goToPhoto2()" disabled>Next</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Photo 2 Screen -->
    <div id="photo2-screen" class="screen">
      <div class="card">
        <h2>Enter Hospital Discharge Medications</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo2-options" class="photo-actions">
          <button onclick="document.getElementById('photo2-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo2-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo2-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput2()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo2-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo2-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo2-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo2-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-upload" accept="image/*" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto2(this.files)">
      <input type="file" id="photo2-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto2(this.files)">
      <div id="photo2-preview" class="preview-container"></div>
      <p id="photo2-status"></p>
      <p id="photo2-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo2-compare" onclick="comparePhotos()" disabled>Compare</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Results Screen -->
    <div id="results-screen" class="screen">
      <h2>Comparison Results</h2>
      <p>Changes listed in <span class="critical">bold red</span> are critical medications and should be reconciled with the provider within <span class="critical">4 hours</span> of discovery.</p>
      <div class="card">
        <div id="results-content"></div>
      </div>
      <div class="photo-actions">
                    <button onclick="exportToPDF()">Export as PDF</button>
        <button onclick="printResults()">Print Results</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
  </main>
<footer>
  &copy; 2025 David Gottschalk. For technical support, please contact <a href="mailto:david@med-reconciliation.com">david@med-reconciliation.com</a>.
</footer>
  <div id="loading">
    <p id="loading-text">Processing...</p>
    <progress id="loading-progress" max="100"></progress>
  </div>
  <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-functions-compat.js"></script>
<script>
const firebaseConfig = {
  apiKey: "AIzaSyBYrJPALSB45rPm5D0T29rEwCdJ5Ek24ug",
  authDomain: "medrec-solutions-cd00e.firebaseapp.com",
  projectId: "medrec-solutions-cd00e",
  storageBucket: "medrec-solutions-cd00e.appspot.com",
  messagingSenderId: "276805089930",
  appId: "1:276805089930:web:9631c7d4cf223f1666d087"
};
const app = firebase.initializeApp(firebaseConfig);
const functions = firebase.functions(app);
</script>

  <script>
    const criticalMeds = [
      'warfarin', 'apixaban', 'rivaroxaban', 'dabigatran', 'edoxaban', 'heparin', 'enoxaparin',
      'clopidogrel', 'ticagrelor', 'prasugrel', 'insulin regular', 'insulin glargine', 'insulin detemir',
      'insulin lispro', 'insulin aspart', 'insulin degludec', 'glipizide', 'glyburide', 'glimepiride',
      'repaglinide', 'nateglinide', 'metformin', 'morphine', 'hydromorphone', 'oxycodone', 'fentanyl',
      'methadone', 'tramadol', 'codeine', 'buprenorphine', 'phenytoin', 'carbamazepine', 'valproic acid',
      'phenobarbital', 'lamotrigine', 'levetiracetam', 'digoxin', 'amiodarone', 'sotalol', 'diltiazem',
      'verapamil', 'metoprolol', 'atenolol', 'carvedilol', 'furosemide', 'bumetanide', 'torsemide',
      'spironolactone', 'hydrochlorothiazide', 'chlorthalidone', 'potassium chloride', 'magnesium sulfate',
      'calcium gluconate', 'calcium chloride', 'sodium bicarbonate', 'phosphate', 'hydralazine', 'clonidine',
      'isosorbide mononitrate', 'isosorbide dinitrate', 'nitroglycerin', 'haloperidol', 'risperidone',
      'olanzapine', 'quetiapine', 'aripiprazole', 'ziprasidone', 'lorazepam', 'diazepam', 'clonazepam',
      'temazepam', 'midazolam', 'zolpidem', 'prednisone', 'methylprednisolone', 'dexamethasone',
      'hydrocortisone', 'levothyroxine', 'liothyronine', 'tacrolimus', 'cyclosporine', 'mycophenolate',
      'azathioprine', 'vancomycin', 'gentamicin', 'tobramycin', 'amikacin', 'ciprofloxacin', 'levofloxacin',
      'moxifloxacin', 'azithromycin', 'clarithromycin', 'erythromycin', 'amoxicillin',
      'amoxicillin-clavulanate', 'ceftriaxone', 'cefepime', 'ceftazidime', 'cefdinir', 'cephalexin',
      'piperacillin-tazobactam', 'penicillin vk', 'dicloxacillin', 'nafcillin', 'meropenem', 'ertapenem',
      'imipenem-cilastatin', 'doxycycline', 'minocycline', 'tetracycline', 'linezolid',
      'sulfamethoxazole-trimethoprim', 'nitrofurantoin', 'metronidazole', 'clindamycin', 'fosfomycin',
      'daptomycin', 'tigecycline', 'carbidopa/levodopa', 'entacapone', 'selegiline', 'rasagiline', 'lithium',
      'theophylline', 'clozapine', 'methotrexate', 'allopurinol', 'colchicine', 'tamsulosin', 'finasteride',
      'denosumab', 'zoledronic acid', 'teriparatide', 'alendronate', 'risedronate', 'acetazolamide',
      'bethanechol', 'bethanechol chloride', 'donepezil', 'rivastigmine', 'galantamine', 'memantine',
      'naltrexone', 'naloxone', 'flumazenil', 'desmopressin', 'octreotide', 'erythropoietin', 'filgrastim',
      'calcitriol', 'ergocalciferol', 'cholecalciferol', 'pyridostigmine', 'propranolol', 'labetalol',
      'isosorbide', 'nicardipine', 'nitroprusside', 'ivabradine', 'sacubitril', 'valsartan',
      'atorvastatin', 'rosuvastatin', 'simvastatin', 'Norco', 'oxycodone/acetaminophen', 'hydrocodone/acetaminophen', 'codeine/acetaminophen', 'tramadol/acetaminophen', 'acetaminophen/caffeine/dihydrocodeine', 'aspirin/caffeine/dihydrocodeine', 'aspirin/codeine', 'ibuprofen/oxycodone', 'acetaminophen/butalbital/caffeine', 'aspirin/butalbital/caffeine', 'acetaminophen/butalbital', 'methylphenidate', 'amphetamine/dextroamphetamine', 'hydrocodone/pseudoephedrine', 'hydrocodone/chlorpheniramine', 'hydrocodone/homatropine', 'busulfan', 'doxorubicin', 'adalimumab', 'acetaminophen/isometheptene/dichloralphenazone', 'ultracet', 'percocet', 'roxicet', 'endocet', 'tylenol #3', 'zamicet', 'vicodin', 'lortab', 'panlor ss', 'trezix', 'synalgos-dc', 'empirin with codeine', 'combunox', 'fioricet', 'esgic', 'zebutal', 'fiorinal', 'bupap', 'rezira', 'tussionex', 'hycomine', 'hydromet', 'midrin','chlorpropamide', 'acarbose', 'miglitol', 'argatroban', 'bivalirudin', 'fondaparinux', 'methylergonovine', 'carboplatin', 'cyclophosphamide', 'promethazine'

    ].map(med => med.toLowerCase());

    const commonMedications = [
      { generic: "hydrocodone/acetaminophen", brands: ["Norco", "Vicodin", "Lortab", "Zamicet"] },
      { generic: "oxycodone/acetaminophen",  brands: ["Percocet", "Xartemis XR", "Roxicet", "Endocet"] },
               { generic: "codeine/acetaminophen",     brands: ["Tylenol #3"] },
               { generic: "tramadol/acetaminophen",    brands: ["Ultracet"] },
               { generic: "acetaminophen/caffeine/dihydrocodeine", brands: ["Panlor SS", "Trezix"] },
               { generic: "aspirin/caffeine/dihydrocodeine",       brands: ["Synalgos-DC"] },
               { generic: "aspirin/codeine",            brands: ["Empirin with codeine"] },
               { generic: "acetaminophen/butalbital/caffeine", brands: ["Fioricet", "Esgic", "Zebutal"] },
               { generic: "aspirin/butalbital/caffeine", brands: ["Fiorinal"] },
               { generic: "acetaminophen/butalbital",   brands: ["Bupap"] },
               { generic: "hydrocodone/pseudoephedrine", brands: ["Rezira"] },
               { generic: "hydrocodone/chlorpheniramine", brands: ["Tussionex", "Hycomine"] },
               { generic: "hydrocodone/homatropine",    brands: ["Hydromet"] },
               { generic: "busulfan",                   brands: ["Myleran"] },
               { generic: "acetaminophen/isometheptene/dichloralphenazone", brands: ["Midrin"] },
               { generic: "ibuprofen/oxycodone",        brands: ["Combunox"] },
      { generic: "acetaminophen", brands: ["Tylenol"] },
      { generic: "albuterol", brands: ["Ventolin", "ProAir", "Proventil", "salbutamol"] },
      { generic: "allopurinol", brands: ["Zyloprim"] },
      { generic: "alprazolam", brands: ["Xanax"] },
      { generic: "amlodipine", brands: ["Norvasc"] },
      { generic: "amoxicillin", brands: ["Amoxil", "Trimox"] },
      { generic: "aspirin", brands: ["Bayer", "Ecotrin"] },
      { generic: "atenolol", brands: ["Tenormin"] },
      { generic: "atorvastatin", brands: ["Lipitor"] },
      { generic: "azithromycin", brands: ["Zithromax", "Z-Pak"] },
      { generic: "bisoprolol", brands: ["Zebeta"] },
      { generic: "budesonide", brands: ["Pulmicort", "Rhinocort"] },
               {   generic: "calcium gluconate",  brands: [] },
               {   generic: "calcium chloride",   brands: [] },
               {   generic: "calcium carbonate",  brands: [] },
               {   generic: "calcium citrate",    brands: [] }, 
      { generic: "cefuroxime", brands: ["Ceftin", "Zinacef"] },
      { generic: "cephalexin", brands: ["Keflex"] },
      { generic: "cetirizine", brands: ["Zyrtec"] },
      { generic: "ciprofloxacin", brands: ["Cipro"] },
      { generic: "citalopram", brands: ["Celexa"] },
      { generic: "clindamycin", brands: ["Cleocin"] },
      { generic: "clonazepam", brands: ["Klonopin"] },
      { generic: "clopidogrel", brands: ["Plavix"] },
      { generic: "cyclobenzaprine", brands: ["Flexeril"] },
      { generic: "digoxin", brands: ["Lanoxin"] },
      { generic: "doxycycline", brands: ["Vibramycin"] },
      { generic: "duloxetine", brands: ["Cymbalta"] },
      { generic: "enalapril", brands: ["Vasotec"] },
      { generic: "escitalopram", brands: ["Lexapro"] },
      { generic: "esomeprazole", brands: ["Nexium"] },
      { generic: "ferrous sulfate", brands: [] },
      { generic: "fluoxetine", brands: ["Prozac"] },
      { generic: "fluticasone", brands: ["Flonase", "Flovent"] },
      { generic: "furosemide", brands: ["Lasix"] },
      { generic: "gabapentin", brands: ["Neurontin"] },
      { generic: "glipizide", brands: ["Glucotrol"] },
      { generic: "glyburide", brands: ["Diabeta", "Micronase"] },
      { generic: "hydralazine", brands: ["Apresoline"] },
      { generic: "hydrochlorothiazide", brands: ["Microzide"] },
      { generic: "ibuprofen", brands: ["Advil", "Motrin"] },
      { generic: "insulin glargine", brands: ["Lantus", "Basaglar"] },
      { generic: "insulin lispro", brands: ["Humalog"] },
      { generic: "irbesartan", brands: ["Avapro"] },
      { generic: "isosorbide mononitrate", brands: ["Imdur"] },
      { generic: "ketorolac", brands: ["Toradol"] },
      { generic: "levothyroxine", brands: ["Synthroid", "Levoxyl"] },
      { generic: "lisinopril", brands: ["Prinivil", "Zestril"] },
      { generic: "lorazepam", brands: ["Ativan"] },
      { generic: "losartan", brands: ["Cozaar"] },
      { generic: "melatonin", brands: [] },
      { generic: "meloxicam", brands: ["Mobic"] },
      { generic: "metformin", brands: ["Glucophage"] },
      { generic: "methotrexate", brands: ["Trexall"] },
      { generic: "metoprolol", brands: ["Lopressor", "Toprol XL"] },
      { generic: "montelukast", brands: ["Singulair"] },
      { generic: "naproxen", brands: ["Aleve", "Naprosyn"] },
      { generic: "nifedipine", brands: ["Procardia", "Adalat"] },
      { generic: "nystatin", brands: ["Mycostatin"] },
      { generic: "omeprazole", brands: ["Prilosec"] },
      { generic: "oxycodone", brands: ["OxyContin", "Roxicodone"] },
      { generic: "pantoprazole", brands: ["Protonix"] },
               {   generic:    "polyethylene glycol",  brands: ["MiraLAX","GaviLAX","GlycoLax","PEG 3350"] },
      { generic: "pravastatin", brands: ["Pravachol"] },
      { generic: "prednisone", brands: ["Deltasone"] },
      { generic: "propranolol", brands: ["Inderal"] },
      { generic: "quinapril", brands: ["Accupril"] },
      { generic: "ranitidine", brands: ["Zantac"] },
      { generic: "rosuvastatin", brands: ["Crestor"] },
      { generic: "sertraline", brands: ["Zoloft"] },
      { generic: "simvastatin", brands: ["Zocor"] },
      { generic: "sitagliptin", brands: ["Januvia"] },
      { generic: "sotalol", brands: ["Betapace"] },
      { generic: "spironolactone", brands: ["Aldactone"] },
      { generic: "sulfamethoxazole-trimethoprim", brands: ["Bactrim", "Septra"] },
      { generic: "tamsulosin", brands: ["Flomax"] },
      { generic: "tramadol", brands: ["Ultram"] },
      { generic: "trazodone", brands: ["Desyrel"] },
      { generic: "valacyclovir", brands: ["Valtrex"] },
      { generic: "valproic acid", brands: ["Depakene"] },
      { generic: "venlafaxine", brands: ["Effexor"] },
      { generic: "verapamil", brands: ["Calan", "Verelan"] },
      { generic: "warfarin", brands: ["Coumadin"] },
      { generic: "zolpidem", brands: ["Ambien"] },
      { generic: "amphetamine/dextroamphetamine", brands: ["Adderall", "Adderall XR"] },
      { generic: "alendronate", brands: ["Fosamax"] },
      { generic: "tadalafil", brands: ["Cialis"] },
      { generic: "fluticasone/umeclidinium/vilanterol", brands: ["Trelegy"] },
      { generic: "empagliflozin", brands: ["Jardiance"] },
      { generic: "semaglutide", brands: ["Ozempic", "Wegovy"] },
      { generic: "vitamin d", brands: ["Drisdol"] },
      { generic: "prednisolone", brands: ["Pred Forte"] },
      { generic: "enoxaparin", brands: ["Lovenox", "Clexane"] },
      { generic: "doxorubicin", brands: ["Adriamycin"] },
      { generic: "adalimumab", brands: ["Humira"] },
      { generic: "rivaroxaban", brands: ["Xarelto"] },
      { generic: "methylphenidate", brands: ["Ritalin", "Concerta"] },
      { generic: "memantine", brands: ["Namenda"] },
      { generic: "isosorbide", brands: [] },
      { generic: "isosorbide dinitrate", brands: [] }
    ];
	// ‚Äî‚Äî‚Äî Map every brand name to its generic ‚Äî‚Äî‚Äî
    const brandToGenericMap = {};
    commonMedications.forEach(({ generic, brands }) => {
      brands.forEach(brand => {
        brandToGenericMap[brand.toLowerCase()] = generic.toLowerCase();
      });
    });

    // ‚Äî‚Äî‚Äî Map every generic to its brands ‚Äî‚Äî‚Äî
    const genericToBrandMap = {};
    Object.entries(brandToGenericMap).forEach(([brand, generic]) => {
      if (!genericToBrandMap[generic]) genericToBrandMap[generic] = [];
      genericToBrandMap[generic].push(brand);
    });

  function normalizeMedicationName(name) {
   if (!name) return '';
   let n = name.toLowerCase().trim();
   if (brandToGenericMap[n]) {
     n = brandToGenericMap[n];
   }
   // drop anything not letter/number/space
   n = n.replace(/[^a-z0-9 ]+/g, '');
   // collapse multiple spaces
   return n.replace(/\s+/g, ' ');
 }

    const unitVariants = {
  tablet:   ['tab','tabs','tablet','tablets','tab.','tablet.'],
  capsule:  ['cap','caps','capsule','capsules','caplet','cap.','gelcap','softgel','gel','sprinkle','sprinkles'],
  spray:    ['spray','sprays'],
  puff:     ['puff','puffs'],
  drop:     ['drop','drops','gtt','gtts','gt','drp'],
  patch:    ['patch','patches','transdermal patch'],
  injection:['shot','syringe','pen','inj','auto-injector'],
  lozenge:  ['lozenge','loz','troche'],
  suppository:['supp','suppositories'],
  solution: ['solution','sol','liq','liquid','oral sol'],
  ointment: ['ointment','oint','ung','cream','gel'],
  inhalation:['inhaler','inh','neb','nebulizer','mdi','dpi'],
  unit:     ['U','IU','units'],
  mL:       ['ml','mL','cc'],
  mcg:      ['Œºg','mcg','ug'],
  mg:       ['mg'],
  mEq:      ['meq', 'mEq', 'milliequivalents'],
  g:        ['g','gram','grams']
};


    let photo1Files = [];
    let photo2Files = [];
    let meds1 = [], meds2 = [];
    let hasTextInput1 = false; // Track if Photo 1 used text input
    let hasTextInput2 = false; // Track if Photo 2 used text input

    async function processFiles(files) {
      let allText = "";
      let lowConfidence = false;
      for (let file of files) {
        try {
          const result = await processFile(file);
//=== STEP 2  cleaned with keepOrderLines
const cleaned = keepOrderLines(result.text);
allText += "\n" + cleaned.join("\n");
//=== END STEP 2

          if (result.confidence < 0.8) {
            lowConfidence = true;
          }
        } catch (err) {
          console.error("Error processing file: ", err);
        }
      }
      if (lowConfidence) {
        showError("Warning: Some text was unclear and may not be accurate. Please review manually.");
      }
      return allText;
    }

function processFile(file) {
  return new Promise((resolve, reject) => {
    if (!file) {
      console.error('No file provided to processFile');
      reject(new Error("No file provided"));
      return;
    }
    console.log('Processing file:', file.name, file.type, file.size);
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        if (!e.target.result) {
          console.error('FileReader result is undefined');
          throw new Error('FileReader result is undefined');
        }
        const imageData = e.target.result;
        console.log('Sending image data:', imageData.substring(0, 100));
        const payload = { data: { image: imageData } };
        console.log('Payload being sent:', payload);
        const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
        const response = await callOcrFunction(payload);
        console.log('Received response from callOcrTest:', response);
        if (!response.data || typeof response.data !== 'object') {
          throw new Error('Invalid response from OCR function');
        }
        resolve(response.data);
      } catch (err) {
        console.error('Error in processFile:', err);
        reject(err);
      }
    };
    reader.onerror = () => {
      console.error('FileReader error:', reader.error);
      reject(new Error("File could not be read: " + reader.error));
    };
    reader.readAsDataURL(file);
  });
}
async function testCallOcr() {
  try {
    const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
    const payload = { data: { test: "Hello, world!" } };
    console.log('Testing callOcrTest with payload:', payload);
    const response = await callOcrFunction(payload);
    console.log('Test response from callOcrTest:', response);
  } catch (err) {
    console.error('Error in testCallOcr:', err);
  }
}
    /**
     * If a single line actually contains two orders (two doses),
     * split it into two.
     */
    function splitConcatOrders(line) {
      // look for two dose patterns in one line
      const doseRegex = /\d+\s*(?:mg|mcg|g|mL|tablet|capsule|puff|drop|unit|IU)\b/gi;
      const matches = [...line.matchAll(doseRegex)];
      if (matches.length > 1) {
        const splitAt = matches[1].index;
        return [
          line.slice(0, splitAt).trim(),
          line.slice(splitAt).trim()
        ];
      }
      return [ line ];
    }

    /**
     * If a ‚Äúcontinuation‚Äù line didn‚Äôt itself name a drug,
     * glue it back onto the previous order.
     */
    function mergeMultiLineOrders(lines) {
      const merged = [];
      lines.forEach(l => {
        if (/^[a-z]/i.test(l) && /\d/.test(l)) {
          // starts like an order ‚Üí new entry
          merged.push(l);
        } else if (merged.length) {
          // continuation ‚Üí append
          merged[merged.length - 1] += ' ' + l;
        } else {
          // no previous ‚Üí keep alone
          merged.push(l);
        }
      });
      return merged;
    }

    /**
     * Merge ‚ÄúDay 1‚Ä¶‚Äù, ‚ÄúDay 2‚Ä¶‚Äù lines (taper packs) back onto
     * the preceding order line.
     */
    function mergeTaperPackOrders(lines) {
      const out = [];
      lines.forEach(l => {
        if (/^day\s*\d+/i.test(l) && out.length) {
          out[out.length - 1] += ' ' + l;
        } else {
          out.push(l);
        }
      });
      return out;
    }

    // ‚Üê‚îÄ‚îÄ END INSERT ‚îÄ‚îÄ‚ñ∂

//=== STEP 1  keepOrderLines helper =========================
function keepOrderLines(rawText) {
  const DEBUG_JUNK = false;   // flip to true to see what you drop

//=== STEP‚ÄëSPLITMULTI  ‚¨áÔ∏é break ‚ÄúA ‚Ä¶ B ‚Ä¶‚Äù lines into two =================
rawText = rawText
  .replace(/\s{2,}/g, '\n')               // two+ spaces  ‚Üí new line
  .replace(/(?:,|;|\band\b)/gi, '\n');    // commas/‚Äúand‚Äù ‚Üí new line
//=== END STEP‚ÄëSPLITMULTI =================================================

  return rawText
    .split(/\r?\n+/)                 // ‚Üí separate lines
    .map(line => cleanLine(line))    // ‚Üí trim weird endings
  .flatMap(splitConcatOrders)      // ‚Üí split ‚Äúlisinopril ‚Ä¶ polyethylene ‚Ä¶‚Äù
    .filter(line => {
      const keep =
        isLikelyOrderLine(line) &&   // letters + numbers?
       ( containsKnownMedication(line) ||    // ‚Üñ try drug list first
         /\d+\s*(mg|mcg|g|mL|units|tablet|capsule|puff|drop)\b/i.test(line) )
        && /\d/.test(line);          // must still have a digit
      if (!keep && DEBUG_JUNK) console.log('üóëÔ∏è', line);
      return keep;
    });
}
//=== END STEP 1 ============================================

    function cleanLine(line) {
  	// 1) drop any ‚Äúnumber.‚Äù or ‚Äúnumber)‚Äù at the start
  	line = line.replace(/^\s*\d+[\.\)]\s*/, '');
  	// 2) remove trailing non-alphanumeric junk and trim
  	return line.replace(/[^a-z0-9]+$/i, '').trim();
}


// ‚Äî‚Äî‚Äî remove trailing junk from merged lines ‚Äî‚Äî‚Äî
function pruneLine(line) {
  // keep dose ‚Üí form ‚Üí route ‚Üí freq ‚Üí PRN ‚Üí ‚Äúfor ‚Ä¶ pain‚Äù or ‚Äúmoderate pain‚Äù
  // only strip off trailing garbage like ‚Äú;‚Äù or OCR noise, but preserve any
  // remaining words (e.g. ‚Äúfor hypertension‚Äù or ‚Äúheart failure‚Äù)
  return line.trim();
 }

    function isLikelyOrderLine(line) {
      //=== STEP 3  stricter test
if (line.length < 5) return false;
const good = (line.match(/[a-z0-9]/gi) || []).length;
return good / line.length >= 0.5;
//=== END STEP 3
    }

function containsKnownMedication(line) {
  const lower = line.toLowerCase();

  // 1) Critical meds always match
  if (criticalMeds.some(med => lower.includes(med))) return true;

  // 2) Any brand name in commonMedications also counts
  if (commonMedications.some(m =>
        m.brands.some(b => lower.includes(b.toLowerCase()))
      )) return true;

  // 3) Generic names or dose patterns as before
  return commonMedications.some(med => lower.includes(med.generic))
      || /\d+\s*(?:mg|mcg|units|puffs|tabs?|tablets?|capsules?)\b/.test(lower);
}

    // ‚Äî‚Äî‚Äî Text normalizer ‚Äî no more stat inside statin ‚Äî‚Äî‚Äî
function normalizeText(str) {
  let text = (str || '').toLowerCase()

    // your existing expansions‚Ä¶
    .replace(/\bnow\b/g, 'immediately')
    // only match "stat" when it's not embedded in another word
    .replace(/(?<![a-z])stat(?![a-z])/g, 'immediately')
    .replace(/\bqhs\b/g, 'at bedtime')
    // ‚Ä¶all the rest of your shorthand/frequency ‚Üí full-text rules‚Ä¶

  // final cleanup:
  return text
    .replace(/\s+/g, ' ')
    .trim();
}

// ‚Äî‚Äî‚Äî Text normalizer ‚Äî no more stat inside statin ‚Äî‚Äî‚Äî
function normalizeText(str) {
  let text = (str || '').toLowerCase()

    // your existing expansions‚Ä¶
    .replace(/\bnow\b/g, 'immediately')
    // only match "stat" when it's not embedded in another word
    .replace(/(?<![a-z])stat(?![a-z])/g, 'immediately')
    .replace(/\bqhs\b/g, 'at bedtime')
    // ‚Ä¶all the rest of your shorthand/frequency ‚Üí full-text rules‚Ä¶

  // final cleanup:
  return text
    .replace(/\s+/g, ' ')
    .trim();
}

// ‚Äî‚Äî‚Äî What changed? ‚Äî‚Äî‚Äî
function getChangeReason(orig, updated) {
  console.log('DEBUG getChangeReason: orig.drug=', orig.drug, 'updated.drug=', updated.drug);
  console.log('DEBUG getChangeReason: orig Parsed=', JSON.stringify(orig));
  console.log('DEBUG getChangeReason: updated Parsed=', JSON.stringify(updated));

  if (!orig || !updated) return 'Misc. Change';

  // 1) Taper packs (day N) always multi
  if (/\bday\s*\d+\b/i.test(orig.drug) || /\bday\s*\d+\b/i.test(updated.drug)) {
    return 'Multiple changes';
  }

  const norm = s => (s || '').toLowerCase().trim().replace(/\s+/g, ' ');
  const canon = f => {
    f = norm(f);
    return (f === '' || f === 'daily' || f === 'q24h') ? 'daily' : f;
  };

  // --- Start Debugging Conditions for Indication-Only Check ---
  const drugNameMatch = normalizeMedicationName(orig.drug) === normalizeMedicationName(updated.drug);
  const doseValueMatch = orig.dose?.value === updated.dose?.value;
  const doseUnitMatch = orig.dose?.unit === updated.dose?.unit;
  const frequencyMatch = canon(orig.frequency) === canon(updated.frequency);
  const timeOfDayMatch = norm(orig.timeOfDay) === norm(updated.timeOfDay); // << THE KEY ONE
  const formMatch = norm(orig.form) === norm(updated.form);
  const routeMatch = norm(orig.route) === norm(updated.route);
  const prnMatch = orig.prn === updated.prn;
  const indicationDiff = norm(orig.indication) !== norm(updated.indication);

  console.log('DEBUG Indication-Only Check Conditions:');
  console.log('  drugNameMatch:', drugNameMatch, `(${normalizeMedicationName(orig.drug)} vs ${normalizeMedicationName(updated.drug)})`);
  console.log('  doseValueMatch:', doseValueMatch, `(${orig.dose?.value} vs ${updated.dose?.value})`);
  console.log('  doseUnitMatch:', doseUnitMatch, `(${orig.dose?.unit} vs ${updated.dose?.unit})`);
  console.log('  frequencyMatch:', frequencyMatch, `(${canon(orig.frequency)} vs ${canon(updated.frequency)})`);
  console.log('  timeOfDayMatch:', timeOfDayMatch, `(orig: "<span class="math-inline">\{orig\.timeOfDay\}" \-\> norm\: "</span>{norm(orig.timeOfDay)}" vs upd: "<span class="math-inline">\{updated\.timeOfDay\}" \-\> norm\: "</span>{norm(updated.timeOfDay)}")`);
  console.log('  formMatch:', formMatch, `(${norm(orig.form)} vs ${norm(updated.form)})`);
  console.log('  routeMatch:', routeMatch, `(${norm(orig.route)} vs ${norm(updated.route)})`);
  console.log('  prnMatch:', prnMatch, `(${orig.prn} vs ${updated.prn})`);
  console.log('  indicationDiff:', indicationDiff, `(${norm(orig.indication)} vs ${norm(updated.indication)})`);
  // --- End Debugging Conditions ---

  // 2) **Indication-only**
  if (
    drugNameMatch &&
    doseValueMatch &&
    doseUnitMatch &&
    frequencyMatch &&
    timeOfDayMatch && // Uses the debugged variable
    formMatch &&
    routeMatch &&
    prnMatch &&
    indicationDiff
  ) {
    console.log('DEBUG: Matched Indication-only block.');
    return 'Indication changed';
  }
  console.log('DEBUG: Did NOT match Indication-only block.');

  // 3) Time-of-day-only (This is less likely the issue but good to be aware of)
  if (
    !timeOfDayMatch && // norm(orig.timeOfDay) !== norm(updated.timeOfDay)
    drugNameMatch && // Ensure it's the same drug for a pure ToD change
    doseValueMatch &&
    doseUnitMatch &&
    frequencyMatch && // Freq should be same if only ToD changed
    formMatch &&
    routeMatch &&
    prnMatch &&
    norm(orig.indication) === norm(updated.indication) // Indication MUST be same
  ) {
    console.log('DEBUG: Matched Time of day changed (exclusive).');
    return 'Time of day changed';
  }


  let changes = [];
  const add = lbl => { if (!changes.includes(lbl)) changes.push(lbl); };

  // 4) Brand ‚Üî Generic
  {
    const a = normalizeMedicationName(orig.drug);
    const b = normalizeMedicationName(updated.drug);
    if (a === b) {
      const isA = brandToGenericMap[norm(orig.drug)];
      const isB = brandToGenericMap[norm(updated.drug)];
      if (Boolean(isA) !== Boolean(isB)) add('Brand/Generic changed');
    }
  }
  // 5) Dose
  const inhaled = o => /inhal|puff|neb|mdi|dpi/.test(norm(o.form)) || /inhal/.test(norm(o.route));
  // Ensure dose values are numbers before comparison if they might be null/undefined
  const origDoseVal = typeof orig.dose?.value === 'number' ? orig.dose.value : -Infinity; // Use a value that won't match if null
  const updatedDoseVal = typeof updated.dose?.value === 'number' ? updated.dose.value : -Infinity;

  if (origDoseVal !== updatedDoseVal || orig.dose?.unit !== updated.dose?.unit) {
     if (!(inhaled(orig) && inhaled(updated))) { // Assuming dose changes for inhaled meds are handled differently or less strictly
        add('Dose changed');
     }
  }

  // 6) Frequency
  if (canon(orig.frequency) !== canon(updated.frequency)) {
    // Avoid flagging "daily" vs "" as a frequency change if timeOfDay is used to imply daily
    if (!( (canon(orig.frequency)==='daily' && updated.frequency === '') ||
           (orig.frequency === '' && canon(updated.frequency)==='daily') )) {
        add('Frequency changed');
    }
  }
  // 7) Time-of-day (second pass) - only add if not already covered by exclusive ToD change
  if (!timeOfDayMatch) { // norm(orig.timeOfDay) !== norm(updated.timeOfDay)
    add('Time of day changed');
  }
  // 8) Form / Route
  if (norm(orig.form) !== norm(updated.form)) {
    add('Form changed');
  }
  if (
    (orig.route && updated.route && norm(orig.route) !== norm(updated.route)) ||
    (!orig.route && updated.route) || (orig.route && !updated.route) || // Handle one being null/empty
    (/inhal/.test(norm(orig.route || '')) !== /inhal/.test(norm(updated.route || '')))
  ) {
    add('Route changed');
  }
  // 9) PRN
  if (orig.prn !== updated.prn) {
    add('PRN changed');
  }
  // 10) Indication (catch ANY remaining indication diff)
  if (indicationDiff) { // norm(orig.indication) !== norm(updated.indication)
    add('Indication changed');
  }

  // collapse trivial TOD/freq double-hit
  if (changes.includes('Frequency changed') && changes.includes('Time of day changed') &&
    canon(orig.frequency) === 'daily' && canon(updated.frequency) === 'daily') {
    changes = changes.filter(c => c !== 'Frequency changed');
  }
  // collapse inhaler form/route double-hit
  if (changes.includes('Form changed') && changes.includes('Route changed') && inhaled(orig) && inhaled(updated)) { // check if both are inhaled
    changes = changes.filter(c => c !== 'Route changed'); // or form, depending on preference
  }

// --- New Rule for Stat/Immediately vs. Timed Dosing ---
const origFreqIsImmediately = norm(orig.frequency) === 'immediately';
const updatedFreqIsDaily = canon(updated.frequency) === 'daily';
const origTODIsEmpty = norm(orig.timeOfDay) === '';
const updatedTODIsSet = norm(updated.timeOfDay) !== '';

if (changes.includes('Frequency changed') && changes.includes('Time of day changed') &&
    origFreqIsImmediately && updatedFreqIsDaily && origTODIsEmpty && updatedTODIsSet) {
  changes = changes.filter(c => c !== 'Time of day changed');
  if (norm(orig.indication) === 'immediately' && norm(updated.indication) === '') {
    changes = changes.filter(c => c !== 'Indication changed');
  }
}
// --- End of New Rule ---

  console.log('DEBUG: changes array before final fallback:', JSON.stringify(changes));

  // Fallback "only indication changed" check (this is the redundant block)
  // Ensure this doesn't incorrectly override if multiple changes were genuinely detected
  if (changes.length > 1 || changes.length === 0) { // Only try this if the array logic didn't find a single specific change (excluding indication itself if it was the only one)
      if (
        drugNameMatch &&
        doseValueMatch &&
        doseUnitMatch &&
        frequencyMatch &&
        timeOfDayMatch &&
        formMatch &&
        routeMatch &&
        prnMatch &&
        indicationDiff // Crucially, indication MUST be different for this to make sense
      ) {
        console.log('DEBUG: Matched Fallback Indication-only block.');
        return 'Indication changed';
      } else if ( // All same AND indication is same (truly unchanged)
        drugNameMatch &&
        doseValueMatch &&
        doseUnitMatch &&
        frequencyMatch &&
        timeOfDayMatch &&
        formMatch &&
        routeMatch &&
        prnMatch &&
        !indicationDiff // Indication is also the same
      ) {
         console.log('DEBUG: Fallback found no changes (Misc. Change or Unchanged).');
         return 'Misc. Change'; // Or 'Unchanged' if you prefer that label
      }
  }
  console.log('DEBUG: Final changes array:', JSON.stringify(changes));

  if (changes.length === 0) return 'Misc. Change'; // Or 'Unchanged'
  if (changes.length === 1) return changes[0];
  return 'Multiple changes';
}

    function parseOrder(orderStr) {
  // Keep a copy of the original input for debugging if needed at the very end
  // const originalInputToParseOrder = orderStr;

  orderStr = orderStr.replace(/[\u2010\u2011\u2012\u2013\u2014\u2015\u2212]/g, '-');
  orderStr = normalizeText(orderStr); // Normalizes "qhs" to "at bedtime", etc.

  let order = {
    drug: "",
    dose: { value: null, unit: '', total: null },
    route: "",
    frequency: "",
    timeOfDay: "",
    administration: "",
    prn: false,
    form: "",
    indication: ""
  };

  // 1. Extract Time-of-Day and common morning/evening/night shorthands
//    Also sets frequency if implied by the shorthand (e.g., qam is daily)
const timeOfDayMappings = [
  { regex: /\bdaily\s+in\s+(the\s+)?morning\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bqam\b/i, timeOfDay: 'morning', frequency: 'daily', originalTerm: 'qam' },
  { regex: /\b(in\s+the\s+)?morning\b/i, timeOfDay: 'morning', originalTermRegexPos: 0 },
  { regex: /\bevery\s+morning\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },

  { regex: /\bqpm\b/i, timeOfDay: 'evening', frequency: 'daily', originalTerm: 'qpm' },
  { regex: /\b(in\s+the\s+)?evening\b/i, timeOfDay: 'evening', originalTermRegexPos: 0 },
  { regex: /\bevery\s+evening\b/i, timeOfDay: 'evening', frequency: 'daily', originalTermRegexPos: 0 },

  { regex: /\bqhs\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTerm: 'qhs' }, // normalizeText also does qhs->at bedtime
  { regex: /\b(at\s+)?bedtime\b/i, timeOfDay: 'bedtime', originalTermRegexPos: 0 },
  { regex: /\bnight\b/i, timeOfDay: 'bedtime', originalTermRegexPos: 0 }, // Assuming 'night' implies bedtime for dosing
  { regex: /\bevery\s+night\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTermRegexPos: 0 }
];

let todProcessed = false;
for (const mapping of timeOfDayMappings) {
  const match = orderStr.match(mapping.regex);
  if (match) {
    order.timeOfDay = mapping.timeOfDay;
    
// Determine the exact string that was matched to replace it accurately
    orderStr = orderStr.replace(match[0], '').trim(); // Replace the entire matched part

    if (mapping.frequency && !order.frequency) { // Only set frequency if not already set by a more specific term
      order.frequency = mapping.frequency;
    }
    todProcessed = true;
    // console.log(`DEBUG parseOrder Step 1 (TimeShorthand): tod="<span class="math-inline">\{order\.timeOfDay\}", freq\="</span>{order.frequency}", orderStr="${orderStr}"`);
    break; // Processed one, move on
  }
}

// If a time of day was found (e.g. "morning") but frequency wasn't set by a specific shorthand (like qam, every morning)
// then assume it's a daily frequency.
if (order.timeOfDay && !order.frequency) {
    order.frequency = 'daily';
    // console.log(`DEBUG parseOrder Step 1 (Implied Daily Freq): tod="<span class="math-inline">\{order\.timeOfDay\}", freq\="</span>{order.frequency}"`);
}

  // 2. Extract Administration (with/without food/water)
  const adminMatch = orderStr.match(/\b(?:with|w\/)\s*(meals|water|juice|liquid)\b|\b(?:without|w\/o)\s*(meals|water|juice|liquid)\b/i);
  if (adminMatch) {
    const prefix = adminMatch[0].toLowerCase().startsWith('with') ? 'with ' : 'without ';
    const noun = (adminMatch[1] || adminMatch[2] || '').toLowerCase();
    order.administration = prefix + noun;
    orderStr = orderStr.replace(adminMatch[0], '').trim();
    // console.log(`DEBUG parseOrder Step 2 (Admin): order.administration="${order.administration}", orderStr="${orderStr}"`);
  }

  // 3. Extract PRN
  const prnRegex = /\bprn\b/i;
  if (prnRegex.test(orderStr)) {
    order.prn = true;
    orderStr = orderStr.replace(prnRegex, '').trim();
    // console.log(`DEBUG parseOrder Step 3 (PRN): order.prn=${order.prn}, orderStr="${orderStr}"`);
  }

  // 4. Extract Indications - This is a critical section
  // Attempt to find "for [text]" first, as it's a strong indication marker.
  // Example: "for moderate pain", "for blood pressure"
  const forIndicationRegex = /\bfor\s+([a-zA-Z0-9\s\/.-]+)/i;
  let forIndicationMatchResult = orderStr.match(forIndicationRegex);
  if (forIndicationMatchResult && forIndicationMatchResult[1]) {
    const potentialIndication = forIndicationMatchResult[1].trim().toLowerCase();
    order.indication = potentialIndication;
    orderStr = orderStr.replace(forIndicationMatchResult[0], '').trim(); // Remove "for [indication]"
    // console.log(`DEBUG parseOrder Step 4a (For Indication): order.indication="${order.indication}", orderStr="${orderStr}"`);
  }

  // If no "for" indication, check for specific keywords like "pain", "shortness of breath"
  // This needs to be careful not to grab parts of drug names.
  if (!order.indication) {
    // Matches phrases like "moderate pain", "acute pain", or just "pain" if it's clearly an indication
    const painIndicRegex = /\b((?:[a-zA-Z]+(?:\s+[a-zA-Z]+)*)?\s*pain)\b/i;
    const painIndicMatch = orderStr.match(painIndicRegex);
    // Ensure the match is not just the drug name itself if the drug name contains "pain"
    if (painIndicMatch && painIndicMatch[0] && painIndicMatch.index > 0) { // Check index > 0 to avoid matching if "pain" is the start (could be drug)
      // Further check: make sure we are not grabbing "drugname pain" if "pain" is part of a common suffix for the drug.
      // This is complex. For now, a simple match:
      let matchedPainStr = painIndicMatch[0].trim().toLowerCase();
      order.indication = matchedPainStr;
      orderStr = orderStr.replace(painIndicMatch[0], '').trim();
      // console.log(`DEBUG parseOrder Step 4b (Pain Indication): order.indication="${order.indication}", orderStr="${orderStr}"`);
    }
  }

  if (!order.indication) {
    const sobMatch = orderStr.match(/\bshortness of breath\b/i); // "SOB" is already expanded by normalizeText
    if (sobMatch) {
      order.indication = 'shortness of breath';
      orderStr = orderStr.replace(sobMatch[0], '').trim();
      // console.log(`DEBUG parseOrder Step 4c (SOB Indication): order.indication="${order.indication}", orderStr="${orderStr}"`);
    }
  }
  // At this point, for your new order, order.indication should ideally be "moderate pain"
  // and orderStr should be "atorvastatin 40 mg tablet po" (or similar for other drugs)

  // console.log(`DEBUG parseOrder: After indication attempts: orderStr="${orderStr}", indication="${order.indication}"`);

  // 5. Extract Dose (mg/kg, combo-dose, then general unit parsing)
  const weightMatch = orderStr.match(/(\d+(?:\.\d+)?)\s*mg\/kg\b/i);
  if (weightMatch) {
    order.dose = { value: parseFloat(weightMatch[1]), unit: 'mg/kg', total: null }; // total might need patient weight
    orderStr = orderStr.replace(weightMatch[0], '').trim();
  } else {
    const comboMatch = orderStr.match(/(\d+)\s*-\s*(\d+)\s*mg\b/);
    if (comboMatch) {
      order.dose = {
        value: [parseInt(comboMatch[1], 10), parseInt(comboMatch[2], 10)],
        unit: 'mg',
        total: null // Or sum them: parseInt(comboMatch[1], 10) + parseInt(comboMatch[2], 10)
      };
      orderStr = orderStr.replace(comboMatch[0], '').trim();
    } else {
      // General dose unit parsing
      const allUnits = Object.values(unitVariants).flat();
      let unitMatchesFound = [];
      for (let u of allUnits) {
        if (typeof u !== 'string' || u.length === 0) continue;
        const escapedU = u.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*${escapedU}\\b`, 'ig');
        let m;
        while ((m = re.exec(orderStr)) !== null) {
          unitMatchesFound.push({ idx: m.index, qty: +m[1], rawUnit: u, matchStr: m[0] });
        }
      }

      if (unitMatchesFound.length > 0) {
        const bestMatch = unitMatchesFound.reduce((a, b) => b.idx > a.idx ? b : a);
        const stdUnit = Object.entries(unitVariants)
          .find(([std, arr]) => arr.includes(bestMatch.rawUnit))?.[0];
        if (stdUnit) {
          order.dose = { value: bestMatch.qty, unit: stdUnit, total: bestMatch.qty };
          // More robust replace by finding the specific instance
          let tempOrderStr = orderStr;
          const startIndex = tempOrderStr.lastIndexOf(bestMatch.matchStr);
          if (startIndex !== -1 && startIndex === bestMatch.idx) {
             tempOrderStr = tempOrderStr.substring(0, startIndex) + tempOrderStr.substring(startIndex + bestMatch.matchStr.length);
          } else { // Fallback if tricky (e.g. "5 mg ... 5 mg") - might remove first one
             const firstOccurenceIndex = tempOrderStr.indexOf(bestMatch.matchStr);
             if (firstOccurenceIndex !== -1) {
                tempOrderStr = tempOrderStr.substring(0, firstOccurenceIndex) + tempOrderStr.substring(firstOccurenceIndex + bestMatch.matchStr.length);
             }
          }
          orderStr = tempOrderStr.trim();
          // console.log(`DEBUG parseOrder Step 5 (Dose - unitMatches): dose=${JSON.stringify(order.dose)}, orderStr="${orderStr}"`);
        }
      }
      // Fallback if unitMatchesLoop didn't set a dose value but a number is present
      else if (!order.dose.value) {
         const doseUnitsForFallback = ['mcg','mg','g','ml','cc','unit','units','tsp','tbsp','drop','spray','puff','patch','lozenge','suppository','tablet','capsule','each','dose'];
         const fallbackDoseRegex = new RegExp(`(\\d+(?:\\.\\d+)?)(?:\\s*(${doseUnitsForFallback.join('|')})(?:s|es)?\\b)?`, 'i');
         // This regex tries to find a number, optionally followed by a unit.
         // Example: "1", "1 tablet", "10 mg"
         const fallbackMatch = orderStr.match(fallbackDoseRegex);
         if (fallbackMatch && fallbackMatch[1]) {
            const qty = parseFloat(fallbackMatch[1]);
            let unit = (fallbackMatch[2] || '').toLowerCase();
            let formFromUnit = "";

            if (unit) {
                // Normalize unit from unitVariants
                const foundStdUnit = Object.entries(unitVariants).find(([std, arr])=> arr.includes(unit));
                if(foundStdUnit) unit = foundStdUnit[0];

                // Check if this "unit" is actually a form
                if (unitVariants.tablet.includes(unit)) { formFromUnit = 'tablet'; unit = 'tablet';} // or keep unit as 'tablet'
                else if (unitVariants.capsule.includes(unit)) { formFromUnit = 'capsule'; unit = 'capsule';}
                // ... (add other form-like units)

                order.dose = { value: qty, unit: unit, total: qty };
                orderStr = orderStr.replace(fallbackMatch[0], '').trim();
                if(formFromUnit && !order.form) order.form = formFromUnit;
                // console.log(`DEBUG parseOrder Step 5 (Dose - fallbackDoseRegex): dose=${JSON.stringify(order.dose)}, orderStr="${orderStr}"`);
            }
         }
      }
    }
  }

  // Normalize dose units (mcg/g to mg) AFTER all dose parsing attempts
  if (order.dose.value !== null && typeof order.dose.value === 'number') { // Check if value is a number
    if (order.dose.unit === 'mcg') {
      order.dose.value = order.dose.value / 1000;
      if (order.dose.total != null) order.dose.total = order.dose.total / 1000;
      order.dose.unit = 'mg';
    } else if (order.dose.unit === 'g') {
      order.dose.value = order.dose.value * 1000;
      if (order.dose.total != null) order.dose.total = order.dose.total * 1000;
      order.dose.unit = 'mg';
    }
    // Round mg values
    if (order.dose.unit === 'mg') {
      order.dose.value = Math.round(order.dose.value * 1000) / 1000;
      if (order.dose.total != null) {
        order.dose.total = Math.round(order.dose.total * 1000) / 1000;
      }
    }
  }
  // console.log(`DEBUG parseOrder: After dose normalization: dose=${JSON.stringify(order.dose)}, orderStr="${orderStr}"`);


// 6. Extract Form (if not already identified by dose parsing)
if (!order.form) {
  // New, more specific form words list - longest phrases first
  const formDefinitions = [
    { term: 'extended-release tablet', canonical: 'extended-release tablet' },
    { term: 'delayed-release tablet', canonical: 'delayed-release tablet' },
    { term: 'chewable tablet', canonical: 'chewable tablet' },
    { term: 'effervescent tablet', canonical: 'effervescent tablet' },
    { term: 'sublingual tablet', canonical: 'sublingual tablet' },
    { term: 'oral disintegrating tablet', canonical: 'oral disintegrating tablet' },
    { term: 'odt', canonical: 'oral disintegrating tablet' }, // ODT
    { term: 'tablet', canonical: 'tablet' },
    { term: 'extended-release capsule', canonical: 'extended-release capsule' },
    { term: 'delayed-release capsule', canonical: 'delayed-release capsule' },
    { term: 'capsule', canonical: 'capsule' },
    { term: 'caplet', canonical: 'caplet' },
    { term: 'softgel', canonical: 'softgel' },
    { term: 'patch', canonical: 'patch' }, { term: 'patches', canonical: 'patch' },
    { term: 'lozenge', canonical: 'lozenge' },
    { term: 'suppository', canonical: 'suppository' },
    { term: 'spray', canonical: 'spray' },
    { term: 'puff', canonical: 'puff' },
    { term: 'drop', canonical: 'drop' }, { term: 'drops', canonical: 'drop' },
    { term: 'suspension', canonical: 'suspension' },
    { term: 'solution', canonical: 'solution' },
    { term: 'elixir', canonical: 'elixir' },
    { term: 'syrup', canonical: 'syrup' },
    { term: 'liquid', canonical: 'liquid' },
    { term: 'cream', canonical: 'cream' },
    { term: 'ointment', canonical: 'ointment' },
    { term: 'gel', canonical: 'gel' },
    { term: 'inhaler', canonical: 'inhaler' },
    { term: 'mdi', canonical: 'inhaler' },
    { term: 'nebule', canonical: 'nebule' }, { term: 'nebulizer solution', canonical: 'nebule'}
  ];

  // Build regex from sorted form terms (longest first to ensure correct matching)
  const sortedFormTerms = formDefinitions.map(fd => fd.term).sort((a, b) => b.length - a.length);
  // Escape terms for regex and join with |
  const formRegexPattern = sortedFormTerms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
  const formRegex = new RegExp(`\\b(${formRegexPattern})\\b`, 'i');
  const formMatch = orderStr.match(formRegex);

  if (formMatch && formMatch[1]) {
    const matchedTerm = formMatch[1].toLowerCase();
    // Find the definition again using the matched term (case-insensitive find)
    const definition = formDefinitions.find(fd => fd.term.toLowerCase() === matchedTerm);
    if (definition) {
      order.form = definition.canonical;
      orderStr = orderStr.replace(formMatch[0], '').trim();
      // console.log(`DEBUG parseOrder Step 6 (Form): order.form="<span class="math-inline">\{order\.form\}", orderStr\="</span>{orderStr}"`);
    }
  }
} 


  // 7. Extract Route
  const routes = [
    { standard: "po", variations: ["po", "oral", "by mouth"] }, { standard: "sl", variations: ["sl", "sublingual"] },
    { standard: "buccal", variations: ["buccal"] }, { standard: "pr", variations: ["pr", "rectal", "rectally"] },
    { standard: "ng", variations: ["ng", "nasogastric", "ng tube"] }, { standard: "og", variations: ["og", "orogastric"] },
    { standard: "gastrostomy", variations: ["gastrostomy", "g-tube", "peg tube"] }, { standard: "jejunostomy", variations: ["jejunostomy", "j-tube"] },
    { standard: "iv", variations: ["iv", "intravenous", "intravenously"] }, { standard: "im", variations: ["im", "intramuscular", "intramuscularly"] },
    { standard: "subq", variations: ["subq", "sc", "subcutaneous", "subcutaneously"] }, { standard: "id", variations: ["id", "intradermal"] },
    { standard: "io", variations: ["io", "intraosseous"] }, { standard: "intrathecal", variations: ["intrathecal"] },
    { standard: "epidural", variations: ["epidural"] }, { standard: "topical", variations: ["topical", "topically", "apply to skin"] },
    { standard: "transdermal", variations: ["transdermal"] }, { standard: "ophthalmic", variations: ["ophthalmic", "in eye", "eye drop"] },
    { standard: "otic", variations: ["otic", "in ear", "ear drop"] }, { standard: "nasal", variations: ["nasal", "intranasal", "in nose", "nasal spray"] },
    { standard: "vaginal", variations: ["vaginal", "vaginally"] }, { standard: "urethral", variations: ["urethral"] },
    { standard: "intrauterine", variations: ["intrauterine"] }, { standard: "inhalation", variations: ["inhalation", "inhaled", "inh", "mdi", "dpi", "nebulized", "neb"] },
    { standard: "intraperitoneal", variations: ["intraperitoneal"] }, { standard: "intraarticular", variations: ["intraarticular", "intra-articular"] },
    { standard: "intrapleural", variations: ["intrapleural"] }, { standard: "intravesical", variations: ["intravesical"] },
    { standard: "implantable", variations: ["implantable"] }
  ];
  if (!order.route) {
    for (const routeDef of routes) {
      for (const variation of routeDef.variations) {
        const routeRegex = new RegExp(`\\b${variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
        if (routeRegex.test(orderStr)) {
          order.route = routeDef.standard;
          orderStr = orderStr.replace(routeRegex, '').trim();
          break;
        }
      }
      if (order.route) break;
    }
    // console.log(`DEBUG parseOrder Step 7 (Route): order.route="${order.route}", orderStr="${orderStr}"`);
  }


  // 8. Extract Frequency

// Explicitly check for "immediately" first, as it's a specific frequency from "stat" or "now"
const immediatelyPattern = /\bimmediately\b/i;
if (!order.frequency && immediatelyPattern.test(orderStr)) {
    order.frequency = "immediately";
    orderStr = orderStr.replace(immediatelyPattern, '').trim();
    // console.log(`DEBUG parseOrder Step 8a (Immediately): order.frequency="<span class="math-inline">\{order\.frequency\}", orderStr\="</span>{orderStr}"`);
}
// Now proceed with other frequency checks if not "immediately"
if (!order.frequency) { // <<<< ADD THIS OPENING 'if' and its brace
  
  const qhMatch = orderStr.match(/\bq(\d+)h\b/i);
  if (qhMatch) {
    order.frequency = `q${qhMatch[1]}h`;
    orderStr = orderStr.replace(qhMatch[0], '').trim();
  } else {
    
    // *** NEW CHECK FOR qXhrs ***
    const qhrsMatch = orderStr.match(/\bq(\d+)(?:hrs|hr)\b/i); // Match q<number>hrs or q<number>hr
    if (qhrsMatch) {
        order.frequency = `q${qhrsMatch[1]}h`; // Normalize to qXh
        orderStr = orderStr.replace(qhrsMatch[0], '').trim();
        // console.log(`DEBUG parseOrder Step 8b (qXhrs): freq="<span class="math-inline">\{order\.frequency\}", orderStr\="</span>{orderStr}"`);
    } else { // This 'else' means qXhrs also failed
        const everyHours = orderStr.match(/\bevery\s*(\d+)\s*hours?\b/i);
        if (everyHours) {
          order.frequency = `q${everyHours[1]}h`;
          orderStr = orderStr.replace(everyHours[0], '').trim();
        } else {
          const freqMapping = { /* ... your existing map ... */
              "once daily": "daily", "once a day": "daily", "1 times daily": "daily", "daily": "daily", "od": "daily", "qd": "daily",
              "twice daily": "twice daily", "2 times daily": "twice daily", "bid": "twice daily",
              "three times daily": "three times daily", "3 times daily": "three times daily", "tid": "three times daily",
              "four times daily": "four times daily", "4 times daily": "four times daily", "qid": "four times daily",
              "every other day": "every other day", "qod": "every other day",
              "stat": "immediately", "now": "immediately",
              "weekly": "weekly", "once a week": "weekly",
              "monthly": "monthly", "once a month": "monthly"
          };
          const sortedFreqKeys = Object.keys(freqMapping).sort((a, b) => b.length - a.length);
          for (const key of sortedFreqKeys) {
            const pattern = new RegExp(`\\b${key.replace(/\s+/g, '\\s+')}\\b`, 'i');
            // Check !order.frequency again inside the loop
            if (!order.frequency && pattern.test(orderStr)) {
              order.frequency = freqMapping[key];
              orderStr = orderStr.replace(pattern, '').trim();
              break;
            }
          }
        }
	}
    }
}
  if (!order.frequency && order.timeOfDay) {
    order.frequency = 'daily';
  }
  // console.log(`DEBUG parseOrder Step 8 (Frequency): order.frequency="${order.frequency}", orderStr="${orderStr}"`);


 // 9. Final Drug Name and any remaining text as Indication (if indication not already set explicitly)
orderStr = orderStr.trim();
// Remove any leading numbers/units that might be leftover unparsed doses or dangling numbers
// This regex tries to remove a number, optionally followed by a unit-like word if it's at the start.
orderStr = orderStr.replace(/^(\d+(?:\.\d+)?\s*([a-zA-ZŒº]+)?)\s*(?=[a-zA-Z])/, '').trim(); // Remove only if followed by a letter (drug name)
orderStr = orderStr.trim();

const finalParts = orderStr.split(/\s+/).filter(part => part.length > 0); // Filter out empty strings from multiple spaces

if (finalParts.length > 0) {
    // The first part is generally the drug. If it's a known non-drug keyword, something is wrong.
    const firstWord = finalParts[0].toLowerCase();
    const knownNonDrugStarters = ['for', 'with', 'as', 'per', 'to', 'if', 'when', 'at', 'in']; // common indication/instruction starters

    if (!knownNonDrugStarters.includes(firstWord) && !/\d/.test(finalParts[0])) { // If first word isn't a non-drug starter or a number
        order.drug = finalParts[0];
        if (finalParts.length > 1 && !order.indication) { // If more words remain AND no indication was set yet
            // Check if the remaining text looks like an indication rather than more drug name
            const remainingText = finalParts.slice(1).join(' ');
            // A simple check: if it starts with a non-drug keyword, it's likely an indication/instruction
            const firstOfRemaining = (finalParts[1] || "").toLowerCase();
            if (knownNonDrugStarters.includes(firstOfRemaining)) {
                order.indication = remainingText.trim();
            } else {
                // It's ambiguous. Could be part of a multi-word drug name or an indication.
                // For now, if no explicit indication was caught, and it doesn't start with a clear
                // indication keyword, we might cautiously add it to drug name or leave as indication.
                // Let's assume for now if indication is not set, it's an indication.
                order.indication = remainingText.trim();
            }
        }
    } else if (finalParts.length > 0 && !order.indication) {
        // If the first word IS a non-drug keyword, or a number, and no drug name was set,
        // this is likely a parsing remnant that should be an indication.
        order.indication = finalParts.join(' ').trim();
    }
    // If order.drug is still empty but finalParts exist, take the first as drug.
    if (!order.drug && finalParts.length > 0) {
        order.drug = finalParts[0];
        if (finalParts.length > 1 && !order.indication) {
            order.indication = finalParts.slice(1).join(' ').trim();
        }
    }
}

// Final cleanup of drug name and indication
if (order.drug) {
    // Remove any trailing non-alphanumeric (except hyphen/slash if desired in drug name)
    order.drug = order.drug.replace(/[^a-zA-Z0-9\/\s-]+/g, ' ').replace(/\s\s+/g, ' ').trim();
}
if (order.indication) {
    order.indication = order.indication.replace(/\s\s+/g, ' ').trim();
    
// If indication ended up being something clearly not an indication (e.g., just units or forms) clear it
    const nonIndicationRemnants = /^(mg|mcg|ml|tablet|capsule|po|iv|subq|im|oint|g|meq|units|unit|in|at|on|am|pm|daily|for|with|the|a|to|of)$/i;
    if (nonIndicationRemnants.test(order.indication.trim())) {
        
// console.log(`Clearing likely non-indication: "<span class="math-inline">\{order\.indication\}" for drug "</span>{order.drug}"`);
        order.indication = "";
    }
} else {
    order.indication = ""; // Ensure it's an empty string if null/undefined
}

  // console.log('FINAL DEBUG Parsed order:', { /* input: originalInputToParseOrder, */ parsed: order });
  return order;
}

    function levenshteinDistance(a, b) {
      const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
      for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
      for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
          matrix[j][i] = Math.min(
            matrix[j][i - 1] + 1,
            matrix[j - 1][i] + 1,
            matrix[j - 1][i - 1] + indicator
          );
        }
      }
      return matrix[b.length][a.length];
    }

    function similarity(a, b) {
      const distance = levenshteinDistance(a, b);
      const maxLen = Math.max(a.length, b.length);
      return 1 - distance / maxLen;
    }

    function ordersAreEqual(a, b) {
  // 1) drug name
  const normA = normalizeMedicationName(a.drug);
  const normB = normalizeMedicationName(b.drug);
  const drugSimilarity = normA && normB
    ? similarity(normA, normB)
    : (normA === normB ? 1 : 0);
  if (drugSimilarity < 0.85) return false;

  // 2) dose (including combos)
  if (Array.isArray(a.dose.value) || Array.isArray(b.dose.value)) {
    if (!Array.isArray(a.dose.value) || !Array.isArray(b.dose.value)) return false;
    if (a.dose.value.length !== b.dose.value.length) return false;
    for (let i = 0; i < a.dose.value.length; i++) {
      if (a.dose.value[i] !== b.dose.value[i]) return false;
    }
    if (a.dose.unit !== b.dose.unit) return false;
  } else {
    const totalA = (a.dose.total != null ? a.dose.total : a.dose.value);
    const totalB = (b.dose.total != null ? b.dose.total : b.dose.value);
    if (totalA !== totalB || a.dose.unit !== b.dose.unit) return false;
  }

  // 3) route
  if (a.route !== b.route) return false;

    /// 4) frequency  ‚Äî treat ‚Äúdaily‚Äù, ‚Äúq24h‚Äù, and blank as the same
	const canonFreq = f => {
 	 f = (f || '').toLowerCase().trim();
 	 return (f === '' || f === 'daily' || f === 'q24h') ? 'daily' : f;
	};

	const fA = canonFreq(a.frequency);
	const fB = canonFreq(b.frequency);

	// exact ‚ÄúqNh‚Äù forms (q4h, q6h, ‚Ä¶) must match numerically
	const qA = fA.match(/^q(\d+)h$/);
	const qB = fB.match(/^q(\d+)h$/);

	if (qA && qB) {
  	if (+qA[1] !== +qB[1]) return false;
	} else if (fA !== fB) {
  	// fall back to fuzzy text similarity for phrases like ‚Äútwice daily‚Äù
  	const freqSim = similarity(fA, fB);
  	if (freqSim < 0.85) return false;
}

  // ‚îÄ‚îÄ‚îÄ normalize time-of-day equivalence ‚îÄ‚îÄ‚îÄ
const normalizeTOD = t => {
  if (!t) return '';
  t = t.toLowerCase().trim(); // Added .trim()
  if (t === 'morning' || t === 'qam' || t === 'am' || t.includes('in morning') || t.includes('in the am')) return 'morning';
  if (t === 'evening' || t === 'pm' || t.includes('in evening') || t.includes('in the pm')) return 'evening';
  if (t === 'bedtime' || t === 'night' || t === 'qhs' || t.includes('at bedtime')) return 'bedtime';
  return t;
};

  if (normalizeTOD(a.timeOfDay) !== normalizeTOD(b.timeOfDay)) {
    return false;
  }
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // 5) dosage form must match ‚Ä¶
  if ((a.form || '') !== (b.form || '')) return false;
  // 6) PRN flag ‚Ä¶
  if (a.prn !== b.prn) return false;


// ‚Äî‚Äî‚Äî ENSURE PAIN INDICATION MATCHES ‚Äî‚Äî‚Äî
if ((a.indication || b.indication) && a.indication !== b.indication) {
  return false;
}
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

  return true;
}

    function compareOrders(list1, list2) {
      let unchanged = [];
      let removed = [];
      let added = [];
      let matched2 = new Array(list2.length).fill(false);
      for (let orderObj1 of list1) {
        let found = false;
        for (let i = 0; i < list2.length; i++) {
          if (!matched2[i] && ordersAreEqual(orderObj1.parsed, list2[i].parsed)) {
            matched2[i] = true;
            unchanged.push({             //  ‚Üê NEW: remember BOTH originals
                              orig: orderObj1,           //     from the facility list
                              new : list2[i]             //     from the hospital list
                              });
            found = true;
            break;
          }
        }
        if (!found) removed.push(orderObj1);
      }
      for (let i = 0; i < list2.length; i++) {
        if (!matched2[i]) added.push(list2[i]);
      }
//=== STEP‚ÄëMERGESAME  ‚¨áÔ∏é stop double‚Äëcounting identical meds =============
for (let i = removed.length - 1; i >= 0; i--) {
  const r = removed[i];
  const j = added.findIndex(a => ordersAreEqual(r.parsed, a.parsed));
  if (j !== -1) {
    unchanged.push({ orig: r, new: added[j] });
    removed.splice(i, 1);          // pull it from ‚Äúremoved‚Äù
    added.splice(j, 1);            // pull it from ‚Äúadded‚Äù
  }
}
//=== END STEP‚ÄëMERGESAME ===============================================

      return { unchanged, removed, added };
    }

    function isCriticalOrder(orderObj) {
      const text = orderObj.original.toLowerCase();
      return criticalMeds.some(med => text.includes(med));
    }

    function showScreen(screenId) {
      document.getElementById('error-message').textContent = '';
      document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
      updateProgress(screenId);
    }

    function updateProgress(screenId) {
      document.getElementById('step1').classList.remove('filled', 'current');
      document.getElementById('step2').classList.remove('filled', 'current');
      document.getElementById('step3').classList.remove('filled', 'current');
      document.getElementById('step4').classList.remove('filled', 'current');
      document.getElementById('line1-2').classList.remove('filled');
      document.getElementById('line2-3').classList.remove('filled');
      document.getElementById('line3-4').classList.remove('filled');

      if (screenId === 'disclaimer-screen') {
        document.getElementById('step1').classList.add('current');
      } else if (screenId === 'photo1-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
      } else if (screenId === 'photo2-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
      } else if (screenId === 'results-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('filled');
        document.getElementById('step4').classList.add('filled');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
        document.getElementById('line3-4').classList.add('filled');
      }
    }

    function showLoading(msg) {
      const ld = document.getElementById('loading'),
            lt = document.getElementById('loading-text');
      ld.style.display = 'flex';
      lt.textContent = msg;
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(msg) {
      document.getElementById('error-message').textContent = msg;
    }

    function acknowledgeDisclaimer() {
      showScreen('photo1-screen');
    }

    function handlePhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
    }

    function handleAdditionalPhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
      document.getElementById('photo1-capture2').value = "";
      document.getElementById('photo1-upload2').value = "";
    }

    function updatePhoto1UI() {
  // 1) grab the ‚ÄúYou can take a photo‚Ä¶‚Äù paragraph
  const instr1 = document.querySelector('#photo1-screen .upload-instructions');
  // 2) hide it as soon as you've added ‚â•1 photo OR used the text‚Äêpaste path
  instr1.style.display = (photo1Files.length > 0 || hasTextInput1)
    ? 'none'
    : 'block';

  // Update count & Next-button state:
  document.getElementById('photo1-status').textContent =
    photo1Files.length + (photo1Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo1-next').disabled =
    photo1Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo1-preview', photo1Files, 1);

  if (photo1Files.length > 0) {
    // Show prompt with **Next** bold:
    const prompt1 = document.getElementById('photo1-prompt');
    prompt1.style.display = 'block';
    prompt1.innerHTML =
      `Photo ${photo1Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Next</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo1-options').style.display = 'none';
    document.getElementById('additional-photo1-option').style.display = 'flex';
  } else {
    // No photos ‚Üí back to start
    document.getElementById('photo1-prompt').style.display = 'none';
    document.getElementById('initial-photo1-options').style.display = 'flex';
    document.getElementById('additional-photo1-option').style.display = 'none';
  }

  // Clear file inputs so you can re-select the same file if needed:
  document.getElementById('photo1-capture').value = "";
  document.getElementById('photo1-upload').value = "";
}



    function handlePhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
    }

    function handleAdditionalPhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
      document.getElementById('photo2-capture2').value = "";
      document.getElementById('photo2-upload2').value = "";
    }

    function updatePhoto2UI() {
    // 1) grab the ‚ÄúYou can take a photo‚Ä¶‚Äù paragraph on screen 2
  const instr2 = document.querySelector('#photo2-screen .upload-instructions');
  // 2) hide it as soon as you've added ‚â•1 photo OR used the paste path
  instr2.style.display = (photo2Files.length > 0 || hasTextInput2)
    ? 'none'
    : 'block';

  // Update count & Compare-button state:
  document.getElementById('photo2-status').textContent =
    photo2Files.length + (photo2Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo2-compare').disabled =
    photo2Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo2-preview', photo2Files, 2);

  if (photo2Files.length > 0) {
    // Show prompt with **Compare** bold:
    const prompt2 = document.getElementById('photo2-prompt');
    prompt2.style.display = 'block';
    prompt2.innerHTML =
      `Photo ${photo2Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Compare</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo2-options').style.display = 'none';
    document.getElementById('additional-photo2-option').style.display = 'flex';
  } else {
    // No photos ‚Üí back to start
    document.getElementById('photo2-prompt').style.display = 'none';
    document.getElementById('initial-photo2-options').style.display = 'flex';
    document.getElementById('additional-photo2-option').style.display = 'none';
  }

  // Clear file inputs
  document.getElementById('photo2-capture').value = "";
  document.getElementById('photo2-upload').value = "";
}

    function updatePreview(previewId, files, listNumber) {
      const container = document.getElementById(previewId);
      container.innerHTML = "";
      files.forEach((file, index) => {
        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.className = 'thumbnail-container';
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '<span class="material-icons">close</span>';
        deleteBtn.onclick = () => deletePhoto(listNumber, index);
        thumbnailDiv.appendChild(img);
        thumbnailDiv.appendChild(deleteBtn);
        container.appendChild(thumbnailDiv);
      });
    }

    function deletePhoto(listNumber, index) {
      if (listNumber === 1) {
        photo1Files.splice(index, 1);
        updatePhoto1UI();
      } else if (listNumber === 2) {
        photo2Files.splice(index, 1);
        updatePhoto2UI();
      }
    }

    function handleTextInput1() {
      const text = document.getElementById('photo1-text-input').value.trim();
      if (!text) {
        showError('Please paste a medication list before submitting.');
        return;
      }
      // Clear any old status
      document.getElementById('photo1-status').textContent = 'List pasted.';
      hasTextInput1 = true;
      let lines = text.split(/\r?\n+/).map(line => cleanLine(line));
	lines = mergeMultiLineOrders(lines);
	lines = mergeTaperPackOrders(lines);
	// prune off any trailing non-order text
	// lines = lines.map(line => pruneLine(line));
	lines = lines.filter(line => 
		isLikelyOrderLine(line) && containsKnownMedication(line)
		);


      console.log('Raw lines after filtering:', lines); // Debug log
      lines = [...new Set(lines)];
      if (lines.length === 0) {
        showError('No valid medication orders detected in the pasted list. Please try again.');
        return;
      }
      meds1 = lines.map(med => {
        try {
          const parsed = parseOrder(med);
          if (!parsed || typeof parsed !== 'object') {
            console.warn('Parse failed for:', med, 'returning default object');
            return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
          }
          return { original: med, parsed: parsed };
        } catch (e) {
          console.error('Error parsing line:', med, e.stack || e);
          return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
        }
      });
      console.log('Medications from First List (Text Input):', meds1);
      document.getElementById('photo1-status').textContent = 'Proceeding to second list...';
      document.getElementById('initial-photo1-options').style.display = 'none';
      document.getElementById('additional-photo1-option').style.display = 'none';
      document.getElementById('photo1-prompt').style.display = 'none';
      showError('');
      showScreen('photo2-screen');
    }

    function handleTextInput2() {
      const text = document.getElementById('photo2-text-input').value.trim();
      if (!text) {
        showError('Please paste a medication list before submitting.');
        return;
      }
      // Clear any old status
      document.getElementById('photo2-status').textContent = 'List pasted.';
      hasTextInput2 = true;
          let lines = text.split(/\r?\n+/).map(line => cleanLine(line));
    	lines = mergeMultiLineOrders(lines);
	lines = mergeTaperPackOrders(lines);
	// prune off any trailing non-order text
	// lines = lines.map(line => pruneLine(line));
    	lines = lines.filter(line => 
		isLikelyOrderLine(line) && containsKnownMedication(line)
		);

      console.log('Raw lines after filtering:', lines); // Debug log
      lines = [...new Set(lines)];
      if (lines.length === 0) {
        showError('No valid medication orders detected in the pasted list. Please try again.');
        return;
      }
      meds2 = lines.map(med => {
        try {
          const parsed = parseOrder(med);
          if (!parsed || typeof parsed !== 'object') {
            console.warn('Parse failed for:', med, 'returning default object');
            return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
          }
          return { original: med, parsed: parsed };
        } catch (e) {
          console.error('Error parsing line:', med, e.stack || e);
          return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
        }
      });
      console.log('Medications from Second List (Text Input):', meds2);
      document.getElementById('photo2-compare').disabled = false;
      document.getElementById('initial-photo2-options').style.display = 'none';
      document.getElementById('additional-photo2-option').style.display = 'flex';
      document.getElementById('photo2-prompt').style.display = 'block';
      document.getElementById('photo2-prompt').textContent = 'You may add a photo or click Compare to continue.';
      showError('');
    }

    async function goToPhoto2() {
      if (!hasTextInput1 && (!photo1Files || photo1Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput1) {
        showLoading('Processing first image(s)...');
        try {
          let combinedText = await processFiles(photo1Files);
                      let lines = combinedText.split(/\r?\n+/).map(line => cleanLine(line));
      		lines = mergeMultiLineOrders(lines);
		lines = mergeTaperPackOrders(lines);
		// prune off any trailing non-order text
		// lines = lines.map(line => pruneLine(line));
//=== STEP 4  removed ‚Äì keepOrderLines already filtered


          console.log('Raw lines from OCR:', lines); // Debug log
          lines = [...new Set(lines)];
          if (lines.length === 0) {
            hideLoading();
            showError('No valid medication orders detected in the first photos. Please try again.');
            return;
          }
          meds1 = lines.map(med => {
            try {
              const parsed = parseOrder(med);
              if (!parsed || typeof parsed !== 'object') {
                console.warn('Parse failed for:', med, 'returning default object');
                return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
              }
              return { original: med, parsed: parsed };
            } catch (e) {
              console.error('Error parsing line:', med, e.stack || e);
              return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
            }
          });
          console.log('Medications from First List:', meds1);
          hideLoading();
          showScreen('photo2-screen');
        } catch (err) {
          console.error('OCR Error:', err);
          hideLoading();
          showError('Error extracting text from the first photos. Please try again.');
        }
      }
    }

    async function comparePhotos() {
      if (!hasTextInput2 && (!photo2Files || photo2Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput2) {
        showLoading('Processing second image(s)...');
        try {
          let combinedText = await processFiles(photo2Files);
                let lines = combinedText.split(/\r?\n+/).map(line => cleanLine(line));
      		lines = mergeMultiLineOrders(lines);
		lines = mergeTaperPackOrders(lines);
		// prune off any trailing non-order text
		// lines = lines.map(line => pruneLine(line));
//=== STEP 4  removed ‚Äì keepOrderLines already filtered

          console.log('Raw lines from OCR:', lines); // Debug log
          lines = [...new Set(lines)];
          if (lines.length === 0) {
            hideLoading();
            showError('No valid medication orders detected in the second photos. Please try again.');
            return;
          }
          meds2 = lines.map(med => {
            try {
              const parsed = parseOrder(med);
              if (!parsed || typeof parsed !== 'object') {
                console.warn('Parse failed for:', med, 'returning default object');
                return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
              }
              return { original: med, parsed: parsed };
            } catch (e) {
              console.error('Error parsing line:', med, e.stack || e);
              return { original: med, parsed: { drug: med, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false } };
            }
          });
          console.log('Medications from Second List:', meds2);
          hideLoading();
          compareAndShowResults();
        } catch (err) {
          console.error('OCR Error:', err);
          hideLoading();
          showError('Error extracting text from the second photos. Please try again.');
        }
      } else {
        compareAndShowResults();
      }
    }

function compareAndShowResults() {
    let { unchanged, removed, added } = compareOrders(meds1, meds2);
    
//=== STEP-MERGE-REMOVED-ADDED (enhanced) ======================
const merged = [];
const addedMap = Object.create(null);
added.forEach(a => {
  addedMap[ normalizeMedicationName(a.original) ] = a;
});

removed = removed.filter(r => {
  const key   = normalizeMedicationName(r.original);
  const match = addedMap[key];
  if (!match) return true;

  // 2-a) if the only difference is form, force a single "Form changed"
  const reason = getChangeReason(r.parsed, match.parsed);
  if (reason === 'Form changed') {
    merged.push({ orig:r, new:match, reason:'Form changed' });
    delete addedMap[key];
    return false;
  }

  // 2-b) otherwise fall back to your old logic
  merged.push({ orig:r, new:match, reason });
  delete addedMap[key];
  return false;
});

added = Object.values(addedMap);
//=== END STEP-MERGE-REMOVED-ADDED ==============================


//=== STEP‚ÄëFIX  skip any blank or junk entries =========================
const notBlank = obj =>
  obj && obj.original && obj.original.trim().length > 0;

unchanged = unchanged.filter(pair => notBlank(pair.orig) && notBlank(pair.new));
removed   = removed  .filter(notBlank);
added     = added    .filter(notBlank);
//=== END STEP‚ÄëFIX ======================================================

    // Build a numbered, four-column table of changes
    let html = `
        <table class="changes-table">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Original Order (Facility)</th>
                    <th>New Order (Hospital)</th>
                    <th>Suspected Change</th>
                </tr>
            </thead>
            <tbody>
    `;

    let idx = 1;

    // Process removed orders (potential changes or removals)

// ‚Äë‚Äë‚Äë FIRST: show the neatly‚Äëmerged pairs ‚Äë‚Äë‚Äë
merged.forEach(pair => {
  const crit = isCriticalOrder(pair.orig) || isCriticalOrder(pair.new);
  html += `
    <tr class="${crit ? 'critical' : ''}">
      <td>${idx++}</td>
      <td>${pair.orig.original}</td>
      <td>${pair.new.original}</td>
      <td>${pair.reason}</td>
    </tr>`;
});
    
removed.forEach(r => {
        console.group(`üîç Comparing removed: ${r.original}`);
        console.log('   current added[]:', added.map(a => a.original));
        const lowerRem = r.original.toLowerCase();
        let match = null;
        let changeType = null;

        // 1) Brand ‚Üí generic?
        const brandKey = Object.keys(brandToGenericMap).find(b => lowerRem.includes(b));
        if (brandKey) {
            changeType = 'Generic Medication';
            const gen = brandToGenericMap[brandKey];
            match = added.find(a => normalizeMedicationName(a.parsed.drug) === gen);
        }

        // 2) Generic ‚Üí brand?
        if (!match) {
            const genKey = normalizeMedicationName(r.parsed.drug);
            const brandList = genericToBrandMap[genKey] || [];
            for (let brand of brandList) {
                const regex = new RegExp(`\\b${brand}\\b`, 'i');
                const found = added.find(a => regex.test(a.original));
                if (found) {
                    changeType = 'Brand Medication';
                    match = found;
                    break;
                }
            }
        }

        // 3) Substring match (fallback, less precise)
        if (!match) {
            const drugName = r.parsed.drug.toLowerCase();
            match = added.find(a => a.original.toLowerCase().includes(drugName));
            if (match) {
                changeType = getChangeReason(r.parsed, match.parsed);
    	// very novice-friendly override for ‚Äúonly indication‚Äù cases
   	 const origInd = (r.parsed.indication || '').toLowerCase().trim();
   	 const newInd  = (match.parsed.indication || '').toLowerCase().trim();
   	 if (
     	 normalizeMedicationName(r.parsed.drug) === normalizeMedicationName(match.parsed.drug)
      	&& r.parsed.dose.value === match.parsed.dose.value
      	&& r.parsed.dose.unit  === match.parsed.dose.unit
     	 && origInd !== newInd
    	) {
      	changeType = 'Indication changed';
    	}
                console.log(`   ‚Üí substring matched "${drugName}" to`, match.original);
            }
        }

        const crit = isCriticalOrder(r) || (match && isCriticalOrder(match));

        // 4) Brand ‚Üî generic swap
        if (match && (changeType === 'Generic Medication' || changeType === 'Brand Medication')) {
            html += `
                <tr class="${crit ? 'critical' : ''}">
                    <td>${idx++}</td>
                    <td>${r.original}</td>
                    <td>${match.original}</td>
                    <td>${changeType}</td>
                </tr>
            `;
            added = added.filter(a => a !== match);
            console.groupEnd();
            return;
        }

        // 5) Dose / freq / form / route / PRN / admin reasons
        if (match) {
            // Use getChangeReason to determine the specific change
            const reason = getChangeReason(r.parsed, match.parsed);
            html += `
                <tr class="${crit ? 'critical' : ''}">
                    <td>${idx++}</td>
                    <td>${r.original}</td>
                    <td>${match.original}</td>
                    <td>${reason}</td>
                </tr>
            `;
            added = added.filter(a => a !== match);
            console.groupEnd();
            return;
        }

        // 6) Same-drug match
        const sameDrug = added.find(a =>
            normalizeMedicationName(a.parsed.drug) === normalizeMedicationName(r.parsed.drug)
        );
        if (sameDrug) {
            const reason = getChangeReason(r.parsed, sameDrug.parsed);
            html += `
                <tr class="${crit ? 'critical' : ''}">
                    <td>${idx++}</td>
                    <td>${r.original}</td>
                    <td>${sameDrug.original}</td>
                    <td>${reason}</td>
                </tr>
            `;
            added = added.filter(a => a !== sameDrug);
            console.groupEnd();
            return;
        }

        // 7) Pure removal
        html += `
            <tr class="${crit ? 'critical' : ''}">
                <td>${idx++}</td>
                <td>${r.original}</td>
                <td></td>
                <td>Removed</td>
            </tr>
        `;
        console.groupEnd();
    });

    // Unchanged ‚Äë‚Äë‚Üí now re‚Äëevaluate for brand/generic etc.
    unchanged.forEach(u => {
       const reason = getChangeReason(u.orig.parsed, u.new.parsed);
       const label  = (reason === 'Misc. Change') ? 'Unchanged' : reason;

      html += `
    <tr${label !== 'Unchanged' && (isCriticalOrder(u.orig)||isCriticalOrder(u.new)) ? ' class="critical"' : ''}>
                <td>${idx++}</td>
                 <td>${u.orig.original}</td>
                 <td>${u.new.original}</td>
                 <td>${label}</td>
             </tr>
        `;
      });


    // Added orders
    added.forEach(a => {
        const crit = isCriticalOrder(a);
        html += `
            <tr class="${crit ? 'critical' : ''}">
                <td>${idx++}</td>
                <td></td>
                <td>${a.original}</td>
                <td>Added</td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
    `;

    document.getElementById('results-content').innerHTML = html;
    showScreen('results-screen');
}

    async function exportToPDF() {
  // 1) grab your table
  const table = document.querySelector('.changes-table');
  // 2) init jsPDF
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });

  // 3) optional: add a title
  pdf.setFontSize(14);
  pdf.text('Comparison Results', 40, 40);

  // 4) render the table with AutoTable
  pdf.autoTable({
    html: table,
    startY: 60,
    theme: 'grid',
    headStyles: { fillColor: [240,240,240] },
    styles: {
      fontSize: 9,
      cellPadding: 4,
      overflow: 'linebreak'
    },
    // ensure no row ever splits across pages:
    pageBreak: 'avoid',
    didDrawPage: (data) => {
      // here you could add page numbers, headers, etc.
    }
  });

  // 5) save the PDF
  pdf.save('MedRec_Report.pdf');
}


function printResults() {
  // 1) make sure we‚Äôre on the results screen
  showScreen('results-screen');

  // 2) give the browser a moment to apply your @media print CSS
  setTimeout(() => {
    window.print();
  }, 100);
}

    function startOver() {
      photo1Files = [];
      photo2Files = [];
      meds1 = [];
      meds2 = [];
      hasTextInput1 = false;
      hasTextInput2 = false;
      document.getElementById('photo1-capture').value = '';
      document.getElementById('photo1-upload').value = '';
      document.getElementById('photo1-capture2').value = '';
      document.getElementById('photo1-upload2').value = '';
      document.getElementById('photo2-capture').value = '';
      document.getElementById('photo2-upload').value = '';
      document.getElementById('photo2-capture2').value = '';
      document.getElementById('photo2-upload2').value = '';
      document.getElementById('photo1-text-input').value = '';
      document.getElementById('photo2-text-input').value = '';
      document.getElementById('photo1-status').textContent = '';
      document.getElementById('photo2-status').textContent = '';
      document.getElementById('photo1-next').disabled = true;
      document.getElementById('photo2-compare').disabled = true;
      document.getElementById('results-content').innerHTML = '';
      document.getElementById('photo1-preview').innerHTML = "";
      document.getElementById('photo2-preview').innerHTML = "";
      document.getElementById('photo1-prompt').style.display = 'none';
      document.getElementById('initial-photo1-options').style.display = 'flex';
      document.getElementById('additional-photo1-option').style.display = 'none';
      document.getElementById('photo2-prompt').style.display = 'none';
      document.getElementById('initial-photo2-options').style.display = 'flex';
      document.getElementById('additional-photo2-option').style.display = 'none';
      showScreen('disclaimer-screen');
    }

    // Tooltip toggle for mobile
    document.querySelectorAll('.tooltip').forEach(tooltip => {
      tooltip.addEventListener('click', (e) => {
        e.stopPropagation();
        const isActive = tooltip.classList.contains('active');
        document.querySelectorAll('.tooltip').forEach(t => t.classList.remove('active'));
        if (!isActive) {
          tooltip.classList.add('active');
        }
      });
    });

    document.addEventListener('click', () => {
      document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.classList.remove('active');
      });
    });

    document.addEventListener('DOMContentLoaded', () => {
      hideLoading();
      updateProgress('disclaimer-screen');
    });
  </script>
<!-- 1) html2canvas: required for jsPDF.html() to work -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<!-- 2) jsPDF UMD bundle -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<!-- 3) jsPDF-AutoTable plugin: add this line -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>

</body>
</html>
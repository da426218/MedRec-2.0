<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MedRec 2.0</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    /* Basic Layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      background-color: #007bff;
      color: white;
      text-align: center;
      padding: 0.5rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      height: 185px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      box-sizing: border-box;
    }
    main {
      flex: 1;
      padding: 1rem;
      max-width: 600px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .screen {
      display: none;
      width: 100%;
      text-align: center;
    }
    .screen.active {
      display: block;
    }
    /* Card Styling */
    .card {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid #ddd;
      padding: 1rem;
      margin: 0.5rem 0;
      width: 100%;
      box-sizing: border-box;
    }
    /* Buttons & Inputs */
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      margin: 0.5rem 0;
      cursor: pointer;
      border-radius: 15px;
      width: 100%;
      max-width: 300px;
      display: block;
      font-weight: 600;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: box-shadow 0.2s ease;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #0056b3;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    /* Hide native file inputs */
    input[type="file"] {
      display: none;
    }
    .photo-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      margin: 1rem 0;
      width: 100%;
    }
    .photo-actions button {
      width: 100%;
      max-width: 300px;
      margin: 0;
    }
    .disclaimer-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1rem 0;
      width: 100%;
    }
    .disclaimer-actions button {
      width: 100%;
      max-width: 300px;
    }
    .upload-instructions {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #555;
    }
    .upload-prompt {
      font-size: 0.9rem;
      margin: 0.5rem 1rem;
      color: #333;
    }
    .preview-container {
      text-align: center;
      margin: 0.5rem 0 1rem;
    }
    .thumbnail-container {
      position: relative;
      display: inline-block;
      margin: 0.25rem;
    }
    .thumbnail-container img {
      width: 80px;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    /* ============== delete (close) chip ============== */
    .delete-btn {
      position: absolute;
      top: -6px;                   /* sticks out a little */
      right: -6px;
      width: 24px;                 /* exact circle */
      height: 24px;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #ff4d4d;         /* red chip */
      color: #fff;                 /* white “X” */
      font-size: 18px;             /* icon size */
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.25);
      transition: background .15s ease;
      padding: 0;                  /* override global button padding */
    }
    .delete-btn:hover {
      background: #d73838;         /* darker on hover */
    }
    /* make the glyph a touch smaller and centred */
    .delete-btn .material-icons {
      font-size: 18px;             /* icon ≈ 75 % of circle */
      line-height: 1;
    }
    #error-message {
      color: red;
      text-align: center;
      margin: 1rem 0;
    }
    .critical {
      color: red;
      font-weight: bold;
    }
/* ========= New table styling ========== */
table.changes-table {
  width: auto;
  margin: 1rem auto;    /* center horizontally */
  border-collapse: collapse;
  font-size: 0.9rem;
}
/* allow horizontal scroll on narrow viewports */
#results-content {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
table.changes-table th,
table.changes-table td {
  border: 1px solid #ddd;
  padding: 0.5rem;
  text-align: left;
}
table.changes-table th {
  background-color: #f0f0f0;
}
/* Prevent splitting rows across PDF pages */
.changes-table,
.changes-table thead,
.changes-table tbody,
.changes-table tr,
.changes-table th,
.changes-table td {
  page-break-inside: avoid !important;
}

    .progress-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0.5rem 0;
      margin-top: -40px;
      position: relative;
    }
    .progress-step {
      width: 30px;
      height: 30px;
      background-color: #cccccc;
      border: 1px solid #999;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      transition: all 0.3s ease;
    }
    .progress-step.filled {
      background-color: #66b0ff;
      border: 1px solid #0056b3;
      color: white;
    }
    .progress-step.current {
      background-color: #007bff;
      border: 3px solid #0056b3;
      color: white;
    }
    .progress-line-container {
      position: absolute;
      top: 50%;
      left: 15px;
      right: 15px;
      height: 2px;
      z-index: 0;
      display: flex;
      justify-content: space-between;
    }
    .progress-line {
      flex: 1;
      height: 2px;
      background-color: #cccccc;
      margin: 0 5px;
    }
    .progress-line.filled {
      background-color: #66b0ff;
    }
    #loading {
      display: none;
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 0.5rem;
      text-align: center;
      z-index: 2000;
    }
    #loading-text {
      margin-bottom: 0.25rem;
    }
    #loading-progress {
      width: 80%;
      max-width: 300px;
    }
    ul {
      padding-left: 20px;
    }
    li {
      margin: 0.5rem 0;
    }
    h3 {
      margin-top: 1rem;
    }
    p.disclaimer-text {
      text-align: justify;
      max-width: 500px;
      margin: 0 auto;
    }
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: pointer;
      color: #007bff;
      margin-left: 5px;
      font-size: 0.9rem;
    }
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #333;
      color: white;
      text-align: center;
      border-radius: 5px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltip-text,
    .tooltip.active .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    #medrec-logo {
      height: 180px;
      width: auto;
      display: block;
      margin: 0 auto;
      position: relative;
      top: -10px;
      z-index: 1001;
    }
    /* New styles for text input */
    .text-input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      width: 100%;
    }
    textarea {
      width: 100%;
      max-width: 300px;
      height: 100px;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      resize: none;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
    }
    textarea:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    }
    
    @media print {
  footer { display: none !important; }
  /* hide everything but the results screen */
  header, button, .photo-actions, .progress-bar, #loading,
  .screen:not(#results-screen) {
    display: none !important;
  }
  #results-screen { display: block !important; }

  /* allow the table to grow and show all columns */
  #results-content {
    overflow: visible !important;
    -webkit-overflow-scrolling: auto !important;
    width: auto !important;
    margin: 0 !important;
  }
  table.changes-table {
    width: 100% !important;
    border-collapse: collapse !important;
  }
  table.changes-table th,
  table.changes-table td {
    border: 1px solid #ddd !important;
    padding: 8px !important;
  }
}

main { /* Add padding to main element */
  padding-bottom: 4rem; /* Add space at bottom before footer */
}

footer {
  text-align: center;
  padding: 1rem;
  margin-top: auto; /* Helps push footer down */
  font-size: 0.8rem;
  color: #6c757d; /* Muted grey color */
  background-color: #f4f4f4; /* Match body background */
}

footer a {
  color: #0056b3; /* Link color */
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

/* ========== highlight rows that contain a contra‑indicated med ========== */
.ci-row {
  background-color: #fffbe6;          /* pale yellow that prints as light grey */
}

  </style>

<!-- === PDF LIBRARIES === -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
<!-- === END PDF LIBRARIES === -->

</head>
<body>
  <header>
    <img src="MedRec%20Logo.png" alt="MedRec 2.0 Logo" id="medrec-logo">
    <div class="progress-bar">
      <div class="progress-line-container">
        <div class="progress-line" id="line1-2"></div>
        <div class="progress-line" id="line2-3"></div>
        <div class="progress-line" id="line3-4"></div>
      </div>
      <div class="progress-step" id="step1">1</div>
      <div class="progress-step" id="step2">2</div>
      <div class="progress-step" id="step3">3</div>
      <div class="progress-step" id="step4">4</div>
    </div>
  </header>
  <main class="main-scroll">
    <div id="error-message"></div>
    <!-- Disclaimer Screen -->
    <div id="disclaimer-screen" class="screen active">
      <h2>Disclaimer</h2>
      <div class="card">
        <p class="disclaimer-text">
          <strong>HIPAA Warning: DO NOT UPLOAD IMAGES CONTAINING IDENTIFIABLE INFORMATION.</strong> This app is intended for use by personnel authorized to handle Protected Health Information (PHI). While MedRec 2.0 is a HIPAA compliant application, users are responsible for ensuring full compliance with HIPAA regulations, including safeguarding resident/patient data and restricting access to authorized personnel only. Unauthorized disclosure of PHI may result in disciplinary action and legal consequences.
<br><br>
          <em>Note:</em> MedRec 2.0 is a support tool and does not guarantee 100% accuracy in identifying medication discrepancies. Final verification must be completed by qualified clinical personnel.
        </p>
      </div>
      <div class="disclaimer-actions">
        <button onclick="acknowledgeDisclaimer()">I Understand</button>
      </div>
    </div>
    <!-- Photo 1 Screen -->
    <div id="photo1-screen" class="screen">
      <div class="card">
        <h2>Enter Medications Before Hospital Stay</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo1-options" class="photo-actions">
          <button onclick="document.getElementById('photo1-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo1-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo1-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput1()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo1-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo1-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo1-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo1-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-upload" accept="image/*" multiple onchange="handlePhoto1(this.files)">
      <input type="file" id="photo1-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto1(this.files)">
      <input type="file" id="photo1-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto1(this.files)">
      <div id="photo1-preview" class="preview-container"></div>
      <p id="photo1-status"></p>
      <p id="photo1-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo1-next" onclick="goToPhoto2()" disabled>Next</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Photo 2 Screen -->
    <div id="photo2-screen" class="screen">
      <div class="card">
        <h2>Enter Hospital Discharge Medications</h2>
        <p class="upload-instructions">You can take a photo, upload a photo, or paste your medication list below.</p>
        <div id="initial-photo2-options" class="photo-actions">
          <button onclick="document.getElementById('photo2-capture').click()">Take Photo</button>
          <button onclick="document.getElementById('photo2-upload').click()">Upload Photo</button>
          <div class="text-input-container">
            <textarea id="photo2-text-input" placeholder="Paste your medication list here..."></textarea>
            <button onclick="handleTextInput2()">Submit List</button>
          </div>
        </div>
        <div id="additional-photo2-option" class="photo-actions" style="display: none;">
          <button onclick="document.getElementById('photo2-capture2').click()">Take Another Photo</button>
          <button onclick="document.getElementById('photo2-upload2').click()">Upload Another Photo</button>
        </div>
      </div>
      <input type="file" id="photo2-capture" accept="image/*" capture="environment" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-upload" accept="image/*" multiple onchange="handlePhoto2(this.files)">
      <input type="file" id="photo2-capture2" accept="image/*" capture="environment" multiple onchange="handleAdditionalPhoto2(this.files)">
      <input type="file" id="photo2-upload2" accept="image/*" multiple onchange="handleAdditionalPhoto2(this.files)">
      <div id="photo2-preview" class="preview-container"></div>
      <p id="photo2-status"></p>
      <p id="photo2-prompt" class="upload-prompt" style="display: none;"></p>
      <div class="photo-actions">
        <button id="photo2-compare" onclick="comparePhotos()" disabled>Compare</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
    <!-- Results Screen -->
    <div id="results-screen" class="screen">
      <h2>Comparison Results</h2>
      <p>Changes listed in <span class="critical">bold red</span> are critical medications and should be reconciled with the provider within <span class="critical">4 hours</span> of discovery.</p>
      <div class="card">
        <div id="results-content"></div>
      </div>
      <div class="photo-actions">
                    <button onclick="exportToPDF()">Export as PDF</button>
        <button onclick="printResults()">Print Results</button>
        <button onclick="startOver()">Start Over</button>
      </div>
    </div>
  </main>
<footer>
  &copy; 2025 David Gottschalk. For technical support, please contact <a href="mailto:david@med-reconciliation.com">david@med-reconciliation.com</a>.
</footer>
  <div id="loading">
    <p id="loading-text">Processing...</p>
    <progress id="loading-progress" max="100"></progress>
  </div>
  <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-functions-compat.js"></script>
<script>
const firebaseConfig = {
  apiKey: "AIzaSyBYrJPALSB45rPm5D0T29rEwCdJ5Ek24ug",
  authDomain: "medrec-solutions-cd00e.firebaseapp.com",
  projectId: "medrec-solutions-cd00e",
  storageBucket: "medrec-solutions-cd00e.appspot.com",
  messagingSenderId: "276805089930",
  appId: "1:276805089930:web:9631c7d4cf223f1666d087"
};
const app = firebase.initializeApp(firebaseConfig);
const functions = firebase.functions(app);
</script>

  <script>
    const criticalMeds = [
      'warfarin', 'coumadin', 'apixaban', 'rivaroxaban', 'dabigatran', 'edoxaban', 'heparin', 'enoxaparin',
      'clopidogrel', 'ticagrelor', 'prasugrel', 'insulin regular', 'insulin glargine', 'insulin detemir',
      'insulin lispro', 'insulin aspart', 'insulin degludec', 'glipizide', 'glyburide', 'glimepiride',
      'repaglinide', 'nateglinide', 'metformin', 'morphine', 'hydromorphone', 'oxycodone', 'fentanyl',
      'methadone', 'tramadol', 'codeine', 'buprenorphine', 'phenytoin', 'carbamazepine', 'valproic acid',
      'phenobarbital', 'lamotrigine', 'levetiracetam', 'digoxin', 'amiodarone', 'sotalol', 'diltiazem',
      'verapamil', 'metoprolol', 'atenolol', 'carvedilol', 'furosemide', 'bumetanide', 'torsemide',
      'spironolactone', 'hydrochlorothiazide', 'chlorthalidone', 'potassium chloride', 'magnesium sulfate',
      'calcium gluconate', 'calcium chloride', 'sodium bicarbonate', 'phosphate', 'hydralazine', 'clonidine',
      'isosorbide mononitrate', 'isosorbide dinitrate', 'nitroglycerin', 'haloperidol', 'risperidone',
      'olanzapine', 'quetiapine', 'aripiprazole', 'ziprasidone', 'lorazepam', 'diazepam', 'clonazepam',
      'temazepam', 'midazolam', 'zolpidem', 'prednisone', 'methylprednisolone', 'dexamethasone',
      'hydrocortisone', 'levothyroxine', 'liothyronine', 'tacrolimus', 'cyclosporine', 'mycophenolate',
      'azathioprine', 'vancomycin', 'gentamicin', 'tobramycin', 'amikacin', 'ciprofloxacin', 'levofloxacin',
      'moxifloxacin', 'azithromycin', 'clarithromycin', 'erythromycin', 'amoxicillin',
      'amoxicillin-clavulanate', 'ceftriaxone', 'cefepime', 'ceftazidime', 'cefdinir', 'cephalexin',
      'piperacillin-tazobactam', 'penicillin vk', 'dicloxacillin', 'nafcillin', 'meropenem', 'ertapenem',
      'imipenem-cilastatin', 'doxycycline', 'minocycline', 'tetracycline', 'linezolid',
      'sulfamethoxazole-trimethoprim', 'nitrofurantoin', 'metronidazole', 'clindamycin', 'fosfomycin',
      'daptomycin', 'tigecycline', 'carbidopa/levodopa', 'entacapone', 'selegiline', 'rasagiline', 'lithium',
      'theophylline', 'clozapine', 'methotrexate', 'allopurinol', 'colchicine', 'tamsulosin', 'finasteride',
      'denosumab', 'zoledronic acid', 'teriparatide', 'alendronate', 'risedronate', 'acetazolamide',
      'bethanechol', 'bethanechol chloride', 'donepezil', 'rivastigmine', 'galantamine', 'memantine',
      'naltrexone', 'naloxone', 'flumazenil', 'desmopressin', 'octreotide', 'erythropoietin', 'filgrastim',
      'calcitriol', 'ergocalciferol', 'cholecalciferol', 'pyridostigmine', 'propranolol', 'labetalol',
      'isosorbide', 'nicardipine', 'nitroprusside', 'ivabradine', 'sacubitril', 'valsartan',
      'atorvastatin', 'rosuvastatin', 'simvastatin', 'Norco', 'oxycodone/acetaminophen', 'hydrocodone/acetaminophen', 'codeine/acetaminophen', 'tramadol/acetaminophen', 'acetaminophen/caffeine/dihydrocodeine', 'aspirin/caffeine/dihydrocodeine', 'aspirin/codeine', 'ibuprofen/oxycodone', 'acetaminophen/butalbital/caffeine', 'aspirin/butalbital/caffeine', 'acetaminophen/butalbital', 'methylphenidate', 'amphetamine/dextroamphetamine', 'hydrocodone/pseudoephedrine', 'hydrocodone/chlorpheniramine', 'hydrocodone/homatropine', 'busulfan', 'doxorubicin', 'adalimumab', 'acetaminophen/isometheptene/dichloralphenazone', 'ultracet', 'percocet', 'roxicet', 'endocet', 'tylenol #3', 'zamicet', 'vicodin', 'lortab', 'panlor ss', 'trezix', 'synalgos-dc', 'empirin with codeine', 'combunox', 'fioricet', 'esgic', 'zebutal', 'fiorinal', 'bupap', 'rezira', 'tussionex', 'hycomine', 'hydromet', 'midrin','chlorpropamide', 'acarbose', 'miglitol', 'argatroban', 'bivalirudin', 'fondaparinux', 'methylergonovine', 'carboplatin', 'cyclophosphamide', 'promethazine'

    ].map(med => med.toLowerCase());

/* Drug Contraindications List */
const drugContraindications = {
  /* 1 */ "atorvastatin": [
           "tipranavir", "ritonavir", "glecaprevir", "pibrentasvir",
           "cyclosporine", "gemfibrozil"
         ],
  /* 2 */ "levothyroxine": [],
  /* 3 */ "lisinopril": [
           "aliskiren", "sacubitril"
         ],
  /* 4 */ "metformin": [],
  /* 5 */ "amlodipine": [],
  /* 6 */ "omeprazole": [
           "rilpivirine", "nelfinavir"
         ],
  /* 7 */ "simvastatin": [
           "itraconazole", "ketoconazole", "posaconazole", "voriconazole",
           "erythromycin", "clarithromycin", "telithromycin", "nelfinavir",
           "ritonavir", "boceprevir", "telaprevir", "nefazodone", "gemfibrozil",
           "cyclosporine", "danazol", "cobicistat", "lomitapide"
         ],
  /* 8 */ "hydrochlorothiazide": [
           "dofetilide", "lithium"
         ],
  /* 9 */ "gabapentin": [],
  /* 10 */ "sertraline": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine", "thioridazine"
         ],
  /* 11 */ "amoxicillin": [],
  /* 12 */ "vitamin_d": [],
  /* 13 */ "ibuprofen": [
           "aspirin", "ketorolac", "methotrexate", "pemetrexed"
         ],
  /* 14 */ "apixaban": [
           "defibrotide"
         ],
  /* 15 */ "montelukast": [],
  /* 16 */ "fluticasone": [
           "ritonavir", "ketoconazole"
         ],
  /* 17 */ "escitalopram": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine"
         ],
  /* 18 */ "rosuvastatin": [
           "cyclosporine", "gemfibrozil", "sofosbuvir_velpatasvir_voxilaprevir",
           "glecaprevir_pibrentasvir"
         ],
  /* 19 */ "pantoprazole": [
           "rilpivirine", "nelfinavir"
         ],
  /* 20 */ "trazodone": [
           "isocarboxazid", "linezoid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine",
           "saquinavir", "thioridazine"
         ],
  /* 21 */ "losartan": [
           "aliskiren"
         ],
  /* 22 */ "metoprolol": [],
  /* 23 */ "albuterol": [],
  /* 24 */ "bupropion": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 25 */ "duloxetine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine",
           "thioridazine"
         ],
  /* 26 */ "prednisone": [
           "itraconazole", "ketoconazole", "mifepristone"
         ],
  /* 27 */ "aspirin": [
           "ketorolac", "methotrexate"
         ],
  /* 28 */ "cetirizine": [
           "levocetirizine"
         ],
  /* 29 */ "azithromycin": [
           "pimozide", "dihydroergotamine", "ergotamine"
         ],
  /* 30 */ "tramadol": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 31 */ "pravastatin": [
           "gemfibrozil"
         ],
  /* 32 */ "clopidogrel": [],
  /* 33 */ "furosemide": [],
  /* 34 */ "fluoxetine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine", "thioridazine"
         ],
  /* 35 */ "citalopram": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine", "dasabuvir"
         ],
  /* 36 */ "warfarin": [
           "defibrotide", "mifepristone"
         ],
  /* 37 */ "doxycycline": [
           "acitretin", "isotretinoin", "methoxyflurane"
         ],
  /* 38 */ "tamsulosin": [],
  /* 39 */ "allopurinol": [
           "didanosine", "azathioprine", "mercaptopurine"
         ],
  /* 40 */ "carvedilol": [],
  /* 41 */ "venlafaxine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 42 */ "propranolol": [
           "thioridazine", "rizatriptan"
         ],
  /* 43 */ "spironolactone": [
           "eplerenone", "triamterene", "amiloride"
         ],
  /* 44 */ "lorazepam": [],
  /* 45 */ "clonazepam": [],
  /* 46 */ "zolpidem": [
           "alcohol"
         ],
  /* 47 */ "cyclobenzaprine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 48 */ "meloxicam": [
           "aspirin", "ketorolac"
         ],
  /* 49 */ "lamotrigine": [
           "dofetilide"
         ],
  /* 50 */ "hydrocodone_acetaminophen": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 51 */ "potassium_chloride": [
           "amiloride", "spironolactone", "triamterene", "eplerenone"
         ],
  /* 52 */ "glipizide": [
           "bosentan"
         ],
  /* 53 */ "methylphenidate": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 54 */ "finasteride": [],
  /* 55 */ "insulin_glargine": [],
  /* 56 */ "esomeprazole": [
           "rilpivirine", "nelfinavir"
         ],
  /* 57 */ "pregabalin": [],
  /* 58 */ "sildenafil": [
           "nitroglycerin", "riociguat", "vericiguat", "amyl_nitrite"
         ],
  /* 59 */ "oxycodone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine",
           "nalmefene", "naltrexone", "samidorphan"
         ],
  /* 60 */ "mirtazapine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 61 */ "alprazolam": [
           "itraconazole", "ketoconazole"
         ],
  /* 62 */ "chlorthalidone": [
           "dofetilide"
         ],
  /* 63 */ "valsartan": [
           "aliskiren", "sacubitril"
         ],
  /* 64 */ "cephalexin": [],
  /* 65 */ "buspirone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 66 */ "diclofenac": [
           "aspirin", "ketorolac"
         ],
  /* 67 */ "levetiracetam": [],
  /* 68 */ "risperidone": [],
  /* 69 */ "ramipril": [
           "aliskiren", "sacubitril"
         ],
  /* 70 */ "aripiprazole": [],
  /* 71 */ "nitroglycerin": [
           "sildenafil", "tadalafil", "vardenafil", "avanafil",
           "riociguat", "vericiguat"
         ],
  /* 72 */ "quetiapine": [
           "pimozide", "thioridazine"
         ],
  /* 73 */ "atenolol": [],
  /* 74 */ "topiramate": [],
  /* 75 */ "lovastatin": [
           "itraconazole", "ketoconazole", "posaconazole", "voriconazole",
           "erythromycin", "clarithromycin", "telithromycin", "nelfinavir",
           "ritonavir", "boceprevir", "telaprevir", "nefazodone", "gemfibrozil",
           "cyclosporine", "danazol", "cobicistat", "lomitapide"
         ],
  /* 76 */ "tiotropium": [
           "ipratropium"
         ],
  /* 77 */ "adalimumab": [
           "anakinra", "abatacept", "etanercept", "infliximab",
           "golimumab", "certolizumab_pegol"
         ],
  /* 78 */ "semaglutide": [],
  /* 79 */ "tirzepatide": [],
  /* 80 */ "ferrous_sulfate": [
           "dimercaprol"
         ],
  /* 81 */ "calcium_carbonate": [
           "ceftriaxone", "sodium_polystyrene_sulfonate"
         ],
  /* 82 */ "fish_oil": [],
  /* 83 */ "multivitamin": [
           "levodopa"
         ],
  /* 84 */ "magnesium": [
           "raltegravir", "elvitegravir", "dolutegravir", "bictegravir"
         ],
  /* 85 */ "probiotics": [],
  /* 86 */ "coenzyme_q10": [],
  /* 87 */ "melatonin": [],
  /* 88 */ "vitamin_c": [],
  /* 89 */ "vitamin_b12": [
           "chloramphenicol"
         ],
  /* 90 */ "zinc": [
           "penicillamine"
         ],
  /* 91 */ "glucosamine": [],
  /* 92 */ "turmeric": [],
  /* 93 */ "vitamin_e": [
           "warfarin", "dicumarol"
         ],
  /* 94 */ "vitamin_k": [
           "warfarin", "anisindione", "dicumarol"
         ],
  /* 95 */ "collagen": [],
  /* 96 */ "biotin": [],
  /* 97 */ "folic_acid": [
           "methotrexate", "pyrimethamine", "raltitrexed"
         ],
  /* 98 */ "cranberry_extract": [],
  /* 99 */ "ashwagandha": [],
  /* 100 */ "elderberry": [],
  /* 101 */ "benzonatate": [],
  /* 102 */ "budesonide": [
           "ketoconazole", "itraconazole", "ritonavir", "clarithromycin"
         ],
  /* 103 */ "carbidopa_levodopa": [
           "isocarboxazid", "phenelzine", "procarbazine", "tranylcypromine"
         ],
  /* 104 */ "celecoxib": [
           "ketorolac", "aspirin"
         ],
  /* 105 */ "ciprofloxacin": [
           "tizanidine", "agomelatine", "flibanserin", "lomitapide",
           "pimozide", "thioridazine"
         ],
  /* 106 */ "clonidine": [],
  /* 107 */ "donepezil": [],
  /* 108 */ "enalapril": [
           "aliskiren", "sacubitril"
         ],
  /* 109 */ "ezetimibe": [
           "cyclosporine"
         ],
  /* 110 */ "famotidine": [],
  /* 111 */ "fexofenadine": [],
  /* 112 */ "hydralazine": [],
  /* 113 */ "hydroxyzine": [
           "amifampridine", "droperidol", "pimozide", "thioridazine"
         ],
  /* 114 */ "indapamide": [
           "dofetilide", "sulpiride"
         ],
  /* 115 */ "insulin_aspart": [],
  /* 116 */ "ipratropium": [
           "tiotropium", "aclidinium", "umeclidinium", "revefenacin",
           "glycopyrrolate"
         ],
  /* 117 */ "isosorbide": [
           "sildenafil", "tadalafil", "vardenafil", "avanafil",
           "riociguat", "vericiguat"
         ],
  /* 118 */ "ketoconazole": [
           "alfuzosin", "amiodarone", "apixaban", "astemizole", "bepridil",
           "cisapride", "colchicine", "conivaptan", "dabigatran", "darifenacin",
           "disopyramide", "dofetilide", "domperidone", "dronedarone",
           "eletriptan", "eplerenone", "ergotamine", "dihydroergotamine",
           "ergometrine", "methylergometrine", "felodipine", "fesoterodine",
           "flibanserin", "halofantrine", "irinotecan", "isavuconazonium",
           "ivabradine", "levacetylmethadol", "lomitapide", "loperamide",
           "lovastatin", "lurasidone", "methadone", "mifepristone",
           "mizolastine", "naloxegol", "nisoldipine", "oral_midazolam",
           "pimozide", "quinidine", "ranolazine", "rivaroxaban", "salmeterol",
           "sertindole", "simvastatin", "sirolimus", "solifenacin",
           "tacrolimus", "terfenadine", "ticagrelor", "tolvaptan",
           "triazolam", "udenafil", "vardenafil", "vincristine", "voclosporin"
         ],
  /* 119 */ "liraglutide": [],
  /* 120 */ "loratadine": [],
  /* 121 */ "memantine": [],
  /* 122 */ "methocarbamol": [],
  /* 123 */ "metronidazole": [
           "disulfiram", "alcohol", "busulfan"
         ],
  /* 124 */ "mupirocin": [],
  /* 125 */ "nifedipine": [
           "rifampin"
         ],
  /* 126 */ "olanzapine": [
           "samidorphan", "thioridazine", "mesoridazine"
         ],
  /* 127 */ "ondansetron": [
           "apomorphine", "dronedarone", "pimozide", "thioridazine"
         ],
  /* 128 */ "oxybutynin": [],
  /* 129 */ "paroxetine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "pimozide", "procarbazine", "rasagiline", "selegiline",
           "thioridazine", "tranylcypromine"
         ],
  /* 130 */ "pioglitazone": [],
  /* 131 */ "promethazine": [
           "amifampridine", "bepridil", "cisapride", "dronedarone",
           "levomethadyl", "mesoridazine", "pimozide", "piperaquine",
           "sparfloxacin", "terfenadine", "thioridazine", "ziprasidone"
         ],
  /* 132 */ "ranitidine": [],
  /* 133 */ "ropinirole": [
           "sulpiride", "metoclopramide", "thioridazine"
         ],
  /* 134 */ "sotalol": [
           "amifampridine", "amisulpride", "anagrelide", "arsenic_trioxide",
           "astemizole", "azithromycin", "bepridil", "chloroquine",
           "chlorpromazine", "ciprofloxacin", "cisapride", "citalopram",
           "clarithromycin", "clozapine", "crizotinib", "dabrafenib",
           "dasatinib", "degarelix", "delamanid", "disopyramide",
           "dofetilide", "dolasetron", "domperidone", "donepezil",
           "dronedarone", "droperidol", "eribulin", "erythromycin",
           "escitalopram", "famotidine", "fingolimod", "flecainide",
           "fluconazole", "fluoxetine", "foscarnet", "fosphenytoin",
           "galantamine", "gatifloxacin", "gemifloxacin", "glasdegib",
           "granisetron", "halofantrine", "haloperidol", "hydroxychloroquine",
           "hydroxyzine", "ibutilide", "iloperidone", "imipramine",
           "inotuzumab_ozogamicin", "itraconazole", "ivabradine", "ivosidenib",
           "ketoconazole", "lapatinib", "lenvatinib", "leuprolide",
           "levofloxacin", "lithium", "lofexidine", "lumefantrine",
           "macimorelin", "mefloquine", "mesoridazine", "methadone",
           "metronidazole", "mifepristone", "mirtazapine", "mizolastine",
           "mobocertinib", "moxifloxacin", "nilotinib", "norfloxacin",
           "octreotide", "ofloxacin", "olanzapine", "ondansetron",
           "osimertinib", "oxaliplatin", "paliperidone", "panobinostat",
           "papaverine", "paroxetine", "pasireotide", "pazopanib",
           "pentamidine", "perphenazine", "pimavanserin", "pimozide",
           "piperaquine", "pitolisant", "ponesimod", "posaconazole",
           "probucol", "procainamide", "prochlorperazine", "promazine",
           "promethazine", "propafenone", "protriptyline", "quetiapine",
           "quinidine", "quinine", "ranolazine", "relugolix", "ribociclib",
           "risperidone", "ritonavir", "saquinavir", "selpercatinib",
           "sertindole", "sertraline", "sevoflurane", "siponimod",
           "sodium_phosphate", "solifenacin", "sorafenib", "sparfloxacin",
           "sulpiride", "sunitinib", "tacrolimus", "tamoxifen", "telavancin",
           "telithromycin", "terfenadine", "tetrabenazine", "thioridazine",
           "toremifene", "trazodone", "triclabendazole", "trimethoprim",
           "trimipramine", "vandetanib", "vardenafil", "vemurafenib",
           "venlafaxine", "vinflunine", "voriconazole", "vorinostat",
           "ziprasidone", "zolmitriptan", "zuclopenthixol"
         ],
  /* 135 */ "sulfamethoxazole_trimethoprim": [
           "dofetilide", "methenamine", "leucovorin"
         ],
  /* 136 */ "terazosin": [
           "sildenafil", "tadalafil", "vardenafil", "avanafil"
         ],
  /* 137 */ "timolol": [],
  /* 138 */ "tolterodine": [
           "clarithromycin", "itraconazole", "ketoconazole", "ritonavir"
         ],
  /* 139 */ "triamterene": [
           "amiloride", "spironolactone", "eplerenone", "potassium_supplements"
         ],
  /* 140 */ "valacyclovir": [],
  /* 141 */ "verapamil": [
           "atazanavir", "cisapride", "colchicine", "dabigatran",
           "dofetilide", "dronedarone", "eletriptan", "eplerenone",
           "ergotamine", "flibanserin", "ivabradine", "lomitapide",
           "lovastatin", "lurasidone", "naloxegol", "ranolazine",
           "rivaroxaban", "simvastatin", "sirolimus", "tacrolimus",
           "tolvaptan", "udenafil", "voclosporin"
         ],
  /* 142 */ "acyclovir": [],
  /* 143 */ "amiodarone": [
           "atazanavir", "bepridil", "cisapride", "cobicistat",
           "colchicine", "darunavir", "dasabuvir", "digitoxin",
           "disopyramide", "dofetilide", "domperidone", "dronedarone",
           "eliglustat", "elvitegravir", "fingolimod", "flecainide",
           "fluconazole", "fosamprenavir", "gemifloxacin", "halofantrine",
           "ibutilide", "idelalisib", "indinavir", "itraconazole",
           "ivabradine", "ketoconazole", "ledipasvir", "lenvatinib",
           "lopinavir_ritonavir", "lorlatinib", "lumefantrine",
           "mavacamten", "mefloquine", "mesoridazine", "mifepristone",
           "moxifloxacin", "nelfinavir", "nilotinib", "ombitasvir_paritaprevir_ritonavir",
           "pacritinib", "pentamidine", "pimozide", "piperaquine",
           "posaconazole", "procainamide", "propafenone", "quetiapine",
           "quinidine", "ranolazine", "ribociclib", "ritonavir",
           "saquinavir", "simeprevir", "simvastatin", "sofosbuvir",
           "sorafenib", "sotalol", "sparfloxacin", "sulpiride",
           "tacrolimus", "tamoxifen", "telaprevir", "telithromycin",
           "terfenadine", "tetrabenazine", "thioridazine", "tipranavir",
           "toremifene", "trazodone", "vandetanib", "vemurafenib",
           "venetoclax", "vinflunine", "voriconazole", "ziprasidone"
         ],
  /* 144 */ "baclofen": [],
  /* 145 */ "betamethasone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 146 */ "brimonidine": [
           "isocarboxazid", "phenelzine", "procarbazine", "rasagiline",
           "selegiline", "tranylcypromine"
         ],
  /* 147 */ "candesartan": [
           "aliskiren"
         ],
  /* 148 */ "chlorhexidine": [],
  /* 149 */ "colchicine": [
           "atazanavir", "clarithromycin", "cyclosporine", "darunavir",
           "elvitegravir_cobicistat", "fluconazole", "fosamprenavir",
           "idelalisib", "indinavir", "itraconazole", "ketoconazole",
           "lopinavir_ritonavir", "mifepristone", "nelfinavir",
           "ombitasvir_paritaprevir_ritonavir_dasabuvir", "posaconazole",
           "ranolazine", "ritonavir", "saquinavir", "telaprevir",
           "telithromycin", "tipranavir", "verapamil", "voriconazole"
         ],
  /* 150 */ "dabigatran": [
           "rifampin", "tipranavir", "dronedarone", "ketoconazole",
           "itraconazole", "cyclosporine"
         ],
  /* 151 */ "desvenlafaxine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 152 */ "digoxin": [],
  /* 153 */ "diltiazem": [
           "cisapride", "colchicine", "dabigatran", "dofetilide",
           "dronedarone", "eletriptan", "eplerenone", "ergotamine",
           "flibanserin", "ivabradine", "lomitapide", "lovastatin",
           "lurasidone", "naloxegol", "pimozide", "rivaroxaban",
           "simvastatin", "sirolimus", "tacrolimus", "tolvaptan",
           "udenafil", "voclosporin"
         ],
  /* 154 */ "divalproex": [
           "meropenem"
         ],
  /* 155 */ "dorzolamide": [],
  /* 156 */ "dronedarone": [
           "amifampridine", "amiodarone", "apomorphine", "arsenic_trioxide",
           "asenapine", "astemizole", "atazanavir", "bepridil", "boceprevir",
           "chloroquine", "chlorpromazine", "ciprofloxacin", "cisapride",
           "citalopram", "clarithromycin", "clofazimine", "clomipramine",
           "clozapine", "cobicistat", "colchicine", "conivaptan",
           "crizotinib", "cyclosporine", "dabigatran", "darunavir",
           "dasatinib", "degarelix", "delamanid", "desipramine",
           "dibenzepin", "disopyramide", "dofetilide", "dolasetron",
           "domperidone", "donepezil", "droperidol", "efavirenz",
           "eliglustat", "encorafenib", "entrectinib", "eribulin",
           "erythromycin", "escitalopram", "famotidine", "fexinidazole",
           "fingolimod", "flecainide", "fluconazole", "fluoxetine",
           "formoterol", "foscarnet", "fostemsavir", "galantamine",
           "gatifloxacin", "gemifloxacin", "gepirone", "givinostat",
           "glasdegib", "granisetron", "halofantrine", "haloperidol",
           "hydroxychloroquine", "hydroxyzine", "ibutilide", "idelalisib",
           "iloperidone", "imipramine", "indinavir", "inotuzumab_ozogamicin",
           "itraconazole", "ivabradine", "ivosidenib", "ketoconazole",
           "lapatinib", "lenvatinib", "leuprolide", "levofloxacin",
           "levoketoconazole", "lithium", "lofepramine", "lopinavir",
           "lovastatin", "lumefantrine", "lurasidone", "macimorelin",
           "mefloquine", "mesoridazine", "methadone", "metronidazole",
           "mifepristone", "mirtazapine", "mizolastine", "mobocertinib",
           "moxifloxacin", "nafarelin", "nelfinavir", "nefazodone",
           "nilotinib", "norfloxacin", "nortriptyline", "octreotide",
           "ofloxacin", "olanzapine", "ondansetron", "osilodrostat",
           "osimertinib", "ozanimod", "paliperidone", "panobinostat",
           "papaverine", "paroxetine", "pasireotide", "pazopanib",
           "pentamidine", "perphenazine", "phenobarbital", "pimavanserin",
           "pimozide", "piperaquine", "pipothiazine", "pitolisant",
           "ponesimod", "posaconazole", "primidone", "probucol",
           "procainamide", "prochlorperazine", "promazine", "promethazine",
           "propafenone", "protriptyline", "quetiapine", "quinidine",
           "quinine", "ranolazine", "relugolix", "ribociclib", "rifabutin",
           "rifampin", "rifapentine", "risperidone", "ritonavir",
           "saquinavir", "selpercatinib", "sertindole", "sertraline",
           "sevoflurane", "simeprevir", "simvastatin", "siponimod",
           "sirolimus", "sodium_phosphate", "solifenacin", "sorafenib",
           "sotalol", "sparfloxacin", "sulpiride", "sunitinib", "tacrolimus",
           "tamoxifen", "telaprevir", "telavancin", "telithromycin",
           "terfenadine", "tetrabenazine", "thioridazine", "toremifene",
           "trazodone", "triclabendazole", "trimipramine", "triptorelin",
           "vandetanib", "vardenafil", "vemurafenib", "venlafaxine",
           "verapamil", "vinflunine", "voclosporin", "voriconazole",
           "vorinostat", "ziprasidone", "zolmitriptan", "zuclopenthixol"
         ],
  /* 157 */ "eletriptan": [
           "atazanavir", "clarithromycin", "cobicistat", "darunavir",
           "diltiazem", "elvitegravir", "ergotamine", "fosamprenavir",
           "idelalisib", "indinavir", "itraconazole", "ketoconazole",
           "lopinavir", "nefazodone", "nelfinavir", "posaconazole",
           "ritonavir", "saquinavir", "telaprevir", "telithromycin",
           "tipranavir", "troleandomycin", "verapamil", "voriconazole"
         ],
  /* 158 */ "empagliflozin": [],
  /* 159 */ "enoxaparin": [
           "defibrotide"
         ],
  /* 160 */ "erythromycin": [
           "alfuzosin", "astemizole", "cisapride", "colchicine",
           "dihydroergotamine", "domperidone", "dronedarone", "eletriptan",
           "eplerenone", "ergotamine", "flibanserin", "ivabradine",
           "lomitapide", "lovastatin", "lurasidone", "mevastatin",
           "mifepristone", "naloxegol", "nisoldipine", "oral_midazolam",
           "pimozide", "ranolazine", "rivaroxaban", "saquinavir",
           "silodosin", "simvastatin", "suvorexant", "tasimelteon",
           "terfenadine", "ticagrelor", "tolvaptan", "triazolam",
           "udenafil", "vardenafil", "voclosporin"
         ],
  /* 161 */ "estradiol": [
           "anastrozole", "exemestane", "letrozole", "ospemifene",
           "tamoxifen"
         ],
  /* 162 */ "etanercept": [
           "anakinra", "abatacept", "adalimumab", "infliximab"
         ],
  /* 163 */ "exenatide": [],
  /* 164 */ "fenofibrate": [
           "simvastatin", "rosuvastatin"
         ],
  /* 165 */ "fluconazole": [
           "alfuzosin", "astemizole", "bepridil", "cisapride",
           "colchicine", "darunavir", "dofetilide", "domperidone",
           "dronedarone", "eletriptan", "eliglustat", "eplerenone",
           "ergotamine", "dihydroergotamine", "erythromycin",
           "fesoterodine", "flibanserin", "halofantrine", "irinotecan",
           "isavuconazonium", "ivabradine", "levacetylmethadol",
           "lomitapide", "lopinavir", "lovastatin", "lurasidone",
           "methadone", "mifepristone", "mizolastine", "naloxegol",
           "nisoldipine", "oral_midazolam", "pimozide", "quinidine",
           "ranolazine", "rivaroxaban", "saquinavir", "sertindole",
           "silodosin", "simvastatin", "sirolimus", "solifenacin",
           "tacrolimus", "terfenadine", "thioridazine", "ticagrelor",
           "tipranavir", "tolvaptan", "triazolam", "udenafil",
           "vardenafil", "venetoclax", "vincristine", "voclosporin",
           "voriconazole", "ziprasidone"
         ],
  /* 166 */ "fluvoxamine": [
           "agomelatine", "alosetron", "astemizole", "cisapride",
           "dronedarone", "eplerenone", "eliglustat", "frovatriptan",
           "isocarboxazid", "ivabradine", "linezolid", "lomitapide",
           "lurasidone", "mesoridazine", "methylene_blue", "mevastatin",
           "mizolastine", "nelfinavir", "phenelzine", "pimozide",
           "procarbazine", "ramelteon", "rasagiline", "ropivacaine",
           "saquinavir", "selegiline", "silodosin", "simvastatin",
           "tacrine", "terfenadine", "theophylline", "thioridazine",
           "tizanidine", "tolvaptan", "tranylcypromine", "triazolam",
           "udenafil", "ziprasidone"
         ],
  /* 167 */ "folic_acid": [
           "methotrexate", "pyrimethamine", "raltitrexed"
         ],
  /* 168 */ "gemfibrozil": [
           "atorvastatin", "cerivastatin", "dasabuvir", "ezetimibe",
           "fluvastatin", "lovastatin", "mevastatin", "pitavastatin",
           "pravastatin", "repaglinide", "rosuvastatin", "selexipag",
           "simvastatin"
         ],
  /* 169 */ "glimepiride": [
           "bosentan"
         ],
  /* 170 */ "glyburide": [
           "bosentan"
         ],
  /* 171 */ "heparin": [
           "defibrotide"
         ],
  /* 172 */ "hydrocortisone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 173 */ "imatinib": [
           "alfuzosin", "astemizole", "bepridil", "cisapride",
           "colchicine", "conivaptan", "darunavir", "dihydroergotamine",
           "domperidone", "dronedarone", "eletriptan", "eplerenone",
           "ergotamine", "fesoterodine", "flibanserin", "halofantrine",
           "irinotecan", "isavuconazonium", "ivabradine", "ketoconazole",
           "levacetylmethadol", "lomitapide", "lovastatin", "lurasidone",
           "methadone", "mifepristone", "mizolastine", "naloxegol",
           "nisoldipine", "oral_midazolam", "pimozide", "quinidine",
           "ranolazine", "rivaroxaban", "salmeterol", "sertindole",
           "silodosin", "simvastatin", "sirolimus", "solifenacin",
           "tacrolimus", "terfenadine", "thioridazine", "ticagrelor",
           "tolterodine", "tolvaptan", "triazolam", "udenafil",
           "vardenafil", "venetoclax", "vincristine", "voclosporin",
           "voriconazole", "ziprasidone"
         ],
  /* 174 */ "irbesartan": [
           "aliskiren"
         ],
  /* 175 */ "labetalol": [
           "thioridazine"
         ],
  /* 176 */ "latanoprost": [],
  /* 177 */ "linagliptin": [],
  /* 178 */ "lisdexamfetamine": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 179 */ "lithium": [
           "sodium_polystyrene_sulfonate", "thioridazine", "ziprasidone"
         ],
  /* 180 */ "loperamide": [
           "eluxadoline", "gemfibrozil", "itraconazole", "ketoconazole",
           "ritonavir", "saquinavir", "tipranavir"
         ],
  /* 181 */ "meclizine": [
           "potassium_chloride"
         ],
  /* 182 */ "methotrexate": [
           "acitretin", "aspirin", "probenecid", "co_trimoxazole",
           "nitrous_oxide"
         ],
  /* 183 */ "methylprednisolone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 184 */ "minocycline": [
           "acitretin", "isotretinoin", "methoxyflurane", "penicillin"
         ],
  /* 185 */ "mometasone": [
           "ritonavir", "ketoconazole"
         ],
  /* 186 */ "morphine": [
           "isocarboxazid", "linezolid", "methylene_blue", "nalmefene",
           "naltrexone", "phenelzine", "procarbazine", "rasagiline",
           "selegiline", "samidorphan", "tranylcypromine"
         ],
  /* 187 */ "mycophenolate": [
           "azathioprine", "sevelamer", "cholestyramine"
         ],
  /* 188 */ "naproxen": [
           "aspirin", "ketorolac", "methotrexate", "pemetrexed"
         ],
  /* 189 */ "nebivolol": [
           "thioridazine"
         ],
  /* 190 */ "nortriptyline": [
           "cisapride", "dronedarone", "isocarboxazid", "linezolid",
           "mesoridazine", "methylene_blue", "phenelzine", "pimozide",
           "procarbazine", "rasagiline", "safinamide", "selegiline",
           "thioridazine", "tranylcypromine"
         ],
  /* 191 */ "olmesartan": [
           "aliskiren"
         ],
  /* 192 */ "oseltamivir": [],
  /* 193 */ "oxcarbazepine": [
           "eslicarbazepine"
         ],
  /* 194 */ "phenazopyridine": [],
  /* 195 */ "phenytoin": [
           "delavirdine", "rilpivirine", "doravirine", "isavuconazonium",
           "praziquantel", "voriconazole"
         ],
  /* 196 */ "prazosin": [
           "riociguat", "sildenafil", "tadalafil", "vardenafil", "avanafil"
         ],
  /* 197 */ "prochlorperazine": [
           "amifampridine", "astemizole", "bepridil", "cisapride",
           "dronedarone", "fluoxetine", "levomethadyl", "mesoridazine",
           "metrizamide", "paroxetine", "pimozide", "piperaquine",
           "propafenone", "quinidine", "saquinavir", "sparfloxacin",
           "terfenadine", "thioridazine", "toremifene", "ziprasidone"
         ],
  /* 198 */ "propofol": [],
  /* 199 */ "raloxifene": [
           "cholestyramine"
         ],
  /* 200 */ "rivaroxaban": [
           "atazanavir", "carbamazepine", "clarithromycin", "cobicistat",
           "conivaptan", "darunavir", "defibrotide", "elvitegravir",
           "enzalutamide", "fosamprenavir", "idelalisib", "indinavir",
           "itraconazole", "ketoconazole", "lopinavir", "lumacaftor",
           "mifepristone", "mitotane", "nelfinavir", "nefazodone",
           "ombitasvir_paritaprevir_ritonavir_dasabuvir", "phenobarbital",
           "phenytoin", "posaconazole", "primidone", "rifampin",
           "rifabutin", "rifapentine", "ritonavir", "saquinavir",
           "telaprevir", "tipranavir", "troleandomycin", "voriconazole"
         ],
  /* 201 */ "rizatriptan": [
           "ergotamine", "isocarboxazid", "linezolid", "methylene_blue",
           "phenelzine", "procarbazine", "propranolol", "rasagiline",
           "selegiline", "tranylcypromine"
         ],
  /* 202 */ "salmeterol": [
           "atazanavir", "clarithromycin", "cobicistat", "darunavir",
           "elvitegravir", "fosamprenavir", "idelalisib", "indinavir",
           "itraconazole", "ketoconazole", "lopinavir", "nefazodone",
           "nelfinavir", "posaconazole", "ritonavir", "saquinavir",
           "telaprevir", "telithromycin", "tipranavir", "troleandomycin",
           "voriconazole"
         ],
  /* 203 */ "saxagliptin": [],
  /* 204 */ "sitagliptin": [],
  /* 205 */ "sumatriptan": [
           "ergotamine", "isocarboxazid", "linezolid", "methylene_blue",
           "phenelzine", "procarbazine", "rasagiline", "selegiline",
           "tranylcypromine"
         ],
  /* 206 */ "tacrolimus": [
           "astemizole", "cisapride", "cyclosporine", "dronedarone",
           "fluconazole", "itraconazole", "ketoconazole", "mifepristone",
           "pimozide", "posaconazole", "ritonavir", "terfenadine",
           "thioridazine", "tipranavir", "voriconazole", "ziprasidone"
         ],
  /* 207 */ "telmisartan": [
           "aliskiren"
         ],
  /* 208 */ "temazepam": [
           "sodium_oxybate"
         ],
  /* 209 */ "terbinafine": [
           "eliglustat", "flibanserin", "pimozide", "tamoxifen",
           "thioridazine"
         ],
  /* 210 */ "testosterone": [],
  /* 211 */ "tizanidine": [
           "ciprofloxacin", "fluvoxamine", "acyclovir"
         ],
  /* 212 */ "torsemide": [],
  /* 213 */ "trandolapril": [
           "aliskiren", "sacubitril"
         ],
  /* 214 */ "triamcinolone": [
           "itraconazole", "ketoconazole", "mifepristone", "ritonavir"
         ],
  /* 215 */ "valproic_acid": [
           "meropenem"
         ],
  /* 216 */ "vardenafil": [
           "amyl_nitrite", "atazanavir", "boceprevir", "cobicistat",
           "darunavir", "elvitegravir", "fosamprenavir", "idelalisib",
           "indinavir", "isosorbide_dinitrate", "isosorbide_mononitrate",
           "itraconazole", "ketoconazole", "lopinavir", "mifepristone",
           "nelfinavir", "nitroglycerin", "posaconazole", "riociguat",
           "ritonavir", "saquinavir", "telaprevir", "tipranavir",
           "vericiguat", "voriconazole"
         ],
  /* 217 */ "vilazodone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 218 */ "voriconazole": [
           "alfuzosin", "aprepitant", "astemizole", "atorvastatin",
           "avanafil", "barbiturates", "bosutinib", "bromocriptine",
           "carbamazepine", "cisapride", "colchicine", "conivaptan",
           "dabrafenib", "darunavir", "domperidone", "dronedarone",
           "efavirenz", "eletriptan", "eliglustat", "encorafenib",
           "entrectinib", "eplerenone", "ergotamine", "dihydroergotamine",
           "eslicarbazepine", "estazolam", "everolimus", "fesoterodine",
           "flibanserin", "fluconazole", "fosamprenavir", "fostamatinib",
           "glasdegib", "halofantrine", "hydroxyzine", "idelalisib",
           "indinavir", "irinotecan", "isavuconazonium", "isoniazid",
           "ivabradine", "ivacaftor", "ivosidenib", "lapatinib",
           "levacetylmethadol", "lomitapide", "lopinavir", "lorlatinib",
           "lovastatin", "lumacaftor", "lurasidone", "mavacamten",
           "mefloquine", "mesoridazine", "methadone", "mifepristone",
           "mitotane", "mizolastine", "mobocertinib", "naloxegol",
           "nelfinavir", "neratinib", "nilotinib", "nisoldipine",
           "olaparib", "omaveloxolone", "oral_midazolam", "osilodrostat",
           "osimertinib", "oxcarbazepine", "palbociclib", "panobinostat",
           "pazopanib", "phenytoin", "pimavanserin", "pimozide",
           "piperaquine", "pitavastatin", "pralsetinib", "quetiapine",
           "quinidine", "ranolazine", "regorafenib", "repotrectinib",
           "ribociclib", "rifabutin", "rifampin", "rimegepant",
           "ritonavir", "rivaroxaban", "romidepsin", "rosuvastatin",
           "salmeterol", "saquinavir", "selumetinib", "sertindole",
           "silodosin", "simeprevir", "simvastatin", "sirolimus",
           "sonidegib", "sotorasib", "sunitinib", "suvorexant",
           "tacrolimus", "tadalafil", "tamoxifen", "tasimelteon",
           "tazemetostat", "terfenadine", "tetrabenazine", "thioridazine",
           "ticagrelor", "tipranavir", "tolterodine", "tolvaptan",
           "trabectedin", "trazodone", "triazolam", "ubrogepant",
           "udenafil", "ulipristal", "vandetanib", "vardenafil",
           "vemurafenib", "venetoclax", "vincristine", "vinflunine",
           "voclosporin", "ziprasidone", "zolpidem"
         ],
  /* 219 */ "zaleplon": [
           "sodium_oxybate"
         ],
  /* 220 */ "zonisamide": [
           "topiramate"
         ],
  /* 221 */ "acetaminophen": [],
  /* 222 */ "alendronate": [],
  /* 223 */ "anastrozole": [
           "estradiol", "tamoxifen", "raloxifene"
         ],
  /* 224 */ "azathioprine": [
           "febuxostat", "allopurinol"
         ],
  /* 225 */ "benazepril": [
           "aliskiren", "sacubitril"
         ],
  /* 226 */ "bimatoprost": [],
  /* 227 */ "bisoprolol": [
           "thioridazine"
         ],
  /* 228 */ "buprenorphine": [
           "nalmefene", "naltrexone", "samidorphan"
         ],
  /* 229 */ "cholecalciferol": [],
  /* 230 */ "cimetidine": [
           "astemizole", "cisapride", "dofetilide", "eliglustat",
           "flibanserin", "lomitapide", "pimozide", "terfenadine",
           "thioridazine"
         ],
  /* 231 */ "clarithromycin": [
           "alfuzosin", "astemizole", "cisapride", "colchicine",
           "dihydroergotamine", "domperidone", "dronedarone", "eletriptan",
           "eplerenone", "ergotamine", "fesoterodine", "flibanserin",
           "ivabradine", "levacetylmethadol", "lomitapide", "lovastatin",
           "lurasidone", "mevastatin", "mifepristone", "naloxegol",
           "nisoldipine", "oral_midazolam", "pimozide", "ranolazine",
           "rivaroxaban", "saquinavir", "salmeterol", "silodosin",
           "simvastatin", "suvorexant", "tacrolimus", "tasimelteon",
           "terfenadine", "thioridazine", "ticagrelor", "tolterodine",
           "tolvaptan", "triazolam", "udenafil", "vardenafil",
           "venetoclax", "voclosporin"
         ],
  /* 232 */ "clindamycin": [],
  /* 233 */ "clobetasol": [],
  /* 234 */ "clozapine": [
           "amifampridine", "bepridil", "cisapride", "dronedarone",
           "fluoxetine", "fluvoxamine", "levomethadyl", "mesoridazine",
           "metoclopramide", "paroxetine", "pimozide", "piperaquine",
           "saquinavir", "sertraline", "sparfloxacin", "terfenadine",
           "thioridazine", "ziprasidone"
         ],
  /* 235 */ "codeine": [
           "isocarboxazid", "linezolid", "methylene_blue", "nalmefene",
           "naltrexone", "phenelzine", "procarbazine", "rasagiline",
           "selegiline", "samidorphan", "tranylcypromine"
         ],
  /* 236 */ "dexamethasone": [
           "desmopressin", "itraconazole", "ketoconazole", "mifepristone",
           "ritonavir", "praziquantel", "rilpivirine"
         ],
  /* 237 */ "diazepam": [
           "sodium_oxybate"
         ],
  /* 238 */ "docusate": [
           "mineral_oil"
         ],
  /* 239 */ "entacapone": [
           "isocarboxazid", "linezolid", "methylene_blue", "phenelzine",
           "procarbazine", "rasagiline", "selegiline", "tranylcypromine"
         ],
  /* 240 */ "eplerenone": [
           "clarithromycin", "itraconazole", "ketoconazole", "nefazodone",
           "nelfinavir", "posaconazole", "ritonavir", "saquinavir",
           "telithromycin", "voriconazole", "potassium_supplements"
         ],
  /* 241 */ "felodipine": [
           "carbamazepine", "clarithromycin", "erythromycin", "itraconazole",
           "ketoconazole", "nefazodone", "phenobarbital", "phenytoin",
           "rifampin", "ritonavir", "telithromycin"
         ],
  /* 242 */ "flurazepam": [
           "sodium_oxybate", "itraconazole", "ketoconazole", "ritonavir"
         ],
  /* 243 */ "fosfomycin": [],
  /* 244 */ "haloperidol": [
           "amifampridine", "astemizole", "bepridil", "cisapride",
           "dronedarone", "fluoxetine", "itraconazole", "ketoconazole",
           "levomethadyl", "mesoridazine", "metoclopramide", "paroxetine",
           "pimozide", "piperaquine", "probucol", "propafenone",
           "quinidine", "saquinavir", "sertindole", "sparfloxacin",
           "terfenadine", "thioridazine", "toremifene", "ziprasidone"
         ],
  /* 245 */ "hydroxychloroquine": [
           "amifampridine", "dronedarone", "fingolimod", "halofantrine",
           "mefloquine", "pimozide", "saquinavir", "tamoxifen",
           "thioridazine", "ziprasidone"
         ],
  /* 246 */ "infliximab": [
           "anakinra", "abatacept", "adalimumab", "etanercept"
         ],
  /* 247 */ "isoniazid": [
           "disulfiram", "carbamazepine", "phenytoin", "valproic_acid"
         ],
  /* 248 */ "ketorolac": [
           "aspirin", "celecoxib", "diclofenac", "diflunisal", "etodolac",
           "fenoprofen", "flurbiprofen", "ibuprofen", "indomethacin",
           "ketoprofen", "meclofenamate", "mefenamic_acid", "meloxicam",
           "nabumetone", "naproxen", "oxaprozin", "pentoxifylline",
           "piroxicam", "probenecid", "sulindac", "tolmetin"
         ],
  /* 249 */ "letrozole": [
           "estradiol", "tamoxifen", "raloxifene"
         ],
  /* 250 */ "lidocaine": [
           "amiodarone", "dofetilide", "dronedarone", "propafenone",
           "quinidine", "tocainide"
         ]
};

function canonicalDrugKey(name) {
  return (name || '').toLowerCase().replace(/[^a-z0-9]/g,'').trim();
}

function hasContra(orderObj, wholeList = []) {
  /* real check can be added later */
  return false;
}

    const commonMedications = [
      { generic: "hydrocodone/acetaminophen", brands: ["Norco", "Vicodin", "Lortab", "Zamicet"] },
      { generic: "oxycodone/acetaminophen",  brands: ["Percocet", "Xartemis XR", "Roxicet", "Endocet"] },
               { generic: "codeine/acetaminophen",     brands: ["Tylenol #3"] },
               { generic: "tramadol/acetaminophen",    brands: ["Ultracet"] },
               { generic: "acetaminophen/caffeine/dihydrocodeine", brands: ["Panlor SS", "Trezix"] },
               { generic: "aspirin/caffeine/dihydrocodeine",       brands: ["Synalgos-DC"] },
               { generic: "aspirin/codeine",            brands: ["Empirin with codeine"] },
               { generic: "acetaminophen/butalbital/caffeine", brands: ["Fioricet", "Esgic", "Zebutal"] },
               { generic: "aspirin/butalbital/caffeine", brands: ["Fiorinal"] },
               { generic: "acetaminophen/butalbital",   brands: ["Bupap"] },
               { generic: "hydrocodone/pseudoephedrine", brands: ["Rezira"] },
               { generic: "hydrocodone/chlorpheniramine", brands: ["Tussionex", "Hycomine"] },
               { generic: "hydrocodone/homatropine",    brands: ["Hydromet"] },
               { generic: "busulfan",                   brands: ["Myleran"] },
               { generic: "acetaminophen/isometheptene/dichloralphenazone", brands: ["Midrin"] },
               { generic: "ibuprofen/oxycodone",        brands: ["Combunox"] },
      { generic: "acetaminophen", brands: ["Tylenol"] },
      { generic: "albuterol", brands: ["Ventolin", "ProAir", "Proventil", "salbutamol"] },
      { generic: "allopurinol", brands: ["Zyloprim"] },
      { generic: "alprazolam", brands: ["Xanax"] },
      { generic: "amlodipine", brands: ["Norvasc"] },
      { generic: "amoxicillin", brands: ["Amoxil", "Trimox"] },
      { generic: "aspirin", brands: ["Bayer", "Ecotrin"] },
      { generic: "atenolol", brands: ["Tenormin"] },
      { generic: "atorvastatin", brands: ["Lipitor"] },
      { generic: "azithromycin", brands: ["Zithromax", "Z-Pak"] },
      { generic: "bisoprolol", brands: ["Zebeta"] },
      { generic: "budesonide", brands: ["Pulmicort", "Rhinocort"] },
              { generic: "budesonide/formoterol", brands: ["Symbicort"] },
               {   generic: "calcium gluconate",  brands: [] },
               {   generic: "calcium chloride",   brands: [] },
               {   generic: "calcium carbonate",  brands: [] },
               {   generic: "calcium citrate",    brands: [] }, 
      { generic: "cefuroxime", brands: ["Ceftin", "Zinacef"] },
      { generic: "cephalexin", brands: ["Keflex"] },
      { generic: "cetirizine", brands: ["Zyrtec"] },
              { generic: "loratadine", brands: ["Claritin"] },
      { generic: "ciprofloxacin", brands: ["Cipro"] },
      { generic: "citalopram", brands: ["Celexa"] },
      { generic: "clindamycin", brands: ["Cleocin"] },
      { generic: "clonazepam", brands: ["Klonopin"] },
      { generic: "clopidogrel", brands: ["Plavix"] },
      { generic: "cyclobenzaprine", brands: ["Flexeril"] },
      { generic: "digoxin", brands: ["Lanoxin"] },
      { generic: "doxycycline", brands: ["Vibramycin"] },
      { generic: "duloxetine", brands: ["Cymbalta"] },
      { generic: "enalapril", brands: ["Vasotec"] },
      { generic: "escitalopram", brands: ["Lexapro"] },
      { generic: "esomeprazole", brands: ["Nexium"] },
      { generic: "ferrous sulfate", brands: [] },
      { generic: "fluoxetine", brands: ["Prozac"] },
      { generic: "fluticasone", brands: ["Flonase", "Flovent"] },
      { generic: "furosemide", brands: ["Lasix"] },
      { generic: "gabapentin", brands: ["Neurontin"] },
      { generic: "glipizide", brands: ["Glucotrol"] },
      { generic: "glyburide", brands: ["Diabeta", "Micronase"] },
      { generic: "hydralazine", brands: ["Apresoline"] },
      { generic: "hydrochlorothiazide", brands: ["Microzide", "HCTZ"] },
      { generic: "ibuprofen", brands: ["Advil", "Motrin"] },
              { generic: "insulin aspart", brands: ["Novolog"] },
      { generic: "insulin glargine", brands: ["Lantus", "Basaglar", "Lantus Solostar"] },
      { generic: "insulin lispro", brands: ["Humalog"] },
      { generic: "irbesartan", brands: ["Avapro"] },
      { generic: "isosorbide mononitrate", brands: ["Imdur"] },
      { generic: "ketorolac", brands: ["Toradol"] },
      { generic: "levothyroxine", brands: ["Synthroid", "Levoxyl"] },
      { generic: "lisinopril", brands: ["Prinivil", "Zestril"] },
      { generic: "lorazepam", brands: ["Ativan"] },
      { generic: "losartan", brands: ["Cozaar"] },
      { generic: "melatonin", brands: [] },
      { generic: "meloxicam", brands: ["Mobic"] },
      { generic: "metformin", brands: ["Glucophage"] },
      { generic: "methotrexate", brands: ["Trexall"] },
      { generic: "metoprolol", brands: ["Lopressor", "Toprol XL"] },
      { generic: "montelukast", brands: ["Singulair"] },
      { generic: "naproxen", brands: ["Aleve", "Naprosyn"] },
      { generic: "nifedipine", brands: ["Procardia", "Adalat"] },
      { generic: "nystatin", brands: ["Mycostatin"] },
      { generic: "omeprazole", brands: ["Prilosec"] },
      { generic: "oxycodone", brands: ["OxyContin", "Roxicodone"] },
      { generic: "pantoprazole", brands: ["Protonix"] },
      {   generic:    "polyethylene glycol",  brands: ["MiraLAX","GaviLAX","GlycoLax","PEG 3350"] },
              { generic: "potassium chloride", brands: ["Klor-Con", "K-Dur", "Micro-K"] },
      { generic: "pravastatin", brands: ["Pravachol"] },
      { generic: "prednisone", brands: ["Deltasone"] },
      { generic: "propranolol", brands: ["Inderal"] },
      { generic: "quinapril", brands: ["Accupril"] },
      { generic: "ranitidine", brands: ["Zantac"] },
      { generic: "rosuvastatin", brands: ["Crestor"] },
      { generic: "sertraline", brands: ["Zoloft"] },
      { generic: "simvastatin", brands: ["Zocor"] },
      { generic: "sitagliptin", brands: ["Januvia"] },
      { generic: "sotalol", brands: ["Betapace"] },
      { generic: "spironolactone", brands: ["Aldactone"] },
      { generic: "sulfamethoxazole-trimethoprim", brands: ["Bactrim", "Septra"] },
      { generic: "tamsulosin", brands: ["Flomax"] },
      { generic: "tramadol", brands: ["Ultram"] },
      { generic: "trazodone", brands: ["Desyrel"] },
      { generic: "valacyclovir", brands: ["Valtrex"] },
      { generic: "valproic acid", brands: ["Depakene"] },
      { generic: "venlafaxine", brands: ["Effexor"] },
      { generic: "verapamil", brands: ["Calan", "Verelan"] },
      { generic: "warfarin", brands: ["Coumadin"] },
      { generic: "zolpidem", brands: ["Ambien"] },
      { generic: "amphetamine/dextroamphetamine", brands: ["Adderall", "Adderall XR"] },
      { generic: "alendronate", brands: ["Fosamax"] },
      { generic: "tadalafil", brands: ["Cialis"] },
      { generic: "fluticasone/umeclidinium/vilanterol", brands: ["Trelegy"] },
      { generic: "empagliflozin", brands: ["Jardiance"] },
      { generic: "semaglutide", brands: ["Ozempic", "Wegovy"] },
               { generic: "vitamin d", brands: ["Drisdol", "vitamin d3", "cholecalciferol"] },
      { generic: "prednisolone", brands: ["Pred Forte"] },
      { generic: "enoxaparin", brands: ["Lovenox", "Clexane"] },
      { generic: "doxorubicin", brands: ["Adriamycin"] },
      { generic: "adalimumab", brands: ["Humira"] },
      { generic: "rivaroxaban", brands: ["Xarelto"] },
      { generic: "methylphenidate", brands: ["Ritalin", "Concerta"] },
      { generic: "memantine", brands: ["Namenda"] },
               { generic: "tiotropium", brands: ["Spiriva", "Spiriva HandiHaler", "Spiriva Respimat"] },
      { generic: "isosorbide", brands: [] },
      { generic: "isosorbide dinitrate", brands: [] }
    ];
	// ——— Map every brand name to its generic ———
    const brandToGenericMap = {};
    commonMedications.forEach(({ generic, brands }) => {
      brands.forEach(brand => {
        brandToGenericMap[brand.toLowerCase()] = generic.toLowerCase();
      });
    });

    // ——— Map every generic to its brands ———
  const genericToBrandMap = {};
  Object.entries(brandToGenericMap).forEach(([brand, generic]) => {
    if (!genericToBrandMap[generic]) genericToBrandMap[generic] = [];
    genericToBrandMap[generic].push(brand);
  });

  const brandSynonyms = {
    spiriva: 'tiotropium',
    'tiotropium bromide': 'tiotropium',
    novolog: 'insulin aspart',
    humalog: 'insulin lispro',
    hctz: 'hydrochlorothiazide',
    'fluticasone propionate': 'fluticasone',
    lipitor:        'atorvastatin',
    lantus:         'insulin glargine',
    claritin:       'loratadine',
    synthroid:      'levothyroxine',
    fosamax:        'alendronate',
    coumadin:       'warfarin',
    'klor-con':     'potassium chloride',
    tylenol:        'acetaminophen'
  };

  const ignoreSalts = /\b(hydrochloride|sulfate|phosphate|acetate|maleate|tartrate|mesylate|succinate|propionate|sodium|potassium|calcium|magnesium)\b/gi;
  const trivialSalts = /\b(sodium|hydrochloride|sulfate|phosphate|acetate|succinate|maleate|tartrate|mesylate|propionate|potassium|calcium|magnesium)\b/gi;

  const importantSaltPairs = [
    ['diclofenac sodium',      'diclofenac potassium'],
    ['cyclosporine',           'cyclosporine modified'],
    ['ferrous sulfate',        'ferrous gluconate']
  ];

  const genericSynonyms = {
    hctz: 'hydrochlorothiazide',
    hydrochlorothiazide: 'hydrochlorothiazide'
  };
  genericSynonyms['tiotropium bromide'] = 'tiotropium';
  genericSynonyms['kcl'] = 'potassium chloride';
  genericSynonyms['iron'] = 'ferrous';
  genericSynonyms['iron sulfate'] = 'ferrous sulfate';

const commonIndicationsPatterns = [
    { pattern: /(hypertension)$/i, indication: "hypertension" },
    { pattern: /(diabetes\s+mellitus)$/i, indication: "diabetes mellitus" }, // More specific first
    { pattern: /(type\s+\d\s+diabetes)$/i, indication: "type 2 diabetes" }, // Or capture type
    { pattern: /(diabetes)$/i, indication: "diabetes" },
    { pattern: /(thyroid\s+disorder)$/i, indication: "thyroid disorder" },
    { pattern: /(hypothyroidism)$/i, indication: "hypothyroidism" },
    { pattern: /(gerd)$/i, indication: "gerd" },
    { pattern: /(gastroesophageal\s+reflux\s+disease)$/i, indication: "gerd" },
    { pattern: /(major\s+depression)$/i, indication: "major depression" },
    { pattern: /(depression)$/i, indication: "depression" },
    { pattern: /(anxiety)$/i, indication: "anxiety" },
    { pattern: /(heart\s+failure)$/i, indication: "heart failure" },
    { pattern: /(high\s+blood\s+pressure)$/i, indication: "high blood pressure" },
    { pattern: /(high\s+cholesterol)$/i, indication: "high cholesterol" },
    { pattern: /(hyperlipidemia)$/i, indication: "hyperlipidemia" },
    { pattern: /(asthma)$/i, indication: "asthma" },
    { pattern: /(copd)$/i, indication: "copd" },
    { pattern: /(chronic\s+obstructive\s+pulmonary\s+disease)$/i, indication: "copd"},
    { pattern: /(arthritis)$/i, indication: "arthritis" },
    { pattern: /(osteoarthritis)$/i, indication: "osteoarthritis" },
    { pattern: /(rheumatoid\s+arthritis)$/i, indication: "rheumatoid arthritis" },
    { pattern: /(insomnia)$/i, indication: "insomnia" },
    { pattern: /(constipation)$/i, indication: "constipation" },
    { pattern: /\ballergies\b/i, indication: "allergies" },
    { pattern: /(pain)$/i, indication: "pain" }, // General pain
    { pattern: /(mild\s+pain)$/i, indication: "mild pain" },
    { pattern: /(moderate\s+pain)$/i, indication: "moderate pain" },
    { pattern: /(severe\s+pain)$/i, indication: "severe pain" },
    { pattern: /(acute\s+pain)$/i, indication: "acute pain" },
    { pattern: /(chronic\s+pain)$/i, indication: "chronic pain" },
    // Add more common, relatively unambiguous terms.
    // Order more specific patterns (e.g., "diabetes mellitus") before less specific ones (e.g., "diabetes").
].sort((a,b) => { // Sort by length of a sample match to prioritize longer matches
    const matchA = "text " + a.indication; // sample for length
    const matchB = "text " + b.indication;
    return matchB.length - matchA.length;
});

  function normalizeMedicationName(name) {
    if (!name) return { name: '', brandTok: [] };
    let n = name.toLowerCase().trim();
    const brandTok = [];

    n = n.replace(ignoreSalts, '').replace(/\s{2,}/g, ' ').trim();

    /* 1 .  Convert any brand name that appears anywhere in the text
       (e.g. "symbicort 160/4.5") to its generic. */
      for (const brand in brandToGenericMap) {
        const re = new RegExp('\\b' + brand + '\\b', 'gi');
        n = n.replace(re, match => {
          const token = match.toLowerCase();
          if (brandTok.length === 0 && !brandTok.includes(token)) {
            brandTok.push(token);
          }
          return brandToGenericMap[brand];
        });
      }

      for (const syn in brandSynonyms) {
        const reSyn = new RegExp('\\b' + syn + '\\b', 'gi');
        n = n.replace(reSyn, match => {
          const token = match.toLowerCase();
          if (brandTok.length === 0 && !brandTok.includes(token)) {
            brandTok.push(token);
          }
          return brandSynonyms[syn];
        });
      }
    // Apply generic synonyms after brand replacements
    for (const syn in genericSynonyms) {
      const reSyn = new RegExp('\\b' + syn + '\\b', 'gi');
      n = n.replace(reSyn, genericSynonyms[syn]);
    }

    // normalize common formulation abbreviations early
    n = n.replace(/\b(xl|xr)\b/, 'er');

    // separate letters and numbers so "warfarin5mg" becomes "warfarin 5mg"
    n = n.replace(/([a-z])([0-9])/gi, '$1 $2')
         .replace(/([0-9])([a-z])/gi, '$1 $2');

    /* 2 .  Strip common salt words */
    const commonSalts = [
      'hydrochloride', 'hcl',
      'sodium', 'potassium',
      'acetate', 'phosphate', 'carbonate',
      'maleate', 'succinate', 'tartrate',
      'besylate', 'camsylate', 'mesylate',
      'gluconate', 'propionate', 'bitartrate', 'edisylate',
      'nacl'
    ];
    commonSalts.sort((a,b) => b.length - a.length);
    for (const salt of commonSalts) {
      const saltRegex = new RegExp(salt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      n = n.replace(saltRegex, ' ');
    }
    n = n.replace(/\s+/g, ' ').trim();

    /* 3 .  Remove timing / meal phrases that sneak into the name */
    n = n.replace(/\b(?:\d+\s*(?:min(?:ute)?s?|hr|hrs?|hours?)\s*)?(?:at|before|after|with|without)\s+(?:breakfast|lunch|dinner|meal(?:s)?|night|bedtime|morning|evening)\b/ig, '')
         .trim();

    /* 4. Remove common leftover instructional/form words and numbers from name string */
    n = n.replace(/\b\d+(?:\.\d+)?\b/g, '');
    n = n.replace(/\b(?:tablet|tablets|tab|tabs|cap|capsule|capsules|caplet|oral|po|subq|sc|im|iv|id|pr|sl|os|od|au|oin|oint|ophth|neb|inh|inj|inject|supp|sol|solution|susp|elix|syr|tr|tinct|lot|crm|crm.|ung|gel|aero|conc|dil|dp|ds|emuls|enema|er|film|gas|gran|gum|impl|inf|ins|irrig|jec|liq|lotn|loz|mdi|mis|nebu|oint|oph|pad|part|pas|past|pel|pen|pill|plst|powd|pwd|rinse|sat|shamp|soak|spg|spl|spray|stk|strip|subl|sup|swab|syr|sys|tab|tamp|tape|top|troche|twa|vag|wafer|xt|xr|xl|xd|sr|cr|dr|la|patch|puffs|drops|lozenge|spray|unit|units|ml|mcg|mg|g|solostar|actuation)\b/gi, '');

    /* 5. Final cleanup */
    n = n.replace(/[\/\-]/g, ' ')
         .replace(/[^a-z0-9 ]+/g, '')
         .replace(/\s+/g, ' ')
         .trim();

    // 6. Drop trailing noise words like dosing instructions or route leftovers
    n = n.replace(/\b(?:daily|weekly|bid|tid|qid|q\d+h|every|once|monday|tuesday|wednesday|thursday|friday|saturday|sunday|mon|tue|wed|thu|fri|sat|sun|m\/?w\/?f|m\s*w\s*f|tu\/?th\/?sa\/?su|ttsu|in|po|sc|im|iv|combination|combo)\b.*$/i, '');
    // 7. Drop leading verbs that accidentally made it into the drug name
    n = n.replace(/^(?:take|give|inject|inhale|apply|use)\b\s*/i, '');

    n = n.trim();

  return { name: n, brandTok };
}

    const unitVariants = {
  tablet:   ['tab','tabs','tablet','tablets','tab.','tablet.'],
  capsule:  ['cap','caps','capsule','capsules','caplet','cap.','gelcap','softgel','gel','sprinkle','sprinkles'],
  spray:    ['spray','sprays'],
  puff:     ['puff','puffs'],
  drop:     ['drop','drops','gtt','gtts','gt','drp'],
  patch:    ['patch','patches','transdermal patch'],
   injection:['shot','syringe','pen','inj','auto-injector','flexpen','solostar'],
  lozenge:  ['lozenge','loz','troche'],
  suppository:['supp','suppositories'],
  solution: ['solution','sol','liq','liquid','oral sol'],
  ointment: ['ointment','oint','ung','cream','gel'],
     inhalation:['inhaler','inh','neb','nebulizer','mdi','dpi','respimat','handihaler'],
  unit:     ['U','IU','units'],
  mL:       ['ml','mL','cc'],
  mcg:      ['μg','mcg','ug'],
  mg:       ['mg'],
  mEq:      ['meq', 'mEq', 'milliequivalents'],
  g:        ['g','gram','grams']
};

    let photo1Files = [];
    let photo2Files = [];
    let meds1 = [], meds2 = [];
    let hasTextInput1 = false; // Track if Photo 1 used text input
    let hasTextInput2 = false; // Track if Photo 2 used text input

    async function processFiles(files) {
  let allCombinedOrderStrings = [];
  let lowConfidence = false;
  const totalFiles = files.length;
  let currentFileIndex = 0;

  for (let file of files) {
    currentFileIndex++;
    showLoading(`Processing image ${currentFileIndex} of ${totalFiles}...`);
    try {
      const result = await processFile(file); // result.text is raw OCR text from one image
      // keepOrderLines processes raw text from one image into an array of order strings
      const orderStringsFromFile = keepOrderLines(result.text);
      allCombinedOrderStrings = allCombinedOrderStrings.concat(orderStringsFromFile);

      if (result.confidence < 0.8) {
        lowConfidence = true;
      }
    } catch (err) {
      console.error("Error processing file: ", file.name, err);
      showError(`Error processing file ${file.name}. Some data may be missing.`);
    }
  }

  if (lowConfidence) {
    showError("Warning: Some OCR text was unclear and may not be accurate. Please review manually.");
  }
  // Return a flat array of unique processed order strings from all images
  return [...new Set(allCombinedOrderStrings.filter(line => line && line.trim() !== ''))];
}

function processFile(file) {
  return new Promise((resolve, reject) => {
    if (!file) {
      console.error('No file provided to processFile');
      reject(new Error("No file provided"));
      return;
    }
    console.log('Processing file:', file.name, file.type, file.size);
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        if (!e.target.result) {
          console.error('FileReader result is undefined');
          throw new Error('FileReader result is undefined');
        }
        const imageData = e.target.result;
        console.log('Sending image data:', imageData.substring(0, 100));
        const payload = { data: { image: imageData } };
        console.log('Payload being sent:', payload);
        const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
        const response = await callOcrFunction(payload);
        console.log('Received response from callOcrTest:', response);
        if (!response.data || typeof response.data !== 'object') {
          throw new Error('Invalid response from OCR function');
        }
        resolve(response.data);
      } catch (err) {
        console.error('Error in processFile:', err);
        reject(err);
      }
    };
    reader.onerror = () => {
      console.error('FileReader error:', reader.error);
      reject(new Error("File could not be read: " + reader.error));
    };
    reader.readAsDataURL(file);
  });
}
async function testCallOcr() {
  try {
    const callOcrFunction = firebase.functions().httpsCallable('callOcrTest');
    const payload = { data: { test: "Hello, world!" } };
    console.log('Testing callOcrTest with payload:', payload);
    const response = await callOcrFunction(payload);
    console.log('Test response from callOcrTest:', response);
  } catch (err) {
    console.error('Error in testCallOcr:', err);
  }
}
    /**
     * If a single line actually contains two orders (two doses),
     * split it into two.
     */
    function splitConcatOrders(line) {
      // look for two dose patterns in one line
      const doseRegex = /\d+\s*(?:mg|mcg|g|mL|tablet|capsule|puff|drop|unit|IU)\b/gi;
      const matches = [...line.matchAll(doseRegex)];
      if (matches.length > 1) {
        const splitAt = matches[1].index;
        return [
          line.slice(0, splitAt).trim(),
          line.slice(splitAt).trim()
        ];
      }
      return [ line ];
    }

    /**
     * If a “continuation” line didn’t itself name a drug,
     * glue it back onto the previous order.
     */
    function mergeMultiLineOrders(lines) {
      const merged = [];
      lines.forEach(l => {
        if (/^[a-z]/i.test(l) && /\d/.test(l)) {
          // starts like an order → new entry
          merged.push(l);
        } else if (merged.length) {
          // continuation → append
          merged[merged.length - 1] += ' ' + l;
        } else {
          // no previous → keep alone
          merged.push(l);
        }
      });
      return merged;
    }

    /**
     * Merge “Day 1…”, “Day 2…” lines (taper packs) back onto
     * the preceding order line.
     */
    function mergeTaperPackOrders(lines) {
      const out = [];
      lines.forEach(l => {
        if (/^day\s*\d+/i.test(l) && out.length) {
          out[out.length - 1] += ' ' + l;
        } else {
          out.push(l);
        }
      });
      return out;
    }

function mergeEMRLines(lines) {
  const mergedOrders = [];
  let i = 0;
  console.log("mergeEMRLines: Input lines count:", lines.length); // Log total lines
  while (i < lines.length) {
    const line1 = lines[i]?.trim();
    if (!line1) { 
      i++;
      continue;
    }

    const isOrderStartLine1 =
    /^[a-zA-Z\s.-]+\s+\d+(?:\.\d+)?\s*(?:mg|mcg|g|u|iu|units?|ml|meq|unit\/ml)\s+[a-zA-Z\s.-]+$/i.test(line1) || // Added units: u, iu, meq, unit/ml. Added 'i' flag. Escaped '/'.
    /^[a-zA-Z\s.-]+\s+inhaler$/i.test(line1); // Added 'i' flag for case-insensitivity

    const line2 = lines[i + 1]?.trim();
    const line3 = lines[i + 2]?.trim();

    // DEBUGGING LOGS START HERE
    if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")) { // Focus on problem meds
        console.log("------------------------------------");
        console.log("mergeEMRLines checking:", JSON.stringify(line1));
        console.log("  isOrderStartLine1:", isOrderStartLine1);
        console.log("  line2:", JSON.stringify(line2));
        console.log("  line3:", JSON.stringify(line3));
    }
    // DEBUGGING LOGS END HERE

    // This is your NEW line2 condition block
    const line2ConditionMet = line2 && 
        (
            ['give', 'take', 'inhale', 'inject', 'apply', 'use', 'place', 'administer', 'chew', 'dissolve', 'spray', 'sprinkle'].some(kw => line2.toLowerCase().startsWith(kw + ' ')) ||
            /^(day\s*\d+|take\s*\d+\s*tab)/i.test(line2.toLowerCase())
        );

    const line3ConditionMet = line3 && line3.toLowerCase().startsWith('start:');

    // MORE DEBUGGING LOGS
    if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")) {
         console.log("  line2ConditionMet:", line2ConditionMet);
         console.log("  line3ConditionMet:", line3ConditionMet);
    }
    // DEBUGGING LOGS END

    if (isOrderStartLine1 && line2ConditionMet && line3ConditionMet) {
      if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")){
        console.log("  DECISION: MERGING these 3 lines.");
      }
      mergedOrders.push(`${line1} ${line2} ${line3}`);
      i += 3; 
    } else {
      if (line1.toLowerCase().includes("lantus") || line1.toLowerCase().includes("prednisone") || line1.toLowerCase().includes("albuterol") || line1.toLowerCase().includes("potassium")){
        console.log("  DECISION: NOT MERGING. Pushing line1 only:", JSON.stringify(line1));
      }
      mergedOrders.push(line1); 
      i += 1; 
    }
  }
  console.log("mergeEMRLines: Output mergedOrders count:", mergedOrders.length); // Log output count
  return mergedOrders;
}

    // ←── END INSERT ──▶

//=== STEP 1  keepOrderLines helper =========================
function keepOrderLines(rawText) {
  //— flatten any tab-separated rows into free-text orders —
  if (rawText.includes('\t')) {
    rawText = rawText
      .split(/\r?\n+/)
      .map(line => {
        const cols = line.split('\t');
        if (cols.length >= 6) {
          return `${cols[0].trim()} ${cols[1].trim()} ${cols[2].trim()} ${cols[3].trim()} on ${cols[4].trim()} for ${cols[5].trim()}`;
        }
        return line;
      })
      .join('\n');
  }

  const DEBUG_JUNK = false;

  // 1. Initial split by newline and trim each line.
  //    This provides a basic array of lines as they appear in the input.
  let lines = rawText.split(/\r?\n+/).map(line => line.trim());
  // console.log("DEBUG keepOrderLines - Initial split & trimmed lines:", JSON.parse(JSON.stringify(lines)));

  // 2. Apply EMR-specific 3-line merging.
  //    This function should now receive lines that are only split by original newlines.
  lines = mergeEMRLines(lines);
  // console.log("DEBUG keepOrderLines - After mergeEMRLines:", JSON.parse(JSON.stringify(lines)));

  // 3. Now, apply further cleaning and other processing to each (potentially merged) line.
  let processedLines = lines.map(line => {
    // The logic from the old STEP-SPLITMULTI (handling commas, semicolons, 'and')
    // is now applied to *each individual line string* after EMR merging.
    // Importantly, it replaces these separators with a SPACE, not a newline,
    // to avoid re-splitting merged lines.
    let modifiedLine = line.replace(/(?:,|;|\band\b)/gi, ' ');
    modifiedLine = modifiedLine.replace(/\s{2,}/g, ' '); // Collapse multiple spaces that might result

    // Then, apply the cleanLine function to this modifiedLine.
    return cleanLine(modifiedLine.trim()); // cleanLine also trims
  });
  // console.log("DEBUG keepOrderLines - After comma/semicolon/and replacement and cleanLine map:", JSON.parse(JSON.stringify(processedLines)));

  // 4. Split lines that might themselves contain two distinct orders (e.g., "Drug A ... Drug B")
  //    This function expects to operate on single strings.
  //processedLines = processedLines.flatMap(splitConcatOrders);
  // console.log("DEBUG keepOrderLines - After splitConcatOrders:", JSON.parse(JSON.stringify(processedLines)));

  // 5. Final filter for valid-looking order lines
  const finalFilteredLines = processedLines.filter(line => {
    const keep =
      line.trim() && // Ensure line is not just whitespace after all processing
      isLikelyOrderLine(line) &&
      (containsKnownMedication(line) ||
        /\d+\s*(mg|mcg|g|mL|units|tablet|capsule|puff|drop)\b/i.test(line)) &&
      /\d/.test(line);
    if (!keep && DEBUG_JUNK && line.trim()) console.log('🗑️ Final filter dropping line:', line);
    return keep;
  });
  // console.log("DEBUG keepOrderLines - Final output:", JSON.parse(JSON.stringify(finalFilteredLines)));
  return finalFilteredLines;
}
//=== END STEP 1 ============================================

    function cleanLine(line) {
  	// 1) drop any “number.” or “number)” at the start
  	line = line.replace(/^\s*\d+[\.\)]\s*/, '');
  	// 2) remove trailing non-alphanumeric junk and trim
  	return line.replace(/[^a-z0-9]+$/i, '').trim();
}

// ——— remove trailing junk from merged lines ———
function pruneLine(line) {
  // keep dose → form → route → freq → PRN → “for … pain” or “moderate pain”
  // only strip off trailing garbage like “;” or OCR noise, but preserve any
  // remaining words (e.g. “for hypertension” or “heart failure”)
  return line.trim();
 }

    function isLikelyOrderLine(line) {
      //=== STEP 3  stricter test
if (line.length < 5) return false;
const good = (line.match(/[a-z0-9]/gi) || []).length;
return good / line.length >= 0.5;
//=== END STEP 3
    }

function containsKnownMedication(line) {
  const lower = line.toLowerCase();

  // 1) Critical meds always match
  if (criticalMeds.some(med => lower.includes(med))) return true;

  // 2) Any brand name in commonMedications also counts
  if (commonMedications.some(m =>
        m.brands.some(b => lower.includes(b.toLowerCase()))
      )) return true;

  // 3) Generic names or dose patterns as before
  return commonMedications.some(med => lower.includes(med.generic))
      || /\d+\s*(?:mg|mcg|units|puffs|tabs?|tablets?|capsules?)\b/.test(lower);
}

    // ——— Text normalizer — no more stat inside statin ———
function normalizeText(str) {
  let text = (str || '').toLowerCase()

    // your existing expansions…
    .replace(/\bnow\b/g, 'immediately')
    // only match "stat" when it's not embedded in another word
    .replace(/(?<![a-z])stat(?![a-z])/g, 'immediately')
    .replace(/\bqhs\b/g, 'at bedtime')
    .replace(/\bnightly\b/g, 'at bedtime')
    // NEW – map the common abbreviation
    .replace(/\bsob\b/g, 'shortness of breath')
    // …all the rest of your shorthand/frequency → full-text rules…

  // final cleanup:
  return text
    .replace(/\s+/g, ' ')
    .trim();
}

function normalizeIndicationText(txt = '') {
  let s = txt.toLowerCase()
             .replace(/[.;,]+/g, ' ')
               .replace(/\bstart\s*date.*$/g,'')
              .replace(/\b(?:start|date)\b/g,'')
              .replace(/\b(?:spray|inject|inhale|use|apply|puff|inhalations?|contents|device|handihaler|respimat|flexpen|each|per|in|via|of|one|two)\b/gi,'')
             .replace(/\s+/g,' ')
             .trim();

  const synonyms = {
    'afib': 'atrial fibrillation',
    'af': 'atrial fibrillation',
    'a fib': 'atrial fibrillation',
    'atrial fib': 'atrial fibrillation',
    'sob':'breathing difficulty',
    'shortness of breath':'breathing difficulty',
    'anxious':'anxiety'
  };
  if (synonyms[s]) s = synonyms[s];
    return s;
}

function normalizeIndication(txt) {
  if (!txt) return '';

  txt = txt
    .toLowerCase()
    .replace(/\b(type\s*2\s*)?diabetes\b/g, 'diabetes')
    .replace(/\b(htn|hypertension|high blood pressure)\b/g, 'hypertension')
    .replace(/\bhigh cholesterol\b/g, 'cholesterol')
    .replace(/\banxious\b/g, 'anxiety')
    .replace(/\bas needed\b/g, 'prn')
    .replace(/\bfor sleep\b/i, 'sleep');

  txt = txt
    .replace(/\banticoag(ulation)? clinic\b/gi, '')
    .replace(/\binr\s*\d+(?:\.\d+)?\s*-\s*\d+(?:\.\d+)?\b/gi, '')
    .replace(/\b(no\s+)?taper\b/gi, '');

  const fillerRE =
    /\b(?:po|by mouth|orally|tablet?s?|tab|daily|every day|in evening|evening|at bedtime|morning|stop|no taper|taper|for \d+\s*days?)\b/gi;
  txt = txt
    .replace(fillerRE, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  return txt;
}

function normalizeTimeOfDay(t) {
  if (!t) return '';
  const aliases = {
    morning: 'morning',
    qam: 'morning',
    am: 'morning',
    'every am': 'morning',
    'every morning': 'morning',
    'in morning': 'morning',
    'in the morning': 'morning',
    'daily in morning': 'morning',
    evening: 'evening',
    pm: 'evening',
    qpm: 'evening',
    'every evening': 'evening',
    'daily in evening': 'evening',
    'in evening': 'evening',
    'in the evening': 'evening',
    'in the pm': 'evening',
    bedtime: 'bedtime',
    night: 'bedtime',
    qhs: 'bedtime',
    nightly: 'bedtime',
    'at bedtime': 'bedtime',
    'at night': 'bedtime',
    'every night': 'bedtime'
  };
  t = t.toLowerCase().trim();
  if (aliases[t]) return aliases[t];
  for (const key in aliases) {
    if (t.includes(key)) return aliases[key];
  }
  return t;
}

function normalizeFrequency(str) {
  if (!str) return '';
  str = str.toLowerCase().trim();
  const tidPattern = /\b(tidac|tid\b|three\s+times\s+daily|3\s+times\s+daily|before\s+meals?)\b/;
  if (tidPattern.test(str)) return 'tid';   // canonical label
  const bidPattern = /\b(twice\s+(a|per)?\s*day|twice\s+daily)(\s+with.*)?\b/;
  if (bidPattern.test(str)) return 'bid';
  const weeklyRE = /once\s+(per\s+)?week(ly)?/i;
  if (weeklyRE.test(str)) return 'weekly';
  return str;
}

function canonFormulation(f) {
  if (!f) return '';
  return f.toLowerCase().replace(/\b(xl|xr|sr|cr)\b/g, 'er').trim();
}

function normalizeAdministration(str) {
  if (!str) return '';
  str = str.toLowerCase().replace(/\s+/g, ' ').trim();
  if (/\bwith\s+(orange\s*juice|food|meal)s?\b/.test(str)) {
    return 'with food';
  }
  if (/\b(between\s+meals|without\s+(food|meal)s?|empty\s*stomach)\b/.test(str)) {
    return 'between meals';
  }
  return str.trim();
}

function inhaled(parsedOrder) {
    if (!parsedOrder) return false;
    const route = (parsedOrder.route || '').toLowerCase();
    const form = (parsedOrder.form || '').toLowerCase();

    // Primary check: route is 'inhalation'
    if (route === 'inhalation') {
        return true;
    }

    // Secondary check: form implies inhalation
    const inhalationForms = ['inhaler', 'puff', 'nebule', 'mdi', 'dpi', 'aerosol', 'aer'];
    if (inhalationForms.includes(form)) {
        return true;
    }

    return false;
}

// ——— What changed? ———
function getChangeReason(orig, updated) {
  const DEBUG_CHANGE_REASON = false;
  if (DEBUG_CHANGE_REASON) {
    console.log('DEBUG getChangeReason: orig.drug=', orig.drug, 'updated.drug=', updated.drug);
    console.log('DEBUG getChangeReason: orig Parsed=', JSON.stringify(orig));
    console.log('DEBUG getChangeReason: updated Parsed=', JSON.stringify(updated));
  }

// DEBUG getChangeReason: updated Parsed=', JSON.stringify(updated));
// ── core/tail extractors for indication check ── // KEEP THIS COMMENT IF YOU WANT
// const core = n => normalizeMedicationName(n).split(' ')[0]; // REMOVE OR COMMENT OUT
// const tail = n => { ... }; // REMOVE OR COMMENT OUT
// const isWord = s => ...; // REMOVE OR COMMENT OUT
// const origTail = tail(orig.drug); // REMOVE OR COMMENT OUT
// const updTail  = tail(updated.drug); // REMOVE OR COMMENT OUT
// const tailDiff = ...; // REMOVE OR COMMENT OUT

  if (!orig || !updated) return 'Misc. Change';

  let changes = [];
  const add = lbl => { if (!changes.includes(lbl)) changes.push(lbl); };

  const norm = s => (s || '').toLowerCase().trim().replace(/\s+/g, ' ');
  const canon = f => {
    f = norm(f);
    if (f === '' || f === 'daily' || f === 'q24h') return 'daily';
    if (['tid', 'tidac', 'three times daily'].includes(f)) return 'tid';
    if (/(?:before|with) meals/.test(f) || /before breakfast lunch dinner/.test(f)) return 'tid';
    return f;
  };

  // --- Initial properties from parsed objects ---
  const origDrugNameRaw = orig.rawDrug || orig.drug; // Preserve pre-normalization if available
  const updatedDrugNameRaw = updated.rawDrug || updated.drug;

  const { name: origDrugNorm } = normalizeMedicationName(orig.drug); // Fully normalized name for substance matching
  const { name: updatedDrugNorm } = normalizeMedicationName(updated.drug);
  const drug = origDrugNorm;

  // --- Comparisons ---
  const drugNameMatchStrict = origDrugNorm === updatedDrugNorm; // Based on fully normalized names (substance match)
  // New: direct raw-name comparison for certain brand/generic swaps
  const rawNamesDiffer = norm(origDrugNameRaw) !== norm(updatedDrugNameRaw);

  const sameMgStrength = (a, b) => {
    const grab = s => {
      const m = (s || '').match(/(\d+(?:\.\d+)?)\s*mg\b/i);
      return m ? Number(m[1]) : null;
    };
    let n1 = grab(a);
    let n2 = grab(b);
    if (n1 === null) n1 = grab(orig.originalRaw);
    if (n2 === null) n2 = grab(updated.originalRaw);
    return n1 !== null && n1 === n2;
  };

  const coumBrand =
    /\bwarfarin\b/i.test(`${origDrugNameRaw} ${updatedDrugNameRaw}`) &&
    /\bcoumadin\b/i.test(`${origDrugNameRaw} ${updatedDrugNameRaw}`);

  if (coumBrand && !changes.includes('Brand/Generic changed'))
    add('Brand/Generic changed');

  if (
    rawNamesDiffer &&
    drugNameMatchStrict &&
    (/coumadin/i.test(origDrugNameRaw) ||
      /coumadin/i.test(updatedDrugNameRaw) ||
      /humalog/i.test(origDrugNameRaw) ||
      /humalog/i.test(updatedDrugNameRaw))
  ) {
    add('Brand/Generic changed');
  }
  const same = (a,b) => (!a && !b) || a===b;
  function valuesEqual(v1, v2) {
    if (Array.isArray(v1) && Array.isArray(v2)) {
      if (v1.length !== v2.length) return false;
      for (let i = 0; i < v1.length; i++) {
        if (Number(v1[i]) !== Number(v2[i])) return false;
      }
      return true;
    }
    return v1 === v2;
  }

  function canonUnit(u) {
    return (u || '').toLowerCase().replace(/\bgram\b/, 'g');
  }

  const doseValueMatch = valuesEqual(orig.dose?.value, updated.dose?.value);
  // Compare total dose, defaulting quantity to 1 when missing
  const qty1 = orig.qty == null ? 1 : orig.qty;
  const qty2 = updated.qty == null ? 1 : updated.qty;
  const tot1 = (orig.dose?.value ?? 0) * qty1;
  const tot2 = (updated.dose?.value ?? 0) * qty2;
  const doseTotalMatch = tot1 === tot2;
  const doseUnitMatch =
    canonUnit(orig.rawUnit || orig.dose?.unit) ===
    canonUnit(updated.rawUnit || updated.dose?.unit);
  const frequencyMatch = canon(orig.frequency) === canon(updated.frequency);
  const tokensEqual = (a,b) => {
    a = (a || []).map(norm).sort();
    b = (b || []).map(norm).sort();
    if (a.length !== b.length) return false;
    for (let i=0; i<a.length; i++) if (a[i] !== b[i]) return false;
    return true;
  };
  const scheduleMatch = tokensEqual(orig.scheduleTokens, updated.scheduleTokens);
  const mealsTokens = ['tidac','before meals','with meals','before breakfast lunch dinner'];
  const containsMeals = tokens => (tokens||[]).map(norm).some(t => mealsTokens.includes(t));
  let timeOfDayMatch =
    normalizeTimeOfDay(orig.timeOfDay) === normalizeTimeOfDay(updated.timeOfDay);
  if (canon(orig.frequency) === 'weekly' && canon(updated.frequency) === 'weekly') {
    timeOfDayMatch = true;
  }
  const timeOfDayRawMatch = same(
    norm(orig.timeOfDayOriginal),
    norm(updated.timeOfDayOriginal)
  );
  let formMatch = same(norm(orig.form), norm(updated.form));
  function canonForm(f) {
    return (f || '')
      .toLowerCase()
      .replace(/\b(tabs?|tablets?)\b/, 'tablet');
  }
  if (
    !formMatch &&
    (
      (canonForm(orig.form) === 'tablet' && updated.form === '') ||
      (canonForm(updated.form) === 'tablet' && orig.form === '')
    )
  ) {
    formMatch = true;
    changes = changes.filter(c => c !== 'Form changed');
  }
  if (!formMatch &&
      orig.form === 'pen' && updated.form === 'pen') {
    formMatch = true;
    changes = changes.filter(c => c !== 'Form changed');
  }
  let formulationMatch = same(norm(orig.formulation), norm(updated.formulation));
  // Re-evaluate formulationMatch minus trivial salts
  const normForm = (f) => (f || '').replace(trivialSalts, '').replace(/\s{2,}/g,'').trim();
  if ( !formulationMatch && normForm(orig.formulation) === normForm(updated.formulation) ) {
    formulationMatch = true;
    // remove the tag if it was added earlier
    changes = changes.filter(c => c !== 'Formulation changed');
  }
  const stripER = f => (f || '').replace(/\ber\b/gi, '').trim();
  if (!formulationMatch && stripER(orig.formulation) === stripER(updated.formulation)) {
    formulationMatch = true;
    changes = changes.filter(c => c !== 'Formulation changed');
  }
  if (
    !formulationMatch &&
    canonFormulation(orig.formulation) === canonFormulation(updated.formulation)
  ) {
    formulationMatch = true;
    changes = changes.filter(c => c !== 'Formulation changed');
  }
  let routeMatch = same(norm(orig.route), norm(updated.route));
  if (!routeMatch) {
    const r1 = norm(orig.route);
    const r2 = norm(updated.route);
    if ((r1 === 'po' && !r2) || (r2 === 'po' && !r1)) {
      routeMatch = true;
    }
  }
  const prnMatch = same(orig.prn, updated.prn);
  const ind1 = normalizeIndication(orig.indication);
  const ind2 = normalizeIndication(updated.indication);
  const indicationDiff = ind1 && ind2 && ind1 !== ind2;
  if (indicationDiff) add('Indication changed');
  const startDateMatch = same(orig.startDate, updated.startDate);
  const endDateMatch = same(orig.endDate, updated.endDate);
  const qtyMatch = same(orig.qty ?? 1, updated.qty ?? 1); // Default to 1 if null for comparison
  const taperDiff =
    orig.taperFlag !== null &&
    updated.taperFlag !== null &&
    orig.taperFlag !== updated.taperFlag;
  const courseDiff =
    /\bx\d+\s*days?\b/i.test(orig.originalRaw || '') !==
    /\bx\d+\s*days?\b/i.test(updated.originalRaw || '');


  // --- Logging for debug ---
  if (DEBUG_CHANGE_REASON) {
    console.log('DEBUG getChangeReason - Comparisons:');
    console.log('  drugNameMatchStrict (normalized substance):', drugNameMatchStrict, `(${origDrugNorm} vs ${updatedDrugNorm})`);
    console.log('  origDrugNameRaw:', origDrugNameRaw, 'updatedDrugNameRaw:', updatedDrugNameRaw);
    console.log('  formulationMatch:', formulationMatch, `(orig: ${norm(orig.formulation)} vs upd: ${norm(updated.formulation)})`);
    console.log('  doseValueMatch (per unit):', doseValueMatch, `(orig: ${orig.dose?.value} vs upd: ${updated.dose?.value})`);
    console.log('  doseTotalMatch:', doseTotalMatch, `(orig: ${orig.dose?.total ?? orig.dose?.value} vs upd: ${updated.dose?.total ?? updated.dose?.value})`);
    console.log('  doseUnitMatch:', doseUnitMatch, `(orig: ${orig.dose?.unit} vs upd: ${updated.dose?.unit})`);
    console.log('  qtyMatch:', qtyMatch, `(orig: ${(orig.qty ?? 1)} vs upd: ${(updated.qty ?? 1)})`);
    console.log('  frequencyMatch:', frequencyMatch, `(orig: ${canon(orig.frequency)} vs upd: ${canon(updated.frequency)})`);
    console.log('  timeOfDayMatch:', timeOfDayMatch, `(orig: ${norm(orig.timeOfDay)} vs upd: ${norm(updated.timeOfDay)})`);
    console.log('  timeOfDayRawMatch:', timeOfDayRawMatch, `(orig: ${norm(orig.timeOfDayOriginal)} vs upd: ${norm(updated.timeOfDayOriginal)})`);
    console.log('  formMatch:', formMatch, `(orig: ${norm(orig.form)} vs upd: ${norm(updated.form)})`);
    console.log('  routeMatch:', routeMatch, `(orig: ${norm(orig.route)} vs upd: ${norm(updated.route)})`);
    console.log('  prnMatch:', prnMatch, `(orig: ${orig.prn} vs upd: ${updated.prn})`);
    console.log('  indicationDiff:', indicationDiff, `(${normalizeIndication(orig.indication)} vs ${normalizeIndication(updated.indication)})`);
    console.log('  startDateMatch:', startDateMatch, `(orig: ${orig.startDate || ""} vs upd: ${updated.startDate || ""})`);
    console.log('  endDateMatch:', endDateMatch, `(orig: ${orig.endDate || ""} vs upd: ${updated.endDate || ""})`);
  }

 // --- End Debugging Conditions ---

// --- Start/End Date Changes ---
  if (!startDateMatch) add('Date changed');
  if (!endDateMatch) add('End Date changed');

  // --- Formulation Change ---
  if (!formulationMatch) {
      // Do not flag a formulation change when both orders lack a formulation and the
      // core drug names match strictly. This avoids false positives such as
      // "Vitamin D3" vs "Cholecalciferol" where neither mentions a formulation.
      if (drugNameMatchStrict && !orig.formulation && !updated.formulation) {
          // nothing
      } else if (orig.formulation || updated.formulation) {
          // Avoid if Brand/Generic already implies this (e.g. Lopressor vs Metoprolol Tartrate)
          // This needs careful thought. For now, if drugNameMatchStrict is true AND formulations differ, it's a formulation change.
          // If drugNameMatchStrict is false, it might be a different drug OR a salt form change handled by B/G.
          if (drugNameMatchStrict || (!changes.includes("Brand/Generic changed") && (norm(orig.formulation) !== norm(updated.formulation))) ) {
               add('Formulation changed');
          }
      }
  }

  // --- Brand/Generic Change ---
  const leftHasBrand  = (orig.brandTokens || []).length;
  const rightHasBrand = (updated.brandTokens || []).length;
  if (drugNameMatchStrict && leftHasBrand !== rightHasBrand) {
    add('Brand/Generic changed');
  }
  if (drugNameMatchStrict) {
    const leftFull  = `${origDrugNameRaw} ${orig.formulation || ''}`.trim();
    const rightFull = `${updatedDrugNameRaw} ${updated.formulation || ''}`.trim();
    const saltSwap = importantSaltPairs.some(([a, b]) =>
      (leftFull.includes(a) && rightFull.includes(b)) ||
      (leftFull.includes(b) && rightFull.includes(a))
    );
    if (saltSwap && !changes.includes('Formulation changed')) {
      changes.push('Formulation changed');
    }
  }

    // Quantity-only difference (dose strength identical)
    const quantityOnlyDiff =
      (qtyMatch === false || taperDiff || courseDiff) &&
      doseValueMatch === true &&
      doseUnitMatch === true &&
      doseTotalMatch === false;

    if (quantityOnlyDiff) {
      // Remove any existing Dose-change flag
      changes = changes.filter(c => c !== 'Dose changed');
      if (!changes.includes('Quantity changed')) {
        changes.push('Quantity changed');
      }
    }

  // --- Dose/Quantity Changes ---
  // Only flag a dose change when the per-unit amount or unit differs, or when the
  // total differs without a quantity change. This prevents "Dose changed" when
  // the strength per spray/tablet is identical but the quantity varies.
if (!doseUnitMatch || !doseValueMatch || (!doseTotalMatch && qtyMatch)) {
  add('Dose changed');
}
// If totals are equal (quantity defaults to 1) and we added the dose flag, it
// likely came from a frequency-only change, so remove it.
const sameStrength =
  doseValueMatch &&
  doseUnitMatch &&
  !Array.isArray(orig.dose?.value) &&
  !Array.isArray(updated.dose?.value);
const sameQty = qtyMatch || (orig.qty == null && updated.qty == null);
if (sameStrength && sameQty && changes.includes('Dose changed')) {
  changes = changes.filter(c => c !== 'Dose changed');
}
if (!doseValueMatch && !changes.includes('Dose changed')) {
  add('Dose changed');
}
// Quantity differences are reflected in the dose when totals differ, but still
// list them separately to highlight dispensing changes.
if (!qtyMatch || taperDiff || courseDiff) {
  add('Quantity changed');
}

  if ((drug === 'ferrous sulfate' || drug === 'iron sulfate') &&
      doseValueMatch && changes.includes('Dose changed')) {
    changes = changes.filter(c => c !== 'Dose changed');
  }

// --- Frequency Change ---
if (!frequencyMatch) {
    if (!( (canon(orig.frequency)==='daily' && updated.frequency === '') ||
           (orig.frequency === '' && canon(updated.frequency)==='daily') )) {
       add('Frequency changed');
    }
} else if (!tokensEqual(orig.frequencyTokens, updated.frequencyTokens) &&
           (containsMeals(orig.frequencyTokens) || containsMeals(updated.frequencyTokens))) {
    if (!(canon(orig.frequency) === 'tid' && canon(updated.frequency) === 'tid')) {
      add('Frequency changed');
    }
}

// --- Time of Day Change ---
if (!timeOfDayMatch && (norm(orig.timeOfDay) || norm(updated.timeOfDay))) {
  add('Time of day changed');
}
if (!scheduleMatch && orig.scheduleTokens.length && updated.scheduleTokens.length) {
  add('Time of day changed');
}

// --- Form Change (tablet, capsule, etc.) ---
if (!formMatch && (norm(orig.form) || norm(updated.form))) {
    add('Form changed');
}

// --- Route Change ---
if (!routeMatch && (norm(orig.route) || norm(updated.route))) { // Only if routes specified and different
     add('Route changed');
}

// --- Administration Change ---
if (orig.administration && updated.administration &&
    orig.administration !== updated.administration) {
    add('Administration changed');
}

// --- PRN logic ---
if (orig.prn !== updated.prn) {
  changes.push('PRN changed');
} else if (
  orig.prn &&
  updated.prn &&
  orig.prnCondition !== updated.prnCondition &&
  !changes.includes('Indication changed')
) {
  changes.push('Indication changed');
}
// --- end PRN logic ---

// --- Indication Change (general catch-all if different) ---
if (indicationDiff) {
    // Only add if it's not the *only* change that would otherwise make it "Unchanged"
    // This avoids flagging minor indication wording differences if everything else is identical.
    // The primary "Indication-only" check is below. This is a broader catch.
    let otherChangesPresent = changes.filter(c => c !== 'Indication changed').length > 0;
    if (otherChangesPresent ||
        !drugNameMatchStrict || !doseTotalMatch || !doseUnitMatch || !frequencyMatch || !routeMatch ||
        !formMatch || !formulationMatch || !prnMatch || !startDateMatch || !endDateMatch || !qtyMatch
       ) {
        add('Indication changed');
    }
}
 
// 2) **Indication-only**
  if (
    drugNameMatchStrict && // Use the strict substance name match
    doseTotalMatch &&     // Use total dose for comparison
    doseUnitMatch &&
    qtyMatch &&           // Check quantity
    frequencyMatch &&
    timeOfDayMatch &&
    formMatch &&
    formulationMatch &&   // Check formulation
    routeMatch &&
    prnMatch &&
    startDateMatch &&     // Check start date
    endDateMatch &&       // Check end date
    indicationDiff        // And indication IS different (and was the only difference)
  ) {
  if (DEBUG_CHANGE_REASON) console.log('DEBUG: Matched Indication-only block (all other key fields identical).');
    // If ONLY the indication is different and everything else critical matches,
    // this specific block ensures 'Indication changed' is the primary (or only) reason.
    changes = ['Indication changed']; 
  } else { 
    // This 'else' is for the if statement immediately above.
    // It means it wasn't a strict "Indication-only" change according to these specific criteria.
    // The broader change detection logic that ran before this block would have already added various changes.
    if (DEBUG_CHANGE_REASON) console.log('DEBUG: Did NOT match strict Indication-only block; other changes might apply or already captured.');
}

   // ——— 3) Time-of-day-only, but allow QOD→daily ———
// THIS IS YOUR EXISTING DEFINITION - KEEP IT AS IS
const isQodToDaily =
  canon(orig.frequency) === 'every other day' &&
  canon(updated.frequency) === 'daily';

// THIS IS YOUR EXISTING IF STATEMENT FOR BLOCK #3:
// Modify it by adding the console.log inside the if, and adding the else block.
if (
  !timeOfDayMatch &&
  drugNameMatchStrict &&  // <-- CHANGE
  doseTotalMatch &&     // <-- CHANGE (from doseValueMatch)
  doseUnitMatch &&
  qtyMatch &&           // <-- ADD
  (frequencyMatch || isQodToDaily) &&
  formMatch &&
  formulationMatch &&   // <-- ADD
  routeMatch &&
  prnMatch &&
  startDateMatch &&     // <-- ADD
  endDateMatch &&       // <-- ADD
  normalizeIndication(orig.indication) === normalizeIndication(updated.indication)
) {
  if (DEBUG_CHANGE_REASON) console.log("--- BLOCK #3 CONDITION MET --- Returning 'Time of day changed'");
  if (changes.length === 0) {
    changes = ['Time of day changed'];
  } else if (!changes.includes('Time of day changed')) {
    changes.push('Time of day changed');
  }
//  return 'Time of day changed'; // Old return
}
else {
  if (DEBUG_CHANGE_REASON) console.log("--- BLOCK #3 CONDITION FAILED for explicit Time of Day return ---");
}

// if Block #3's condition was false.

  if (changes.includes('Dose changed') && coumBrand) {
    if (doseTotalMatch || sameMgStrength(origDrugNameRaw, updatedDrugNameRaw)) {
      changes = changes.filter(c => c !== 'Dose changed');
    }
  }

  // collapse trivial TOD/freq double-hit
  if (changes.includes('Frequency changed') && changes.includes('Time of day changed') &&
    canon(orig.frequency) === 'daily' && canon(updated.frequency) === 'daily') {
    changes = changes.filter(c => c !== 'Frequency changed');
  }
  // collapse inhaler form/route double-hit
  if (changes.includes('Form changed') && changes.includes('Route changed') && inhaled(orig) && inhaled(updated)) { // check if both are inhaled
    changes = changes.filter(c => c !== 'Route changed'); // or form, depending on preference
  }

// --- New Rule for Stat/Immediately vs. Timed Dosing ---
const origFreqIsImmediately = norm(orig.frequency) === 'immediately';
const updatedFreqIsDaily = canon(updated.frequency) === 'daily';
const origTODIsEmpty = norm(orig.timeOfDay) === '';
const updatedTODIsSet = norm(updated.timeOfDay) !== '';

if (changes.includes('Frequency changed') && changes.includes('Time of day changed') &&
    origFreqIsImmediately && updatedFreqIsDaily && origTODIsEmpty && updatedTODIsSet) {
  changes = changes.filter(c => c !== 'Time of day changed');
    if (normalizeIndication(orig.indication) === 'immediately' && normalizeIndication(updated.indication) === '') {
    changes = changes.filter(c => c !== 'Indication changed');
  }
} 
// --- End of New Rule ---

  if (DEBUG_CHANGE_REASON) console.log('DEBUG: changes array before final formatting:', JSON.stringify(changes));

  // Consolidate: If "Brand/Generic changed" and "Formulation changed" are both present,
  // and the formulation is part of the brand name (e.g. Metoprolol Tartrate vs Lopressor),
  // "Brand/Generic changed" might be sufficient. This is complex, for now, list both if detected.

  if (changes.length === 0) return 'Unchanged'; // Default to Unchanged if no specific diffs were added
  if (changes.length === 1) return changes[0];
  if (changes.length <= 4) { // List up to 4 specific changes
      // Prioritize more significant changes if too many minor ones
      const priorityOrder = ["Dose changed", "Frequency changed", "Formulation changed", "Quantity changed", "Brand/Generic changed", "Route changed", "Administration changed", "Form changed", "PRN changed", "Indication changed", "Date changed", "End Date changed", "Time of day changed"];
      changes.sort((a, b) => {
          let idxA = priorityOrder.indexOf(a);
          let idxB = priorityOrder.indexOf(b);
          if (idxA === -1) idxA = priorityOrder.length; // put unknown at end
          if (idxB === -1) idxB = priorityOrder.length;
          return idxA - idxB;
      });
      return changes.slice(0, 4).join(', ');
  }
  return 'Multiple changes'; // For 5 or more
}

    function parseOrder(orderStr) {
  // Keep a copy of the original input for debugging if needed at the very end
  // const originalInputToParseOrder = orderStr;
  const originalRaw = orderStr;   // keep untouched copy
  orderStr = orderStr.replace(/[\u2010\u2011\u2012\u2013\u2014\u2015\u2212]/g, '-');
  orderStr = normalizeText(orderStr); // Normalizes "qhs" to "at bedtime", etc.
  // Capture trailing trough monitoring notes before removing them
  let troughNote = null;
  const troughMatch = orderStr.match(/-\s*((?:target\s+)?trough.*)$/i);
  if (troughMatch) troughNote = troughMatch[1].trim();
  // Strip trailing trough comments so numeric targets don't get parsed as doses
  orderStr = orderStr.replace(/-\s*(?:target\s+)?trough.*$/i, '').trim();

  let order = {
    drug: "",
    dose: { value: null, unit: '', total: null },
    qty: null,
    route: "",
    frequency: "",
    frequencyTokens: [],
    timeOfDay: "",
    timeOfDayOriginal: "",
    administration: "",
    prn: false,
    prnCondition: "",
    startDate: "",
    endDate: "",
    form: "",
    formulation: "",
    indication: "",
    brandTokens: [],
    rawDrug: "",
    rawUnit: "",
    taperFlag: null,
    originalRaw
  };
// Store the initially cleaned drug string for later Brand/Generic comparison
  const initialCleanedDrugString = orderStr;

  // Record presence of taper/no taper for quantity comparisons
  if (/\bno\s+taper\b/i.test(originalRaw)) {
    order.taperFlag = 0;
  } else if (/\btaper\b/i.test(originalRaw)) {
    order.taperFlag = 1;
  }

// --- Enhanced Date Parsing ---
let dateFoundAndRemoved = false;

// Regex for "Start: MM/DD/YYYY", "Started: MM/DD/YYYY", "On: MM/DD/YYYY"
const explicitStartDateRegex = /\b(?:start|started|on)\s*:\s*(\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4}))\b/i;
let explicitStartDateMatch = orderStr.match(explicitStartDateRegex);
if (explicitStartDateMatch) {
    order.startDate = explicitStartDateMatch[1];
    orderStr = orderStr.replace(explicitStartDateMatch[0], "").trim();
    dateFoundAndRemoved = true;
    // console.log(`DEBUG parseOrder (Explicit Start Date): startDate="<span class="math-inline">\{order\.startDate\}", orderStr\="</span>{orderStr}"`);
}

// Regex for "End: MM/DD/YYYY", "Discontinue: MM/DD/YYYY", etc.
const explicitEndDateRegex = /\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?)\s*:\s*(\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4}))\b/i;
let explicitEndDateMatch = orderStr.match(explicitEndDateRegex);
if (explicitEndDateMatch) {
    order.endDate = explicitEndDateMatch[1];
    orderStr = orderStr.replace(explicitEndDateMatch[0], "").trim();
    // console.log(`DEBUG parseOrder (Explicit End Date): endDate="<span class="math-inline">\{order\.endDate\}", orderStr\="</span>{orderStr}"`);
}

// Fallback: Look for standalone MM/DD/YYYY or MM/DD/YY dates if not already captured
// Try to capture them as start dates if no end date was found yet, or if they appear before an end date.
// This is tricky to avoid misinterpreting dates within drug names or strengths if not careful.
// We'll assume dates appearing generally are start dates if no "End:" prefix was near them.
if (!dateFoundAndRemoved) { // Only if an explicit "Start: date" wasn't found
    // Regex to find a date pattern that is NOT immediately preceded by an end-date keyword
    const genericDateRegex = /(?<!\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?)\s*:\s*)(\b\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4})\b)/i;
    let genericDateMatch = orderStr.match(genericDateRegex);
    if (genericDateMatch && genericDateMatch[1]) {
        // To be safer, only take this as a start date if no end date is also present in the close vicinity AFTER it
        const potentialEndDateNearby = /\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?)\s*:\s*\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4})\b/i.test(orderStr.substring(genericDateMatch.index));
        if (!potentialEndDateNearby || !order.endDate) { // If no end date is set OR no end date is found after this generic date
            order.startDate = genericDateMatch[1];
            orderStr = orderStr.replace(genericDateMatch[0], "").trim(); // Replace the found generic date
            // console.log(`DEBUG parseOrder (Generic Start Date): startDate="<span class="math-inline">\{order\.startDate\}", orderStr\="</span>{orderStr}"`);
        }
    }
}
// --- End of Enhanced Date Parsing ---

const endDateRegex = /\b(?:end|ended|stop|stopped|dc|d\/c|discontinue(?:d)?):\s*(\d{1,2}\/\d{1,2}\/\d{4})\b/i;
let endDateMatchResult = orderStr.match(endDateRegex);
if (endDateMatchResult) {
    order.endDate = endDateMatchResult[1];
    orderStr = orderStr.replace(endDateMatchResult[0], "").trim(); // Remove "End: MM/DD/YYYY"
}

  // 1. Extract Time-of-Day and common morning/evening/night shorthands
//    Also sets frequency if implied by the shorthand (e.g., qam is daily)
const timeOfDayMappings = [
  // --- NEW: Prioritize "every other X" and specific daily patterns before general ones ---
  { regex: /\bevery\s+other\s+morning\b/i, timeOfDay: 'morning', frequency: 'every other day', originalTermRegexPos: 0 },
  { regex: /\bevery\s+other\s+evening\b/i, timeOfDay: 'evening', frequency: 'every other day', originalTermRegexPos: 0 },
  { regex: /\bevery\s+other\s+night\b/i, timeOfDay: 'bedtime', frequency: 'every other day', originalTermRegexPos: 0 },

  { regex: /\bdaily\s+in\s+(the\s+)?morning\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bqam\b/i, timeOfDay: 'morning', frequency: 'daily', originalTerm: 'qam' },
  { regex: /\bevery\s+am\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bevery\s+morning\b/i, timeOfDay: 'morning', frequency: 'daily', originalTermRegexPos: 0 },
  // General "morning" - its frequency will be defaulted to 'daily' later if not set by a more specific rule above
  { regex: /\b(in\s+the\s+)?morning\b/i, timeOfDay: 'morning', originalTermRegexPos: 0 },

  { regex: /\bqpm\b/i, timeOfDay: 'evening', frequency: 'daily', originalTerm: 'qpm' },
  { regex: /\bevery\s+evening\b/i, timeOfDay: 'evening', frequency: 'daily', originalTermRegexPos: 0 },
  // General "evening" - its frequency will be defaulted to 'daily' later
  { regex: /\b(in\s+the\s+)?evening\b/i, timeOfDay: 'evening', originalTermRegexPos: 0 },

  { regex: /\bqhs\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTerm: 'qhs' },
  { regex: /\bhs\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTerm: 'hs' },
  { regex: /\bnightly\b/i,  timeOfDay: 'bedtime', frequency: 'daily', originalTerm: 'nightly' },
  { regex: /\bevery\s+night\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTermRegexPos: 0 },
  { regex: /\bat\s+night\b/i, timeOfDay: 'bedtime', frequency: 'daily', originalTermRegexPos: 0 }, // Specific "at night"
  // General "bedtime" - its frequency will be defaulted to 'daily' later
  { regex: /\b(at\s+)?bedtime\b/i, timeOfDay: 'bedtime', originalTermRegexPos: 0 },
  // General "night" as a fallback for bedtime - its frequency will be defaulted to 'daily' later
  { regex: /\bnight\b/i, timeOfDay: 'bedtime', originalTermRegexPos: 0 }
];

let todProcessed = false;
for (const mapping of timeOfDayMappings) {
  const match = orderStr.match(mapping.regex);
  if (match) {
    order.timeOfDay = mapping.timeOfDay;
    order.timeOfDayOriginal = (mapping.originalTerm || match[0]).toLowerCase().trim();
    
// Determine the exact string that was matched to replace it accurately
    orderStr = orderStr.replace(match[0], '').trim(); // Replace the entire matched part

    if (mapping.frequency && !order.frequency) { // Only set frequency if not already set by a more specific term
      order.frequency = mapping.frequency;
    }
    todProcessed = true;
    // console.log(`DEBUG parseOrder Step 1 (TimeShorthand): tod="<span class="math-inline">\{order\.timeOfDay\}", freq\="</span>{order.frequency}", orderStr="${orderStr}"`);
    break; // Processed one, move on
  }
}

// If a time of day was found (e.g. "morning") but frequency wasn't set by a specific shorthand (like qam, every morning)
// then check for weekly-style phrases before assuming it's a daily frequency.
if (order.timeOfDay && !order.frequency) {
    const weeklyPattern = /\b(?:once\s+weekly|once\s+a\s+week|weekly|every\s+(?:mon(?:day)?|tue(?:sday)?|wed(?:nesday)?|thu(?:rsday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?))\b/i;
    const weeklyMatch = orderStr.match(weeklyPattern);
    if (weeklyMatch) {
        order.frequency = 'weekly';
        order.frequencyTokens.push(weeklyMatch[0].toLowerCase());
        orderStr = orderStr.replace(weeklyMatch[0], '').trim();
    } else {
        order.frequency = 'daily';
    }
    // console.log(`DEBUG parseOrder Step 1 (Implied Freq): tod="${order.timeOfDay}", freq="${order.frequency}"`);
}
// After handling weekly vs daily, catch phrases like "2 times a day"
if (!order.frequency) {
  const m = orderStr.match(/(\d)\s*times\s+(?:a|per)\s+(?:day|daily)\b/i);
  if (m) {
    const map = { 1: 'daily', 2: 'bid', 3: 'tid', 4: 'qid' };
    order.frequency = map[m[1]] || '';
    order.frequencyTokens.push(m[0].toLowerCase());
    orderStr = orderStr.replace(m[0], '').trim();
  }
}
/* ——— NEW: capture “before / after breakfast|lunch|dinner”
          with an optional numeric offset ——— */
if (!order.timeOfDay) {
  const mealFreqMatch = orderStr.match(/\b(?:before|with)\s+meals\b/i);
  if (mealFreqMatch) {
    if (!order.frequency) order.frequency = 'tid';
    orderStr = orderStr.replace(mealFreqMatch[0], '').trim();
  }
}
if (!order.timeOfDay) {
  const explicitMeals = orderStr.match(/\bbefore\s+breakfast\s+lunch\s+dinner\b/i);
  if (explicitMeals) {
    if (!order.frequency) order.frequency = 'tid';
    orderStr = orderStr.replace(explicitMeals[0], '').trim();
  }
}
if (!order.timeOfDay) {
  const mealTiming =
    orderStr.match(/\b(?:\d+\s*(?:min(?:ute)?s?|hr|hrs?|hours?)\s*)?(before|after)\s+(breakfast|lunch|dinner)\b/i);
  if (mealTiming) {
    order.timeOfDay = mealTiming[0].replace(/\s+/g, ' ').trim();
    order.timeOfDayOriginal = mealTiming[0].toLowerCase().replace(/\s+/g, ' ').trim();
    if (!order.frequency) order.frequency = 'daily';      // give it a default
    orderStr = orderStr.replace(mealTiming[0], '').trim(); // strip the phrase

    /* ——— ALSO strip a trailing “daily” so it doesn’t sink into the drug name ——— */
    orderStr = orderStr.replace(/\bdaily\b/i, '').trim();
  }
}

// only strip “every” for time-of-day phrases
orderStr = orderStr
  .replace(/\bevery\s+(morning|evening|night)\b/gi, '$1')
  .trim();

  // 2. Extract Administration (with/without food/water)
  const adminMatch = orderStr.match(
    /\b(?:(with(?:out)?|w\/o?|before|after|between)\s*(orange\s*juice|meals?|meal|food|water|juice|liquid|supper|breakfast|lunch|dinner)|empty\s*stomach)\b/i
  );

  if (adminMatch) {
    let phrase = '';
    if (/empty\s*stomach/i.test(adminMatch[0])) {
      phrase = 'between meals';
    } else {
      const prefixRaw = adminMatch[1] || '';
      const noun = (adminMatch[2] || '').toLowerCase();
      let prefix = prefixRaw.toLowerCase();
      if (prefix === 'w/') prefix = 'with';
      if (prefix === 'w/o') prefix = 'without';
      phrase = `${prefix} ${noun}`.trim();
    }
    order.administration = normalizeAdministration(phrase);
    if (!order.frequency && /(?:before|with|between)\s+meals?/i.test(order.administration)) {
      order.frequency = 'tid';
    }
    orderStr = orderStr.replace(adminMatch[0], '').trim();
    // console.log(`DEBUG parseOrder Step 2 (Admin): order.administration="${order.administration}", orderStr="${orderStr}"`);
  }

// In parseOrder, START of new formulation parsing block (replaces old one)
const formulationKeywords = [
    'modified release', 'delayed release', 'extended release', 'controlled release', // Multi-word first
    'xr', 'er', 'sr', 'la', 'xl', 'cr', 'dr',
    'succinate', 'tartrate', 'maleate', 'fumarate', 'besylate', 'camsylate', 'mesylate',
    'acetate', 'phosphate', 'carbonate', 'gluconate', 'propionate', 'sodium', 'hydrochloride'
].sort((a, b) => b.length - a.length); // Sort by length, longest first is crucial

let processedOrderStrForFormulation = orderStr; // Work on a copy
const foundFormulations = [];

for (const keyword of formulationKeywords) {
    const keywordRegex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
    let match;
    // Find all matches of the current keyword
    const matches = Array.from(processedOrderStrForFormulation.matchAll(keywordRegex));

    for (const currentMatch of matches.reverse()) { // Process matches from right to left to handle indices correctly
        const drugNameIfKeywordRemoved = (
            processedOrderStrForFormulation.substring(0, currentMatch.index) +
            processedOrderStrForFormulation.substring(currentMatch.index + currentMatch[0].length)
        ).trim().toLowerCase();

        let isSafeToExtract = true;
        if (drugNameIfKeywordRemoved.length < 2 && !/\d/.test(drugNameIfKeywordRemoved)) {
             // Avoid extracting if it leaves almost nothing sensible or just numbers
             isSafeToExtract = false;
        }
        // Further check: if the keyword itself is a common drug (e.g. "phosphate" as in "sodium phosphate")
        // and removing it leaves something that doesn't look like another drug, it might be part of the core name.
        // This is tricky; a good keyword list is key.
        // For example, we don't want to extract "phosphate" from "sodium phosphate" if "sodium" alone isn't the intended drug.
        // The current formulationKeywords list is mostly suffixes or release types, which is safer.

        if (isSafeToExtract) {
            foundFormulations.push({ text: currentMatch[0].toLowerCase(), index: currentMatch.index });
            // Temporarily replace to avoid re-matching parts of already found longer formulations by shorter ones
            processedOrderStrForFormulation =
                processedOrderStrForFormulation.substring(0, currentMatch.index) +
                " ".repeat(currentMatch[0].length) + // Replace with spaces to keep indices for other keywords
                processedOrderStrForFormulation.substring(currentMatch.index + currentMatch[0].length);
        }
    }
}

if (foundFormulations.length > 0) {
    // Sort found formulations by their original index to maintain order
    foundFormulations.sort((a, b) => a.index - b.index);
    order.formulation = foundFormulations.map(f => f.text).join(" ").trim();

    // Now, actually remove the extracted formulations from the original orderStr
    // Rebuild orderStr by removing all extracted formulation parts
    let tempStr = orderStr;
    for (const formulationPart of order.formulation.split(' ')) {
        if (formulationPart) { // Ensure part is not empty
             // Use a regex that matches the whole word formulation part
             const partRegex = new RegExp(`\\b${formulationPart.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
             tempStr = tempStr.replace(partRegex, '');
        }
    }
    orderStr = tempStr.replace(/\s\s+/g, ' ').trim();
}
orderStr = orderStr.trim();

// Remove boilerplate phrases that might remain attached to the drug name
orderStr = orderStr.replace(/\bcombination\b/i, '').trim();
orderStr = orderStr.replace(/\bmay\s+increase\s+to.*$/i, '').trim();

// console.log(`DEBUG parseOrder (Formulation): formulation="<span class="math-inline">\{order\.formulation\}", orderStr\="</span>{orderStr}"`);
// END of new formulation parsing block

    // 3. Extract PRN  ── capture condition when present
  const prnCondWords = '(?:anxious|anxiety|pain|in\\s+pain|nausea|vomiting|sob|shortness\\s+of\\s+breath|itching|fever|dizzy|headache)';
  let prnMatch = orderStr.match(new RegExp(`\\bprn\\s+(?:for\\s+)?(${prnCondWords})\\b`, 'i'));
  if (!prnMatch) prnMatch = orderStr.match(new RegExp(`\\bas\\s+needed\\s+(?:for\\s+)?(${prnCondWords})\\b`, 'i'));
  if (!prnMatch) prnMatch = orderStr.match(new RegExp(`\\bif\\s+(${prnCondWords}|needed)\\b`, 'i'));
  if (!prnMatch) prnMatch = orderStr.match(/\b(?:prn|as\s+needed|if\s+needed)\b/i);
  if (prnMatch) {
    order.prn = true;
    if (prnMatch[1]) order.prnCondition = normalizeIndication(prnMatch[1]);
    orderStr = orderStr.replace(prnMatch[0], '').trim();

    // console.log(`DEBUG parseOrder Step 3 (PRN): order.prn=${order.prn}, prnCondition="${order.prnCondition}", orderStr="${orderStr}"`);
  }

  // 4. Extract Indications - This is a critical section
  // Attempt to find "for [text]" first, as it's a strong indication marker.
  // Example: "for moderate pain", "for blood pressure"
  const forIndicationRegex = /\bfor\s+([a-zA-Z0-9\s\/.-]+)/i;
  let forIndicationMatchResult = orderStr.match(forIndicationRegex);
  if (forIndicationMatchResult && forIndicationMatchResult[1]) {
    const potentialIndication = forIndicationMatchResult[1].trim().toLowerCase();
    order.indication = normalizeIndication(potentialIndication);
    orderStr = orderStr.replace(forIndicationMatchResult[0], '').trim(); // Remove "for [indication]"
    // console.log(`DEBUG parseOrder Step 4a (For Indication): order.indication="${order.indication}", orderStr="${orderStr}"`);
  }

  // If no "for" indication, check for specific keywords like "pain", "shortness of breath"
  // This needs to be careful not to grab parts of drug names.
  if (!order.indication) {
    // Matches phrases like "moderate pain", "acute pain", or just "pain" if it's clearly an indication
    const painIndicRegex = /\b((?:[a-zA-Z]+(?:\s+[a-zA-Z]+)*)?\s*pain)\b/i;
    const painIndicMatch = orderStr.match(painIndicRegex);
    // Ensure the match is not just the drug name itself if the drug name contains "pain"
    if (painIndicMatch && painIndicMatch[0] && painIndicMatch.index > 0) { // Check index > 0 to avoid matching if "pain" is the start (could be drug)
      // Further check: make sure we are not grabbing "drugname pain" if "pain" is part of a common suffix for the drug.
      // This is complex. For now, a simple match:
      let matchedPainStr = painIndicMatch[0].trim().toLowerCase();
      order.indication = normalizeIndication(matchedPainStr);
      orderStr = orderStr.replace(painIndicMatch[0], '').trim();
      // console.log(`DEBUG parseOrder Step 4b (Pain Indication): order.indication="${order.indication}", orderStr="${orderStr}"`);
    }
  }

  if (!order.indication) {
    const sobMatch = orderStr.match(/\bshortness of breath\b/i); // "SOB" is already expanded by normalizeText
    if (sobMatch) {
      order.indication = normalizeIndication('shortness of breath');
      orderStr = orderStr.replace(sobMatch[0], '').trim();
      // console.log(`DEBUG parseOrder Step 4c (SOB Indication): order.indication="${order.indication}", orderStr="${orderStr}"`);
    }
  }
  // At this point, for your new order, order.indication should ideally be "moderate pain"
  // and orderStr should be "atorvastatin 40 mg tablet po" (or similar for other drugs)

  // console.log(`DEBUG parseOrder: After indication attempts: orderStr="${orderStr}", indication="${order.indication}"`);

// Extract Quantity (e.g., "2 tabs") before dose, as it might be part of the dose string
const qtyWords = [
  'tabs', 'tab', 'tablets',
  'caps', 'capsules', 'caplets',
  'puff', 'puffs',
  'spray', 'sprays',
  'drop', 'drops',
  'lozenge', 'lozenges',
  'patch', 'patches'
];
// Helper to convert "1/2" or "½" style strings to decimals
function fractionToDecimal(str) {
  const map = { '½': 0.5, '¼': 0.25, '¾': 0.75 };
  if (map[str]) return map[str];
  const frac = str.match(/^(\d+)\s*\/\s*(\d+)$/);
  if (frac) return parseFloat(frac[1]) / parseFloat(frac[2]);
  return parseFloat(str);
}
// Regex to match "take/give/administer X units" or just "X units"
const qtyRegexEarly = new RegExp(
  `(?:\\b(?:take|give|administer|inhale|inject|apply|use)\\s+)?((?:\\d+\\/\\d+|[\\u00bc-\\u00be]|\\d+(?:\\.\\d+)?))\\s*(${qtyWords.join('|')})(?:s)?\\b`,
  'i'
);
const qtyMatchEarly = orderStr.match(qtyRegexEarly);
if (qtyMatchEarly) {
    order.qty = fractionToDecimal(qtyMatchEarly[1]); // Group 1 is the number
    const matchedQtyWord = qtyMatchEarly[2].toLowerCase(); // Group 2 is the unit word

    // If the matched word is a form, set order.form if not already set by a more specific term
    if ((['tablet', 'tab', 'tablets', 'tabs'].includes(matchedQtyWord)) && !order.form) order.form = 'tablet';
    else if ((['capsule', 'caps', 'caplet', 'capsules'].includes(matchedQtyWord)) && !order.form) order.form = 'capsule';
    else if ((['puff', 'puffs'].includes(matchedQtyWord)) && !order.form) order.form = 'puff';
    // ... add other form types if needed

    orderStr = orderStr.replace(qtyMatchEarly[0], '').trim();
}

  // 5. Extract Dose (mg/kg, combo-dose, then general unit parsing)
  // Strip parenthetical elemental-iron note
  orderStr = orderStr.replace(
    /\((?:\s*\d+\s*mg\s*elemental[^)]*)\)/i,
    ''
  ).trim();
  const weightMatch = orderStr.match(/(\d+(?:\.\d+)?)\s*mg\/kg\b/i);
  if (weightMatch) {
    order.dose = { value: parseFloat(weightMatch[1]), unit: 'mg/kg', total: null }; // total might need patient weight
    orderStr = orderStr.replace(weightMatch[0], '').trim();
  } else {
        const comboMatch = orderStr.match(/(\d+(?:\.\d+)?)\s*(?:mg)?\s*(?:-|\/|\+)\s*(\d+(?:\.\d+)?)\s*mg\b/i);
    if (comboMatch) {
      order.dose = {
                value: [parseFloat(comboMatch[1]), parseFloat(comboMatch[2])],
        unit: 'mg',
        total: null
      };
      orderStr = orderStr.replace(comboMatch[0], '').trim();
    } else {
      const multiMgMatches = [...orderStr.matchAll(/(\d+(?:\.\d+)?)\s*mg\b/ig)];
      if (multiMgMatches.length >= 2) {
        order.dose = {
          value: multiMgMatches.map(m => parseFloat(m[1])),
          unit: 'mg',
          total: null
        };
        multiMgMatches.forEach(m => { orderStr = orderStr.replace(m[0], '').trim(); });
      } else {

      // General dose unit parsing
const allUnits = Object.values(unitVariants).flat();
let unitMatchesFound = [];
for (let u of allUnits) {
  if (typeof u !== 'string' || !u) continue;
  const re = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*${u.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}\\b`, 'ig');
  let m;
  while ((m = re.exec(orderStr)) !== null) {
    const normUnit = u.toLowerCase() === "gram" ? "g" : u.toLowerCase();
    unitMatchesFound.push({ idx: m.index, qty: +m[1], rawUnit: normUnit, matchStr: m[0] });
  }
}

if (unitMatchesFound.length > 0) {
  const precedence = ['mcg','mg','g','mEq','unit','mL',
                      'tablet','capsule','patch','puff','spray','drop'];

  const hits = unitMatchesFound.map(m => {
    const stdUnit = Object.entries(unitVariants)
          .find(([std, arr]) => arr.includes(m.rawUnit))?.[0] || m.rawUnit;
    return { ...m, stdUnit, score: precedence.indexOf(stdUnit) };
  });

  hits.sort((a, b) => {
    if (a.score !== b.score) return a.score - b.score;  // better unit first
    return a.idx - b.idx;                               // tie → earlier hit
  });

  const bestMatch = hits[0];
  const sprayHit = hits.find(h => h.stdUnit === 'spray');
  let unitLower = bestMatch.stdUnit.toLowerCase();
  if (unitLower === "gram") unitLower = "g";
  order.rawUnit = unitLower; // store pre-normalization unit
  order.dose = { value: bestMatch.qty,
                 unit:  unitLower,
                 total: bestMatch.qty };

  if (sprayHit && order.qty === null) {
    order.qty = sprayHit.qty;
  }
  if (bestMatch.stdUnit === 'spray' && order.qty === null) {
    order.qty = bestMatch.qty;
  }
  if (order.qty !== null) {
    order.dose.total = bestMatch.qty * order.qty;
  }

  orderStr = orderStr.replace(bestMatch.matchStr, '').trim();
  // Capture trailing formulation tokens that may follow the strength (e.g. "1000 mg ER")
  let trailingForm = orderStr.match(/^[-\s]*(xr|er|sr|la|xl|cr|dr)\b/i);
  if (trailingForm) {
    order.formulation = (order.formulation ? order.formulation + ' ' : '') + trailingForm[1].toLowerCase();
    orderStr = orderStr.replace(trailingForm[0], '').trim();
  }
  // …and drop any leftover verb that preceded the dose phrase
  orderStr = orderStr.replace(/\b(?:give|take|administer)\b\s*/i, '').trim();
// If the best dose unit implies a form, set it if not already set
  if (bestMatch.stdUnit === 'tablet' && !order.form) order.form = 'tablet';
  else if (bestMatch.stdUnit === 'capsule' && !order.form) order.form = 'capsule';
  else if (bestMatch.stdUnit === 'puff' && !order.form) order.form = 'puff';
}
// Fallback if unitMatchesLoop didn't set a dose value but a number is present

      else if (!order.dose.value) {
         const doseUnitsForFallback = ['mcg','mg','g','ml','cc','unit','units','tsp','tbsp','drop','spray','puff','patch','lozenge','suppository','tablet','capsule','each','dose'];
         const fallbackDoseRegex = new RegExp(`(\\d+(?:\\.\\d+)?)(?:\\s*(${doseUnitsForFallback.join('|')})(?:s|es)?\\b)?`, 'i');
         // This regex tries to find a number, optionally followed by a unit.
         // Example: "1", "1 tablet", "10 mg"
         const fallbackMatch = orderStr.match(fallbackDoseRegex);
         if (fallbackMatch && fallbackMatch[1]) {
            const qty = parseFloat(fallbackMatch[1]);
            let unit = (fallbackMatch[2] || '').toLowerCase();
            let formFromUnit = "";

            if (unit) {
                // Normalize unit from unitVariants
                const foundStdUnit = Object.entries(unitVariants).find(([std, arr])=> arr.includes(unit));
                if(foundStdUnit) unit = foundStdUnit[0].toLowerCase();
                if (unit === "gram") unit = "g";

                // Check if this "unit" is actually a form
                if (unitVariants.tablet.includes(unit)) { formFromUnit = 'tablet'; unit = 'tablet';} // or keep unit as 'tablet'
                else if (unitVariants.capsule.includes(unit)) { formFromUnit = 'capsule'; unit = 'capsule';}
                // ... (add other form-like units)

                order.dose = { value: qty, unit: unit, total: qty };
                orderStr = orderStr.replace(fallbackMatch[0], '').trim();
                if(formFromUnit && !order.form) order.form = formFromUnit;
                 let trailingForm2 = orderStr.match(/^[-\s]*(xr|er|sr|la|xl|cr|dr)\b/i);
                if (trailingForm2) {
                    order.formulation = (order.formulation ? order.formulation + ' ' : '') + trailingForm2[1].toLowerCase();
                    orderStr = orderStr.replace(trailingForm2[0], '').trim();
                }
                // console.log(`DEBUG parseOrder Step 5 (Dose - fallbackDoseRegex): dose=${JSON.stringify(order.dose)}, orderStr="${orderStr}"`);
            }
         }
      }
    }
  }

  // Normalize dose units (mcg/g to mg) AFTER all dose parsing attempts
  if (order.dose.value !== null && typeof order.dose.value === 'number') { // Check if value is a number
    if (order.dose.unit === 'mcg') {
      order.dose.value = order.dose.value / 1000;
      order.dose.unit = 'mg';
      order.rawUnit = 'mg';
      order.dose.total = order.dose.value * (order.qty || 1);
    } else if (order.dose.unit === 'g') {
      order.dose.value = order.dose.value * 1000;
      order.dose.unit = 'mg';
      order.rawUnit = 'mg';
      order.dose.total = order.dose.value * (order.qty || 1);
    }
    // Round mg values
    if (order.dose.unit === 'mg') {
      order.dose.value = Math.round(order.dose.value * 1000) / 1000;
      if (order.dose.total != null) {
        order.dose.total = Math.round(order.dose.total * 1000) / 1000;
      }
    }
    // alias full word units
    if (order.dose.unit === 'gram') order.dose.unit = 'g';
  }
  // console.log(`DEBUG parseOrder: After dose normalization: dose=${JSON.stringify(order.dose)}, orderStr="${orderStr}"`);

  // Calculate total dose if qty is present
if (order.qty === null) { // If qty not parsed by qtyRegexEarly
    // Try to find qty from originalRaw if it wasn't stripped with dose/form, e.g. "Drug 50mg 2 tablets"
    const qtyLatePattern = new RegExp(`(?:^|\\s)((?:\\d+\\/\\d+|[\\u00bc-\\u00be]|\\d+(?:\\.\\d+)?))\\s*(${qtyWords.join('|')})(?:s)?\\b`, 'i');
    const qtyMatchLate = originalRaw.match(qtyLatePattern);
    if (qtyMatchLate) {
        // Check if this qty is not the same as dose.value to avoid double capture if unit was like 'tablet'
        const potentialQty = fractionToDecimal(qtyMatchLate[1]);
        if (!order.dose.value || Math.abs(order.dose.value - potentialQty) > 0.001 || order.dose.unit !== qtyMatchLate[2].toLowerCase().replace(/s$/,'') ) {
             if (orderStr.includes(qtyMatchLate[0])) { // If it's still in orderStr, remove it
                 orderStr = orderStr.replace(qtyMatchLate[0], '').trim();
             }
             order.qty = potentialQty;
        }
    }
}

if (order.dose.value !== null && typeof order.dose.value === 'number' && order.qty !== null && typeof order.qty === 'number') {
    order.dose.total = order.dose.value * order.qty;
} else if (order.dose.value !== null) {
    order.dose.total = order.dose.value; // Default total to value if qty is not applicable/found
}

// If dose unit itself is 'tablet' or 'capsule' and value is set, this implies qty if qty is still null
if (order.qty === null && (order.dose.unit === 'tablet' || order.dose.unit === 'capsule' || order.dose.unit === 'puff' || order.dose.unit === 'spray')) {
    if (order.dose.value && order.dose.value > 0) { // ensure value is a positive number
        order.qty = order.dose.value;
        if (order.dose.total === null) { // if total wasn't set by previous block
             order.dose.total = order.dose.value * order.qty; // This would be qty*qty, should be value is strength
        }
        // If the drug name itself likely contains the strength, this logic is fine.
        // Example: "Drug 50mg 1 tablet" -> dose.value=1, dose.unit=tablet, qty=1. Total=1.
        // Example: "Drug 2 puffs" -> dose.value=2, dose.unit=puff, qty=2. Total=4 (if value isn't # of puffs).
        // This needs care: if dose.value was *already* the count of units, then total is just value.
        // Let's assume if unit is tablet/capsule/puff, dose.value IS the count for that unit.
        if (order.dose.unit === 'tablet' || order.dose.unit === 'capsule' || order.dose.unit === 'puff' || order.dose.unit === 'spray') {
             order.dose.total = order.dose.value; // The "value" is the number of these items
        }
    }
}

// 6. Extract Form (override generic forms with specific terms if found)
{
  // New, more specific form words list - longest phrases first
  const formDefinitions = [
    { term: 'extended-release tablet', canonical: 'extended-release tablet' },
    { term: 'delayed-release tablet', canonical: 'delayed-release tablet' },
    { term: 'chewable tablet', canonical: 'chewable tablet' },
    { term: 'effervescent tablet', canonical: 'effervescent tablet' },
    { term: 'sublingual tablet', canonical: 'sublingual tablet' },
    { term: 'oral disintegrating tablet', canonical: 'oral disintegrating tablet' },
    { term: 'odt', canonical: 'oral disintegrating tablet' }, // ODT
    { term: 'tablet', canonical: 'tablet' },
    { term: 'extended-release capsule', canonical: 'extended-release capsule' },
    { term: 'delayed-release capsule', canonical: 'delayed-release capsule' },
    { term: 'capsule', canonical: 'capsule' },
    { term: 'caplet', canonical: 'caplet' },
    { term: 'softgel', canonical: 'softgel' },
    { term: 'patch', canonical: 'patch' }, { term: 'patches', canonical: 'patch' },
    { term: 'lozenge', canonical: 'lozenge' },
    { term: 'suppository', canonical: 'suppository' },
    { term: 'spray', canonical: 'spray' },
    { term: 'puff', canonical: 'puff' },
    { term: 'drop', canonical: 'drop' }, { term: 'drops', canonical: 'drop' },
    { term: 'suspension', canonical: 'suspension' },
    { term: 'solution', canonical: 'solution' },
    { term: 'elixir', canonical: 'elixir' },
    { term: 'syrup', canonical: 'syrup' },
    { term: 'liquid', canonical: 'liquid' },
    { term: 'cream', canonical: 'cream' },
    { term: 'ointment', canonical: 'ointment' },
    { term: 'gel', canonical: 'gel' },
    { term: 'inhaler', canonical: 'inhaler' },
    { term: 'mdi', canonical: 'inhaler' },
          { term: 'flexpen', canonical: 'pen' },
          { term: 'solostar', canonical: 'pen' },
          { term: 'respimat', canonical: 'respimat' },
          { term: 'handihaler', canonical: 'handihaler' },
    { term: 'nebule', canonical: 'nebule' }, { term: 'nebulizer solution', canonical: 'nebule'}
  ];

  // Build regex from sorted form terms (longest first to ensure correct matching)
  const sortedFormTerms = formDefinitions.map(fd => fd.term).sort((a, b) => b.length - a.length);
  // Escape terms for regex and join with |
  const formRegexPattern = sortedFormTerms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
  const formRegex = new RegExp(`\\b(${formRegexPattern})\\b`, 'i');
  const formMatch = orderStr.match(formRegex);

  if (formMatch && formMatch[1]) {
    const matchedTerm = formMatch[1].toLowerCase();
    // Find the definition again using the matched term (case-insensitive find)
    const definition = formDefinitions.find(fd => fd.term.toLowerCase() === matchedTerm);
    if (definition) {
      if (!order.form || ["tablet","capsule","caplet","softgel"].includes(order.form)) {
        order.form = definition.canonical;
      }
      orderStr = orderStr.replace(formMatch[0], "").trim();
      // console.log(`DEBUG parseOrder Step 6 (Form): order.form="${order.form}", orderStr="${orderStr}"`);
    }
  }
} 

  // 7. Extract Route
  const routes = [
    { standard: "po", variations: ["po", "oral", "orally", "by mouth"] }, { standard: "sl", variations: ["sl", "sublingual", "sublingually"] },
    { standard: "buccal", variations: ["buccal"] }, { standard: "pr", variations: ["pr", "rectal", "rectally"] },
    { standard: "ng", variations: ["ng", "nasogastric", "ng tube"] }, { standard: "og", variations: ["og", "orogastric"] },
    { standard: "gastrostomy", variations: ["gastrostomy", "g-tube", "peg tube"] }, { standard: "jejunostomy", variations: ["jejunostomy", "j-tube"] },
    { standard: "iv", variations: ["iv", "intravenous", "intravenously"] }, { standard: "im", variations: ["im", "intramuscular", "intramuscularly"] },
    { standard: "subq", variations: ["subq", "sc", "subcutaneous", "subcutaneously"] }, { standard: "id", variations: ["id", "intradermal"] },
    { standard: "io", variations: ["io", "intraosseous"] }, { standard: "intrathecal", variations: ["intrathecal"] },
    { standard: "epidural", variations: ["epidural"] }, { standard: "topical", variations: ["topical", "topically", "apply to skin"] },
    { standard: "transdermal", variations: ["transdermal"] }, { standard: "ophthalmic", variations: ["ophthalmic", "in eye", "eye drop"] },
    { standard: "otic", variations: ["otic", "in ear", "ear drop"] }, { standard: "nasal", variations: ["nasal", "intranasal", "in nose", "nasal spray"] },
    { standard: "vaginal", variations: ["vaginal", "vaginally"] }, { standard: "urethral", variations: ["urethral"] },
    { standard: "intrauterine", variations: ["intrauterine"] }, { standard: "inhalation", variations: ["inhalation", "inhalations", "inhaled", "inh", "inhale", "mdi", "dpi", "nebulized", "neb", "handihaler", "respimat"] },
    { standard: "intraperitoneal", variations: ["intraperitoneal"] }, { standard: "intraarticular", variations: ["intraarticular", "intra-articular"] },
    { standard: "intrapleural", variations: ["intrapleural"] }, { standard: "intravesical", variations: ["intravesical"] },
    { standard: "implantable", variations: ["implantable"] }
  ];
  if (!order.route) {
    for (const routeDef of routes) {
      for (const variation of routeDef.variations) {
        const routeRegex = new RegExp(`\\b${variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
        if (routeRegex.test(orderStr)) {
          order.route = routeDef.standard;
          orderStr = orderStr.replace(routeRegex, '').trim();
          break;
        }
      }
      if (order.route) break;
    }
    // console.log(`DEBUG parseOrder Step 7 (Route): order.route="${order.route}", orderStr="${orderStr}"`);
  }

  // 8. Extract Frequency

// Explicitly check for "immediately" first, as it's a specific frequency from "stat" or "now"
const immediatelyPattern = /\bimmediately\b/i;
if (!order.frequency && immediatelyPattern.test(orderStr)) {
    order.frequency = "immediately";
    order.frequencyTokens.push('immediately');
    orderStr = orderStr.replace(immediatelyPattern, '').trim();
    // console.log(`DEBUG parseOrder Step 8a (Immediately): order.frequency="<span class="math-inline">\{order\.frequency\}", orderStr\="</span>{orderStr}"`);
}
// Now proceed with other frequency checks if not "immediately"
if (!order.frequency) {
  
  const qhMatch = orderStr.match(/\bq(\d+)h\b/i);
  if (qhMatch) {
    order.frequency = `q${qhMatch[1]}h`;
    order.frequencyTokens.push(qhMatch[0].toLowerCase());
    orderStr = orderStr.replace(qhMatch[0], '').trim();
  } else {
    
    // *** NEW CHECK FOR qXhrs ***
    const qhrsMatch = orderStr.match(/\bq(\d+)(?:hrs|hr)\b/i); // Match q<number>hrs or q<number>hr
    if (qhrsMatch) {
        order.frequency = `q${qhrsMatch[1]}h`; // Normalize to qXh
        order.frequencyTokens.push(qhrsMatch[0].toLowerCase());
        orderStr = orderStr.replace(qhrsMatch[0], '').trim();
        // console.log(`DEBUG parseOrder Step 8b (qXhrs): freq="<span class="math-inline">\{order\.frequency\}", orderStr\="</span>{orderStr}"`);
    } else { // This 'else' means qXhrs also failed
        const everyHours = orderStr.match(/\bevery\s*(\d+)\s*(?:hours?|h|hr|hrs)\b/i);
        if (everyHours) {
          order.frequency = `q${everyHours[1]}h`;
          order.frequencyTokens.push(everyHours[0].toLowerCase());
          orderStr = orderStr.replace(everyHours[0], '').trim();
        } else {
          const freqMapping = { /* ... your existing map ... */
              "once daily": "daily", "once a day": "daily", "1 times daily": "daily", "daily": "daily", "od": "daily", "qd": "daily",
              "twice daily": "twice daily", "2 times daily": "twice daily", "2 times a day": "twice daily", "bid": "twice daily", "twice a day": "twice daily",
              "three times daily": "three times daily", "3 times daily": "three times daily", "tid": "three times daily", "tidac": "three times daily", "before meals": "three times daily", "with meals": "three times daily", "before breakfast lunch dinner": "three times daily",
              "four times daily": "four times daily", "4 times daily": "four times daily", "qid": "four times daily",
              "every other day": "every other day", "qod": "every other day",
              "stat": "immediately", "now": "immediately",
              "weekly": "weekly", "once a week": "weekly", "once per week": "weekly",
              "monthly": "monthly", "once a month": "monthly"
          };
          const freqMapExtra = {
            'twice a day': 'bid',
            'twice daily': 'bid',
            'twice a day with meals': 'bid',
            'twice daily with meals': 'bid'
          };
          Object.assign(freqMapping, freqMapExtra);
          freqMapping['bid'] = 'bid';
          const sortedFreqKeys = Object.keys(freqMapping).sort((a, b) => b.length - a.length);
          for (const key of sortedFreqKeys) {
            const pattern = new RegExp(`\\b${key.replace(/\s+/g, '\\s+')}\\b`, 'i');
            // Check !order.frequency again inside the loop
            if (!order.frequency && pattern.test(orderStr)) {
              const m = orderStr.match(pattern);
              order.frequency = freqMapping[key];
              if (m) order.frequencyTokens.push(m[0].toLowerCase());
              orderStr = orderStr.replace(pattern, '').trim();
              break;
            }
          }
        }
	}
    }
}
}
// ... (end of Step 8 for frequency parsing)
  if (!order.frequency && order.timeOfDay) {
    order.frequency = 'daily';
  }
  order.frequency = normalizeFrequency(order.frequency);
  if (
    order.frequency === 'tid' &&
    /twice\s+(?:a|per)?\s*day\s+with\s+meals/i.test(originalRaw)
  ) {
    order.frequency = 'bid';
  }
  // console.log(`DEBUG parseOrder Step 8 (Frequency): order.frequency="${order.frequency}", orderStr="${orderStr}"`);

// 9. Final Drug Name and Indication Assignment from remaining orderStr

orderStr = orderStr.trim();
// Add a console log to see what orderStr looks like before this final step
// console.log(`DEBUG parseOrder Step 9 - Initial orderStr for drug/indication: "${orderStr}"`);

// Aggressively try to remove known non-drug components that might still be attached
// This is a safety net; ideally, earlier parsing steps should have removed these.

// Remove fully parsed dates again if they were missed (using the populated order.startDate/endDate)
if (order.startDate) {
    const sdPattern = new RegExp(`\\b(?:start|started|on)\\s*:\\s*${order.startDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi');
    orderStr = orderStr.replace(sdPattern, '').trim();
    orderStr = orderStr.replace(new RegExp(`\\b${order.startDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim(); // Remove standalone date too
}
if (order.endDate) {
    const edPattern = new RegExp(`\\b(?:end|ended|stop|stopped|dc|d\\/c|discontinue(?:d)?)\\s*:\\s*${order.endDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi');
    orderStr = orderStr.replace(edPattern, '').trim();
    orderStr = orderStr.replace(new RegExp(`\\b${order.endDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim();
}
// Remove generic date patterns again
orderStr = orderStr.replace(/\b\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4})\b/g, '').trim();

// Remove common instruction prefixes/suffixes if they are still glued
const instructionWords = ['take', 'give', 'inhale', 'inject', 'apply', 'use', 'place', 'administer', 'chew', 'dissolve', 'spray', 'sprinkle', 'one', 'two', 'three', 'tablet', 'capsule', 'cap', 'tab', 'pill'];
instructionWords.forEach(word => {
    orderStr = orderStr.replace(new RegExp(`^${word}\\s+`, 'i'), '').trim();
    orderStr = orderStr.replace(new RegExp(`\\s+${word}$`, 'i'), '').trim();
});


      if (!order.frequency) {
          const abbr = orderStr.match(/\b(qd|bid|tid|qid)\b/i);
          if (abbr) {
              const map = { qd: 'daily', bid: 'bid', tid: 'tid', qid: 'qid' };
              order.frequency = map[abbr[1].toLowerCase()];
              orderStr = orderStr.replace(abbr[0], '').trim();
          }
      }
// Remove common route/frequency/formulation remnants if they are at the very end or beginning
const trailingRemnants = ['po', 'by mouth', 'oral', 'sublingual', 'sl', 'iv', 'im', 'sc', 'subq', 'topical', 'daily', 'bid', 'tid', 'qid', 'qhs', 'prn', 'er', 'xr', 'sr', 'dr', 'odt', 'solution', 'suspension', 'ointment', 'cream', 'gel', 'patch', 'inhaler', 'for', 'with', 'at', 'and', 'as needed', 'if needed', 'in morning', 'in evening', 'at bedtime', 'unit', 'units', 'mcg', 'mg', 'ml', 'meq', 'iu'];
trailingRemnants.forEach(remnant => {
    // Regex to match whole word at start or end, mindful of multi-word remnants
    const remnantPatternStart = new RegExp(`^${remnant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\s+|\\b|$)`, 'i');
    const remnantPatternEnd = new RegExp(`(\\s+|\\b|^)${remnant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i');
    orderStr = orderStr.replace(remnantPatternStart, '').trim();
    orderStr = orderStr.replace(remnantPatternEnd, '').trim();
});

orderStr = orderStr.replace(/[.,;]$/, '').trim(); // Remove trailing punctuation
orderStr = orderStr.replace(/^[.,;]/, '').trim();  // Remove leading punctuation
orderStr = orderStr.replace(/\s\s+/g, ' ').trim(); // Collapse multiple spaces
// Remove stray leading or trailing hyphens introduced by formatting
orderStr = orderStr.replace(/^\s*-\s*/, '').replace(/\s*-\s*$/, '').trim();
// Remove trailing solitary prepositions like "in" or "at"
orderStr = orderStr.replace(/\b(?:in|at|on)\s*$/i, '').trim();

// console.log(`DEBUG parseOrder Step 9 - orderStr after targeted cleanup: "${orderStr}"`);

let finalDrugName = "";

if (orderStr.length > 0) {
    // Attempt to identify known medication names (longest first) from the beginning of orderStr
    let knownMedNamesForExtraction = [];
    commonMedications.forEach(m => {
        knownMedNamesForExtraction.push(m.generic.toLowerCase());
        m.brands.forEach(b => knownMedNamesForExtraction.push(b.toLowerCase()));
    });
    criticalMeds.forEach(cm => { // Add critical meds as they are important to identify correctly
        if (!knownMedNamesForExtraction.includes(cm)) {
            knownMedNamesForExtraction.push(cm);
        }
    });
    knownMedNamesForExtraction = [...new Set(knownMedNamesForExtraction)].sort((a, b) => b.length - a.length);

    let matchedKnownName = "";
    for (const knownName of knownMedNamesForExtraction) {
        if (orderStr.toLowerCase().startsWith(knownName)) {
            // Check if the match is a whole word or followed by typical drug name extenders (XR, ER, HCTZ, numbers for strength)
            const afterMatch = orderStr.substring(knownName.length).trim();
            const nextWord = afterMatch.split(' ')[0].toLowerCase();
            const knownSuffixes = ['xr', 'er', 'sr', 'hcl', 'sodium', 'potassium', 'maleate', 'tartrate', 'succinate', 'acetate', 'phosphate', 'carbonate', 'hydrochloride', 'hctz', 'plus', 'dm', 'pm', 'forte'];
            
            if (afterMatch === "" || !/^[a-zA-Z]/.test(afterMatch) || knownSuffixes.includes(nextWord) || /^\d/.test(nextWord) || /^\//.test(afterMatch) || /^-/.test(afterMatch)) {
                 // It's likely the end of the drug name or followed by a strength/formulation
                let tempDrugName = orderStr.substring(0, knownName.length);
                let tempRemainder = afterMatch;

                // Try to grab common extenders like XR, numbers, or combo parts
                if (tempRemainder) {
                    const comboPartRegex = /^\s*([\/\-]\s*[a-zA-Z0-9\s.]+|(?:xr|er|sr|dr|hctz|hcl|sodium|potassium|\d+(\.\d+)?(?:mg|mcg|g|units)?)(?:\s+|$))/i;
                    const comboMatch = tempRemainder.match(comboPartRegex);
                    if (comboMatch && comboMatch[0]) {
                        tempDrugName += comboMatch[0];
                        tempRemainder = tempRemainder.substring(comboMatch[0].length).trim();
                    }
                }
                matchedKnownName = tempDrugName.trim();
                break;
            }
        }
    }

    if (matchedKnownName) {
        finalDrugName = matchedKnownName;
    } else {
        // Fallback: if no known drug name matches, take first 1-3 words as drug.
        // This is a heuristic and might be wrong for new/uncommon drugs.
        const words = orderStr.split(/\s+/);
        if (words.length > 0) {
            if (words.length <= 2) {
                finalDrugName = words.join(" ");
            } else { // If more than 2 words, take first 2 if they seem like a drug, else first 1.
                const firstTwo = words[0] + " " + words[1];
                // Simple check: if first two words are not just numbers or very short common words
                if (!/^\d+$/.test(words[0]) && !/^\d+$/.test(words[1]) && (words[0].length > 2 || words[1].length > 2) ) {
                    finalDrugName = firstTwo;
                    
                } else {
                    finalDrugName = words[0];
                    
                }
            }
        }
    }
}

// Strip common inhaler device terms that can trail the drug name
const deviceWords = /\b(respimat|handihaler|actuation|flexpen|kwikpen|solostar|pen|diskus)\b/i;
orderStr = orderStr.replace(deviceWords, '').replace(/\/\s*$/, '').trim();
finalDrugName = finalDrugName.replace(deviceWords, '').replace(/\/\s*$/, '').trim();

// Assign to order object
const drugStr = finalDrugName
  .replace(/[^a-zA-Z0-9\/\s\-\.#]+/g, ' ') // Allow # for Tylenol #3
  .replace(/\s\s+/g, ' ')
  .trim()
  .toLowerCase();
order.rawDrug = drugStr;
const { name: drugName, brandTok } = normalizeMedicationName(drugStr);
order.drug = drugName;
order.brandTokens = brandTok;

// --- Indication catcher (only if the token 'for' is present) ---
  const indMatch = orderStr.match(/\bfor\s+(.+?)$/i);
  if (indMatch) {
    order.indication = normalizeIndication(indMatch[1].trim());
    orderStr = orderStr.replace(indMatch[0], '').trim();
  }
  if (!order.indication) {
    const leftover = orderStr.match(/\ballergies\b/i);
    if (leftover) {
      order.indication = 'allergies';
      orderStr = orderStr.replace(leftover[0], '').trim();
    }
  }

// If order.drug ended up empty from the above, try a last resort from initialCleanedDrugString
if (!order.drug && initialCleanedDrugString) {
    let fallbackDrug = initialCleanedDrugString;
    // Remove known non-drug parts from this fallback too
    if (order.startDate) fallbackDrug = fallbackDrug.replace(new RegExp(`\\b(?:start|started|on)\\s*:\\s*${order.startDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim();
    if (order.endDate) fallbackDrug = fallbackDrug.replace(new RegExp(`\\b(?:end|ended|stop|stopped|dc|d\\/c|discontinue(?:d)?)\\s*:\\s*${order.endDate.replace(/\//g, '\\/').replace(/\./g, '\\.')}\\b`, 'gi'), '').trim();
    fallbackDrug = fallbackDrug.replace(/\b\d{1,2}\/\d{1,2}\/(?:\d{2}|\d{4})\b/g, '').trim();
    // Take first 1-2 words as a very basic fallback
    order.drug = fallbackDrug.split(/\s+/).slice(0, 2).join(' ').replace(/[^a-zA-Z0-9\/\s\-\.#]+/g, ' ').replace(/\s\s+/g, ' ').trim().toLowerCase();
    // console.log(`DEBUG parseOrder Step 9 - Fallback to initial string for drug name: "${order.drug}"`);
}
// console.log(`DEBUG parseOrder Step 9 - Final drug: "${order.drug}", Final indication: "${order.indication}"`);

// Ensure drug field isn't empty if orderStr had content originally and nothing else was parsed
if (!order.drug && initialCleanedDrugString &&
    !order.startDate && !order.endDate &&
    !order.timeOfDay && !order.frequency &&
    !order.indication && !order.form && !order.formulation &&
    !order.route && !order.dose.value && !order.qty &&
    initialCleanedDrugString.trim().length > 0
) {
    // If orderStr contained something but nothing specific was parsed from it,
    // it's likely the drug name itself.
    order.drug = initialCleanedDrugString.trim().toLowerCase();
}

// If no form detected but original text mentions tablets or capsules
  if (!order.form) {
      const raw = originalRaw.toLowerCase();
      if (/\btab(lets?)?\b/.test(raw)) {
          order.form = 'tablet';
      } else if (/\bcap(sules?|lets?)?\b/.test(raw)) {
          order.form = 'capsule';
      }
  }

  const deviceRE = /\b(solostar|flexpen|kwikpen|pen)\b/gi;
  if (order.form) {
      order.form = order.form.replace(deviceRE, '').trim() || 'pen';
  } else if (deviceRE.test(originalRaw.toLowerCase())) {
      order.form = 'pen';
  }

  const injMatch = originalRaw.match(/inject\s*(\d+(?:\.\d+)?)\s*u(?:nits?)?\b/i);
  if (injMatch && /u\s*\/\s*ml/i.test(originalRaw)) {
      const units = parseFloat(injMatch[1]);
      order.dose.value = units;
      order.dose.unit = 'unit';
      order.dose.total = units;
      // leave qty null so dose change is flagged, not quantity
  }
// Default route to 'po' if form implies oral administration and route not set
const oralFormsForPo = ['tablet','capsule','caplet','softgel','lozenge','syrup','solution','suspension','elixir','liquid','oral disintegrating tablet'];
if (!order.route && oralFormsForPo.includes(order.form)) {
    order.route = 'po';
}

  order.frequency  = normalizeFrequency(order.frequency);
  order.timeOfDay  = normalizeTimeOfDay(order.timeOfDay);
  if (!order.indication && troughNote) order.indication = troughNote;
  order.indication = normalizeIndication(order.indication);
  order.formulation = canonFormulation(order.formulation);

  // Capture day-of-week schedule tokens like "MWF" or "Tu/Th/Sa/Su" for later diff checks
  const schedRe = /\b(?:m\/?w\/?f|m\s*w\s*f|mwf|tu\/?th\/?sa\/?su|ttsu)\b/gi;
  order.scheduleTokens = (originalRaw.match(schedRe) || []).map(t => t.toLowerCase());

  // console.log('FINAL DEBUG Parsed order:', { /* input: originalInputToParseOrder, */ parsed: order });
  return order;
}

    function levenshteinDistance(a, b) {
      const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
      for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
      for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
          matrix[j][i] = Math.min(
            matrix[j][i - 1] + 1,
            matrix[j - 1][i] + 1,
            matrix[j - 1][i - 1] + indicator
          );
        }
      }
      return matrix[b.length][a.length];
    }

    // ------------------------------------------------------------------
// ------------------------------------------------------------------
//  String-similarity helper  (Levenshtein, normalised 0–1 score)
// ------------------------------------------------------------------
function similarity(a, b) {
  if (a === b) return 1;               // perfect match
  const maxLen = Math.max(a.length, b.length);
  if (maxLen === 0) return 1;          // two empty strings
  const distance = levenshteinDistance(a, b);
  return 1 - distance / maxLen;        // 0 = no overlap, 1 = identical
}

// ===========================================================
  // Find every contra‑indicated pair present in the full list
  // ===========================================================
function findContraIndications(allOrders) {
  const medsFound  = allOrders
        .map(o => coreDrugName(o.parsed.drug))   // << one canonical key
        .filter(Boolean);                        // drop blanks / junk
  const uniqueMeds = [...new Set(medsFound)];
  const warnings = [];

  uniqueMeds.forEach(med => {
    const badList = drugContraindications[med];
    if (!badList || badList.length === 0) return;

    badList.forEach(bad => {
      if (uniqueMeds.includes(bad)) {
        const key = [med, bad].sort().join(' + ');   // avoid duplicates A+B / B+A
        if (!warnings.find(w => w.key === key)) {
          warnings.push({ key, a: med, b: bad });
        }
      }
    });
  });

  return warnings;          // array like [{key:'atorvastatin + gemfibrozil', a:'atorvastatin', b:'gemfibrozil'}]
}

    function ordersAreEqual(a, b) {
	const norm = s => (s || '').toLowerCase().trim().replace(/\s+/g, ' ');
  // — NEW: orders with different startDates should _not_ be treated as equal
  if ((a.startDate || "") !== (b.startDate || "")) {
    return false;
  }

// Compare endDates (Fix 3.2)
  if ((a.endDate || "") !== (b.endDate || "")) {
    return false;
  }

  // 1) drug name and formulation
  const { name: normDrugA } = normalizeMedicationName(a.drug); // Substance name
  const { name: normDrugB } = normalizeMedicationName(b.drug); // Substance name
  const formulationA = norm(a.formulation);
  const formulationB = norm(b.formulation);

  // For two orders to be considered "equal" for the "Unchanged" category,
  // their substance name AND formulation should ideally match strictly.
  if (normDrugA !== normDrugB) return false;
  if (formulationA !== formulationB) return false;

  // 2) dose, total dose, and quantity
  const totalA = (a.dose.total != null ? a.dose.total : a.dose.value); // Prioritize total
  const totalB = (b.dose.total != null ? b.dose.total : b.dose.value); // Prioritize total

  if (totalA !== totalB || a.dose.unit !== b.dose.unit) return false;
  // If total dose and unit are same, also ensure quantity per administration is the same for strict equality
  if ((a.qty ?? 1) !== (b.qty ?? 1)) return false; // Default qty to 1 if null

  // 3) route
  if (a.route !== b.route) return false;

    /// 4) frequency  — treat “daily”, “q24h”, and blank as the same
	const canonFreq = f => {
 	 f = (f || '').toLowerCase().trim();
 	 return (f === '' || f === 'daily' || f === 'q24h') ? 'daily' : f;
	};

	const fA = canonFreq(a.frequency);
	const fB = canonFreq(b.frequency);

	// exact “qNh” forms (q4h, q6h, …) must match numerically
	const qA = fA.match(/^q(\d+)h$/);
	const qB = fB.match(/^q(\d+)h$/);

	if (qA && qB) {
  	if (+qA[1] !== +qB[1]) return false;
	} else if (fA !== fB) {
  	// fall back to fuzzy text similarity for phrases like “twice daily”
  	const freqSim = similarity(fA, fB);
  	if (freqSim < 0.85) return false;
}

  // ─── normalize time-of-day equivalence ───
  if (normalizeTimeOfDay(a.timeOfDay) !== normalizeTimeOfDay(b.timeOfDay)) {
    return false;
  }
  // ────────────────────────────────────────────

  // 5) dosage form must match …
  if ((a.form || '') !== (b.form || '')) return false;
  // 6) PRN flag …
  if (a.prn !== b.prn) return false;

// ——— ENSURE PAIN INDICATION MATCHES (NORMALIZED) ——— (Fix 1C)
{
  const ind1 = normalizeIndicationText(a.indication || '');
  const ind2 = normalizeIndicationText(b.indication || '');
  if (ind1 && ind2 && ind1 !== ind2) {
    return false;
  }
}
// ——————————————————————————————

  // 7) quantity per dose
  const qtyA = a.qty ?? 1;
  const qtyB = b.qty ?? 1;
  if (qtyA !== qtyB) return false;

  return true;
}

    function compareOrders(list1, list2) {
      let unchanged = [];
      let removed = [];
      let added = [];
      let matched2 = new Array(list2.length).fill(false);
      for (let orderObj1 of list1) {
        let found = false;
        for (let i = 0; i < list2.length; i++) {
          if (!matched2[i] && ordersAreEqual(orderObj1.parsed, list2[i].parsed)) {
            matched2[i] = true;
            unchanged.push({             //  ← NEW: remember BOTH originals
                              orig: orderObj1,           //     from the facility list
                              new : list2[i]             //     from the hospital list
                              });
            found = true;
            break;
          }
        }
        if (!found) removed.push(orderObj1);
      }
      for (let i = 0; i < list2.length; i++) {
        if (!matched2[i]) added.push(list2[i]);
      }
//=== STEP‑MERGESAME  ⬇︎ stop double‑counting identical meds =============
for (let i = removed.length - 1; i >= 0; i--) {
  const r = removed[i];
  const j = added.findIndex(a => ordersAreEqual(r.parsed, a.parsed));
  if (j !== -1) {
    unchanged.push({ orig: r, new: added[j] });
    removed.splice(i, 1);          // pull it from “removed”
    added.splice(j, 1);            // pull it from “added”
  }
}
//=== END STEP‑MERGESAME ===============================================

      return { unchanged, removed, added };
    }

    function diffRows(listA, listB) {
      const parseList = str =>
        (str || '')
          .split(/\r?\n/)
          .map(s => s.trim())
          .filter(Boolean)
          .map(line => ({ original: line, parsed: parseOrder(line) }));

      const arrA = parseList(listA);
      const arrB = parseList(listB);

      const { unchanged, removed, added } = compareOrders(arrA, arrB);

      const rows = [];
      unchanged.forEach(pair => {
        const reason = getChangeReason(pair.orig.parsed, pair.new.parsed);
        const label = reason === 'Misc. Change' ? 'Unchanged' : reason;
        rows.push({
          orig: pair.orig.original,
          new: pair.new.original,
          changes: label === 'Unchanged' ? [] : [label]
        });
      });
      removed.forEach(r => {
        rows.push({ orig: r.original, new: '', changes: ['Removed'] });
      });
      added.forEach(a => {
        rows.push({ orig: '', new: a.original, changes: ['Added'] });
      });

      rows.sort((a, b) => {
        const aUnchanged = a.changes.length === 0;
        const bUnchanged = b.changes.length === 0;
        if (aUnchanged === bUnchanged) return 0;
        return aUnchanged ? 1 : -1;
      });

      return rows;
    }

    if (typeof module !== 'undefined') module.exports.diffRows = diffRows;
    if (typeof window !== 'undefined') window.diffRows = diffRows;

    function isCriticalOrder(orderObj) {
      const text = orderObj.original.toLowerCase();
      return criticalMeds.some(med => text.includes(med));
    }

    function showScreen(screenId) {
      document.getElementById('error-message').textContent = '';
      document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
      updateProgress(screenId);
      const scroller = document.querySelector('.main-scroll');
      if (scroller) scroller.scrollTop = 0;
      window.scrollTo(0, 0);
    }

    function updateProgress(screenId) {
        // reset steps & lines
  ['step1','step2','step3','step4'].forEach(id=>{
    document.getElementById(id).classList.remove('filled','current');
  });
  ['line1-2','line2-3','line3-4'].forEach(id=>{
    document.getElementById(id).classList.remove('filled');
  });

      if (screenId === 'disclaimer-screen') {
        document.getElementById('step1').classList.add('current');
      } else if (screenId === 'photo1-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
      } else if (screenId === 'photo2-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('current');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
      } else if (screenId === 'results-screen') {
        document.getElementById('step1').classList.add('filled');
        document.getElementById('step2').classList.add('filled');
        document.getElementById('step3').classList.add('filled');
        document.getElementById('step4').classList.add('filled');
        document.getElementById('line1-2').classList.add('filled');
        document.getElementById('line2-3').classList.add('filled');
        document.getElementById('line3-4').classList.add('filled');
      }
    }

    function showLoading(msg) {
      const ld = document.getElementById('loading'),
            lt = document.getElementById('loading-text');
      ld.style.display = 'flex';
      lt.textContent = msg;
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(msg) {
      document.getElementById('error-message').textContent = msg;
    }

    // Hide upload controls after a list is finalized
    function showProcessedState(screenId) {
      const screen = document.getElementById(screenId);
      if (!screen) return;
      const h = screen.querySelector('h2');
      if (h && !h.dataset.orig) h.dataset.orig = h.textContent;
      if (h) h.textContent = 'List saved \u2014 click Compare (or Start Over)';

      screen
        .querySelectorAll('[id^="initial-"], [id^="additional-"], .text-input-container, .upload-instructions')
        .forEach(el => {
          el.style.display = 'none';
        });
    }

    function acknowledgeDisclaimer() {
      showScreen('photo1-screen');
    }

    function handlePhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
    }

    function handleAdditionalPhoto1(files) {
      if (!files || files.length === 0) return;
      photo1Files = photo1Files.concat(Array.from(files));
      if (photo1Files.length > 5) {
        photo1Files = photo1Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto1UI();
      document.getElementById('photo1-capture2').value = "";
      document.getElementById('photo1-upload2').value = "";
    }

    function updatePhoto1UI() {
  // 1) grab the “You can take a photo…” paragraph
  const instr1 = document.querySelector('#photo1-screen .upload-instructions');
  // 2) hide it as soon as you've added ≥1 photo OR used the text‐paste path
  instr1.style.display = (photo1Files.length > 0 || hasTextInput1)
    ? 'none'
    : 'block';

  // Update count & Next-button state:
  document.getElementById('photo1-status').textContent =
    photo1Files.length + (photo1Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo1-next').disabled =
    photo1Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo1-preview', photo1Files, 1);

  if (photo1Files.length > 0) {
    // Show prompt with **Next** bold:
    const prompt1 = document.getElementById('photo1-prompt');
    prompt1.style.display = 'block';
    prompt1.innerHTML =
      `Photo ${photo1Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Next</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo1-options').style.display = 'none';
    document.getElementById('additional-photo1-option').style.display = 'flex';
  } else {
    // No photos → back to start
    document.getElementById('photo1-prompt').style.display = 'none';
    document.getElementById('initial-photo1-options').style.display = 'flex';
    document.getElementById('additional-photo1-option').style.display = 'none';
  }

  // Clear file inputs so you can re-select the same file if needed:
  document.getElementById('photo1-capture').value = "";
  document.getElementById('photo1-upload').value = "";
}

    function handlePhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
    }

    function handleAdditionalPhoto2(files) {
      if (!files || files.length === 0) return;
      photo2Files = photo2Files.concat(Array.from(files));
      if (photo2Files.length > 5) {
        photo2Files = photo2Files.slice(0,5);
        showError("Maximum of 5 photos allowed for this step.");
      } else {
        showError("");
      }
      updatePhoto2UI();
      document.getElementById('photo2-capture2').value = "";
      document.getElementById('photo2-upload2').value = "";
    }

    function updatePhoto2UI() {
    // 1) grab the “You can take a photo…” paragraph on screen 2
  const instr2 = document.querySelector('#photo2-screen .upload-instructions');
  // 2) hide it as soon as you've added ≥1 photo OR used the paste path
  instr2.style.display = (photo2Files.length > 0 || hasTextInput2)
    ? 'none'
    : 'block';

  // Update count & Compare-button state:
  document.getElementById('photo2-status').textContent =
    photo2Files.length + (photo2Files.length === 1
      ? " photo added."
      : " photos added.");
  document.getElementById('photo2-compare').disabled =
    photo2Files.length === 0;

  // Refresh thumbnails:
  updatePreview('photo2-preview', photo2Files, 2);

  if (photo2Files.length > 0) {
    // Show prompt with **Compare** bold:
    const prompt2 = document.getElementById('photo2-prompt');
    prompt2.style.display = 'block';
    prompt2.innerHTML =
      `Photo ${photo2Files.length} of 5 added. ` +
      `Add another photo (up to 5) to complete your list, or click ` +
      `<strong>Compare</strong> to continue.`;

    // Swap out buttons:
    document.getElementById('initial-photo2-options').style.display = 'none';
    document.getElementById('additional-photo2-option').style.display = 'flex';
  } else {
    // No photos → back to start
    document.getElementById('photo2-prompt').style.display = 'none';
    document.getElementById('initial-photo2-options').style.display = 'flex';
    document.getElementById('additional-photo2-option').style.display = 'none';
  }

  // Clear file inputs
  document.getElementById('photo2-capture').value = "";
  document.getElementById('photo2-upload').value = "";
}

    function updatePreview(previewId, files, listNumber) {
      const container = document.getElementById(previewId);
      container.innerHTML = "";
      files.forEach((file, index) => {
        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.className = 'thumbnail-container';
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '<span class="material-icons">close</span>';
        deleteBtn.onclick = () => deletePhoto(listNumber, index);
        thumbnailDiv.appendChild(img);
        thumbnailDiv.appendChild(deleteBtn);
        container.appendChild(thumbnailDiv);
      });
    }

    function deletePhoto(listNumber, index) {
      if (listNumber === 1) {
        photo1Files.splice(index, 1);
        updatePhoto1UI();
      } else if (listNumber === 2) {
        photo2Files.splice(index, 1);
        updatePhoto2UI();
      }
    }

    function handleTextInput1() {
  const rawPastedText = document.getElementById('photo1-text-input').value; // Get raw text
  if (!rawPastedText.trim()) {
    showError('Please paste a medication list before submitting.');
    return;
  }
  document.getElementById('photo1-status').textContent = 'Processing pasted list...';
  hasTextInput1 = true;

  // Use keepOrderLines to process the pasted text.
  // keepOrderLines handles splitting, cleaning, merging (including EMR), and filtering.
  let processedOrderStrings = keepOrderLines(rawPastedText);

  console.log('handleTextInput1 - Processed Order Strings by keepOrderLines:', processedOrderStrings);

  if (processedOrderStrings.length === 0) {
    showError('No valid medication orders detected in the pasted list. Please try again.');
    document.getElementById('photo1-status').textContent = 'No orders found.';
    hasTextInput1 = false; // Reset if no orders found
    return;
  }

  meds1 = processedOrderStrings.map(medStr => {
    try {
      const parsed = parseOrder(medStr); // parseOrder gets a hopefully complete string
      if (!parsed || typeof parsed !== 'object') {
        console.warn('Parse failed for (handleTextInput1):', medStr, 'returning default object');
        return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
      }
      return { original: medStr, parsed: parsed };
    } catch (e) {
      console.error('Error parsing line (handleTextInput1):', medStr, e.stack || e);
      return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
    }
  });

  console.log('handleTextInput1 - Meds1 (parsed objects):', meds1);
  document.getElementById('photo1-status').textContent = 'List processed. Proceeding to second list...';
  document.getElementById('initial-photo1-options').style.display = 'none';
  document.getElementById('additional-photo1-option').style.display = 'none';
  document.getElementById('photo1-preview').innerHTML = "";
  photo1Files = [];
  document.getElementById('photo1-prompt').style.display = 'none';
  showError('');
  showProcessedState('photo1-screen');
  showScreen('photo2-screen');
}

    function handleTextInput2() {
  const rawPastedText = document.getElementById('photo2-text-input').value; // Get raw text
  if (!rawPastedText.trim()) {
    showError('Please paste a medication list before submitting.');
    return;
  }
  document.getElementById('photo2-status').textContent = 'Processing pasted list...';
  hasTextInput2 = true;

  // Use keepOrderLines to process the pasted text.
  let processedOrderStrings = keepOrderLines(rawPastedText);

  console.log('handleTextInput2 - Processed Order Strings by keepOrderLines:', processedOrderStrings);

  if (processedOrderStrings.length === 0) {
    showError('No valid medication orders detected in the pasted list. Please try again.');
    document.getElementById('photo2-status').textContent = 'No orders found.';
    hasTextInput2 = false; // Reset if no orders found
    return;
  }

  meds2 = processedOrderStrings.map(medStr => {
    try {
      const parsed = parseOrder(medStr);
      if (!parsed || typeof parsed !== 'object') {
        console.warn('Parse failed for (handleTextInput2):', medStr, 'returning default object');
        return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
      }
      return { original: medStr, parsed: parsed };
    } catch (e) {
      console.error('Error parsing line (handleTextInput2):', medStr, e.stack || e);
      return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
    }
  });

  console.log('handleTextInput2 - Meds2 (parsed objects):', meds2);
  document.getElementById('photo2-status').textContent = '';
  document.getElementById('photo2-compare').disabled = false; // Enable compare button
  document.getElementById('initial-photo2-options').style.display = 'none';
  document.getElementById('additional-photo2-option').style.display = 'none'; // Usually, after text input, we don't add more photos for that list.
  document.getElementById('photo2-preview').innerHTML = "";
  photo2Files = [];
  document.getElementById('photo2-prompt').style.display = 'block';
  document.getElementById('photo2-prompt').innerHTML = 'Ready — click <strong>Compare</strong> to continue, or Start Over.';
  showError('');
  showProcessedState('photo2-screen');
}

    async function goToPhoto2() {
      if (!hasTextInput1 && (!photo1Files || photo1Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput1) {
        showLoading('Processing first image(s)...');
        try {
      // processFiles now returns an array of fully processed order strings
      let processedOrderStrings = await processFiles(photo1Files);

      console.log('goToPhoto2 - Processed Order Strings from OCR:', processedOrderStrings);

      if (processedOrderStrings.length === 0) {
        hideLoading();
        showError('No valid medication orders detected in the first photos. Please try again.');
        return;
      }

      meds1 = processedOrderStrings.map(medStr => {
        try {
          const parsed = parseOrder(medStr);
          if (!parsed || typeof parsed !== 'object') {
            console.warn('Parse failed for (goToPhoto2 OCR):', medStr, 'returning default object');
            return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
          }
          return { original: medStr, parsed: parsed };
        } catch (e) {
          console.error('Error parsing line (goToPhoto2 OCR):', medStr, e.stack || e);
          return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
        }
      });

      console.log('goToPhoto2 - Meds1 (parsed objects from OCR):', meds1);
      hideLoading();
      showProcessedState('photo1-screen');
      showScreen('photo2-screen');
    } catch (err) { // This catch is for errors from processFiles or the mapping
      console.error('Error in goToPhoto2 OCR processing:', err);
      hideLoading();
      showError('Error processing text from the first photos. Please try again.');
    }
      }
    }

    async function comparePhotos() {
      if (!hasTextInput2 && (!photo2Files || photo2Files.length === 0)) {
        showError('Please select at least one photo or submit a medication list.');
        return;
      }
      if (!hasTextInput2) {
        showLoading('Processing second image(s)...');
        try {
      // processFiles now returns an array of fully processed order strings
      let processedOrderStrings = await processFiles(photo2Files);

      console.log('comparePhotos - Processed Order Strings from OCR:', processedOrderStrings);

      if (processedOrderStrings.length === 0) {
        hideLoading();
        showError('No valid medication orders detected in the second photos. Please try again.');
        return;
      }

      meds2 = processedOrderStrings.map(medStr => {
        try {
          const parsed = parseOrder(medStr);
          if (!parsed || typeof parsed !== 'object') {
            console.warn('Parse failed for (comparePhotos OCR):', medStr, 'returning default object');
            return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
          }
          return { original: medStr, parsed: parsed };
        } catch (e) {
          console.error('Error parsing line (comparePhotos OCR):', medStr, e.stack || e);
          return { original: medStr, parsed: { drug: medStr, dose: { value: null, unit: '', total: null }, route: '', frequency: '', prn: false, startDate: '', form: '', indication: '' } };
        }
      });

      console.log('comparePhotos - Meds2 (parsed objects from OCR):', meds2);
      hideLoading();
      showProcessedState('photo2-screen');
      compareAndShowResults();
    } catch (err) { // This catch is for errors from processFiles or the mapping
      console.error('Error in comparePhotos OCR processing:', err);
      hideLoading();
      showError('Error processing text from the second photos. Please try again.');
    }
      } else {
        compareAndShowResults();
      }
    }

// === CORE‑DRUG helper (global) ===
const coreDrugName = n => (n || '')
  .toLowerCase()

    /* 1. salts / formulations */
  .replace(/\b(?:sodium|calcium|acetate|phosphate|carbonate|hydrochloride|succinate|tartrate|gluconate|anhydrous|choline|modified)\b/gi, '')
  // Specific handling for potassium/chloride to avoid removing them if they are the drug name
  .replace(/\bpotassium\b/gi, (match, offset, str) => {
      const s = str.toLowerCase();
      return (s.startsWith("potassium chloride") || s.startsWith("potassium citrate") || s.startsWith("potassium phosphate")) ? match : '';
  })
  .replace(/\bchloride\b/gi, (match, offset, str) => {
      const s = str.toLowerCase();
      return (s.includes("potassium chloride") || s.includes("sodium chloride")) ? match : '';
  })

   /* 2. dosage-form words */
  .replace(/\b(?:tab|tabs?|tablet|tablets?|cap|caps?|capsule|capsules?|caplet|patch|patches|puff|puffs|drop|drops|spray|sprays|lozenge|suppository|solution|suspension|ointment|cream|gel|inhaler|inhalation|neb|mdi|dpi)\b/gi, '')

  /* 3. scheduling words */
  .replace(/\b(?:daily|nightly|morning|evening|bedtime|qam|qpm|qhs|am|pm|q\d+h)\b/gi, '')
  
  /* 3b. stray numbers */
  .replace(/\b\d+\b/g, '')

  /* 4. punctuation / extra spaces */
  .replace(/[^a-z0-9\s/-]+/g, ' ')
  .replace(/\s+/g, ' ')
  .trim();

function compareAndShowResults() {
    let { unchanged, removed, added } = compareOrders(meds1, meds2);
        
//=== STEP-MERGE-REMOVED-ADDED (enhanced) ======================
const merged = [];
const addedMap = Object.create(null);

// --- START DEBUG LOGS FOR addedMap POPULATION ---
console.log("--- Building addedMap (Primary Merge Step) ---");
added.forEach(a => {
  const originalDrugString = a.original; // For logging
  const parsedDrugField = a.parsed.drug;
  // Use the first word of the normalized generic name as the primary key
  const primaryKey = normalizeMedicationName(parsedDrugField).name.split(' ')[0].trim();
  if (primaryKey) { // Ensure the key is not empty
      console.log(`  [addedMap]: Adding: Original Str: "<span class="math-inline">\{originalDrugString\}" \-\-\> Parsed Drug\: "</span>{parsedDrugField}" --> Primary Key: "${primaryKey}"`);
      addedMap[primaryKey] = a;
  } else {
      console.log(`  [addedMap]: SKIPPING ADD due to empty primaryKey. Original Str: "<span class="math-inline">\{originalDrugString\}", Parsed Drug\: "</span>{parsedDrugField}"`);
  }
});

console.log("--- Finished building addedMap. Keys: ", Object.keys(addedMap));
console.log("addedMap after build:", addedMap);
// --- END DEBUG LOGS FOR addedMap POPULATION ---

// --- START DEBUG LOGS FOR removed.filter (Primary Merge Step) ---
console.log("--- Filtering 'removed' list (Primary Merge Step) ---");
removed = removed.filter(r => {
  const originalRemovedDrugString = r.original;
  const parsedRemovedDrugField    = r.parsed.drug;

  // Use the first word of the normalized generic name for lookup
  const primaryLookupKey = normalizeMedicationName(parsedRemovedDrugField).name.split(' ')[0].trim();
  let match = undefined;
  let usedKey = "";

  if (primaryLookupKey) {
      console.log(
        `  [removed.filter]: Processing Removed: "<span class="math-inline">\{originalRemovedDrugString\}" → drug\="</span>{parsedRemovedDrugField}" → Primary Lookup Key: "${primaryLookupKey}"`
      );
      match = addedMap[primaryLookupKey];
      usedKey = primaryLookupKey;
  } else {
      console.log(
        `  [removed.filter]: SKIPPING LOOKUP due to empty primaryLookupKey for Removed: "<span class="math-inline">\{originalRemovedDrugString\}", Parsed Drug\: "</span>{parsedRemovedDrugField}"`
      );
  }

  if (!match) {
    console.log(`     NO MATCH for Primary Lookup Key: "${primaryLookupKey}" → keep in removed`);
    return true; // Keep in removed if no match
  }

  if (!match) {
    console.log(`    NO MATCH for either "${lookupKey}" or "${usedKey}" → keep in removed`);
    return true;
  }

  console.log(
    `    MATCH FOUND for key "${usedKey}" (merged with added original="${match.original}")`
  );
 
// Determine the reason using the comprehensive getChangeReason function,
// which now correctly accumulates multiple changes.
const reason = getChangeReason(r.parsed, match.parsed);

merged.push({ orig: r, new: match, reason });

    // purge every key in addedMap that still points to this matched entry:
  Object.keys(addedMap).forEach(k => {
    if (addedMap[k] === match) {
      delete addedMap[k];
    }
  });

  return false;
});

console.log("--- Finished filtering 'removed' list ---");

added = Object.values(addedMap);
console.log("Remaining addedMap keys (will appear as ‘Added’ rows):", Object.keys(addedMap));

//=== END STEP-MERGE-REMOVED-ADDED ==============================

//=== STEP‑FIX  skip any blank or junk entries =========================
const notBlank = obj =>
  obj && obj.original && obj.original.trim().length > 0;

unchanged = unchanged.filter(pair => notBlank(pair.orig) && notBlank(pair.new));
removed   = removed  .filter(notBlank);
added     = added    .filter(notBlank);
//=== END STEP‑FIX ======================================================

// ---------------------------------------------
//  CI scan **only** on the ACTIVE (hospital) list
// ---------------------------------------------
const activeOrders =
      meds2
      .concat( unchanged.map(p => p.new) );

const ciAlerts = findContraIndications(activeOrders);

/* build a highlight-set containing BOTH
   the raw names *and* their stripped cores */
const ciSet = new Set(
  ciAlerts.flatMap(w => {
    return [
      w.a,              // e.g. "simvastatin"
      w.b,              // e.g. "ketoconazole"
      coreDrugName(w.a),// e.g. "simvastatin"
      coreDrugName(w.b) // e.g. "ketoconazole"
    ];
  })
);

const finalResults = [];

// ---------------------------------------------

    // Process removed orders (potential changes or removals)

// ‑‑‑ FIRST: show the neatly‑merged pairs ‑‑‑
merged.forEach(pair => {
  finalResults.push({
    orig: pair.orig,
    new: pair.new,
    label: pair.reason,
    critical: isCriticalOrder(pair.new) && pair.reason !== 'Unchanged',
    ci: ciSet.has(coreDrugName(pair.orig.parsed.drug)) ||
        ciSet.has(coreDrugName(pair.new.parsed.drug)),
    changes: pair.reason === 'Unchanged' ? [] : [pair.reason]
  });
});
    
removed.forEach(r => {
        console.group(`🔍 Comparing removed: ${r.original}`);
        console.log('   current added[]:', added.map(a => a.original));
        const lowerRem = r.original.toLowerCase();
        let match = null;
        let changeType = null;

        // 1) Brand → generic?
        const brandKey = Object.keys(brandToGenericMap).find(b => lowerRem.includes(b));
        if (brandKey) {
            changeType = 'Generic Medication';
            const gen = brandToGenericMap[brandKey];
            match = added.find(a => normalizeMedicationName(a.parsed.drug).name === gen);
        }

        // 2) Generic → brand?
        if (!match) {
            const genKey = normalizeMedicationName(r.parsed.drug).name;
            const brandList = genericToBrandMap[genKey] || [];
            for (let brand of brandList) {
                const regex = new RegExp(`\\b${brand}\\b`, 'i');
                const found = added.find(a => regex.test(a.original));
                if (found) {
                    changeType = 'Brand Medication';
                    match = found;
                    break;
                }
            }
        }

        // 3) Substring match (fallback, less precise)
if (!match) {
    const drugName = r.parsed.drug.toLowerCase();
    match = added.find(a => a.original.toLowerCase().includes(drugName));
    if (match) {
        changeType = getChangeReason(r.parsed, match.parsed);
        console.log(`   → substring matched "${drugName}" to`, match.original);
    }
}  // <-- closes the if(!match) block correctly

        const crit = false;         // removed orders aren’t active any more

           // 4) Brand ↔ generic swap (also catch an indication tweak)
   if (match && (changeType === 'Generic Medication' || changeType === 'Brand Medication')) {
     // build a list of reasons
     const reasons = [ changeType ];
     const ind1 = normalizeIndicationText((r.parsed.indication || '').toLowerCase().trim());
     const ind2 = normalizeIndicationText((match.parsed.indication || '').toLowerCase().trim());
     if (ind1 !== ind2) {
       reasons.push('Indication changed');
     }
            finalResults.push({
              orig: r,
              new: match,
              label: reasons.join(', '),
              critical: false,
              ci: ciSet.has(coreDrugName(r.parsed.drug)) ||
                  (match && ciSet.has(coreDrugName(match.parsed.drug))),
              changes: reasons
            });
     added = added.filter(a => a !== match);
     console.groupEnd();
     return;
   }

        // 5) Dose / freq / form / route / PRN / admin reasons
        if (match) {
            // Use getChangeReason to determine the specific change
            const reason = getChangeReason(r.parsed, match.parsed);
            finalResults.push({
                orig: r,
                new: match,
                label: reason,
                critical: crit,
                ci: false,
                changes: reason === 'Unchanged' ? [] : [reason]
            });
            added = added.filter(a => a !== match);
            console.groupEnd();
            return;
        }

        // 6) Same-drug match
        const sameDrug = added.find(a =>
            normalizeMedicationName(a.parsed.drug).name === normalizeMedicationName(r.parsed.drug).name
        );
        if (sameDrug) {
            const reason = getChangeReason(r.parsed, sameDrug.parsed);
            finalResults.push({
                orig: r,
                new: sameDrug,
                label: reason,
                critical: crit,
                ci: false,
                changes: reason === 'Unchanged' ? [] : [reason]
            });
            added = added.filter(a => a !== sameDrug);
            console.groupEnd();
            return;
        }

        // 7) Pure removal
        finalResults.push({
            orig: r,
            new: null,
            label: 'Removed',
            critical: crit,
            ci: false,
            changes: ['Removed']
        });
        console.groupEnd();
    });

    // Unchanged ‑‑→ now re‑evaluate for brand/generic etc.
    unchanged.forEach(u => {
       const reason = getChangeReason(u.orig.parsed, u.new.parsed);
       const label  = (reason === 'Misc. Change') ? 'Unchanged' : reason;

       finalResults.push({
         orig: u.orig,
         new: u.new,
         label,
         critical: label !== 'Unchanged' && (isCriticalOrder(u.orig) || isCriticalOrder(u.new)),
         ci: ciSet.has(coreDrugName(u.orig.parsed.drug)) ||
             ciSet.has(coreDrugName(u.new.parsed.drug)),
         changes: label === 'Unchanged' ? [] : [label]
       });
      });

        // Added orders
    added.forEach(a => {
      const crit = isCriticalOrder(a);
      finalResults.push({
        orig: null,
        new: a,
        label: 'Added',
        critical: crit,
        ci: ciSet.has(coreDrugName(a.parsed.drug)),
        changes: ['Added']
      });
    });

    finalResults.sort((a, b) => {
      const aUnchanged = (a.changes?.length === 0);
      const bUnchanged = (b.changes?.length === 0);
      if (aUnchanged === bUnchanged) return 0;
      return aUnchanged ? 1 : -1;
    });

    let html = `
        <table class="changes-table">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Original Order (Facility)</th>
                    <th>New Order (Hospital)</th>
                    <th>Suspected Change</th>
                </tr>
            </thead>
            <tbody>`;

    finalResults.forEach((row, i) => {
      html += `
        <tr class="${row.critical ? 'critical' : ''} ${row.ci ? 'ci-row' : ''}">
          <td>${i + 1}</td>
          <td>${row.orig ? row.orig.original : ''}</td>
          <td>${row.new ? row.new.original : ''}</td>
          <td>${row.label}</td>
        </tr>`;
    });

    html += `
            </tbody>
        </table>
    `;

    // ─── Append CI block below the table ───
    if (ciAlerts.length) {
      html += `
        <h3 style="margin-top:1.5rem; color: red; font-weight: bold;">
      Potential Contraindications
    </h3>
        <ul>
          ${ciAlerts.map(w =>
            `<li><strong>${w.a}</strong> should NOT be used with <strong>${w.b}</strong></li>`
          ).join('')}
        </ul>
        <p style="font-size:0.85rem;">
          These flags are a quick screen and do <em>not</em> replace clinical judgment.
        </p>
      `;
    }

    document.getElementById('results-content').innerHTML = html;
   
 // make the current CI list available for exportToPDF()
    window.currentContraAlerts = ciAlerts;

    showScreen('results-screen');
}

    async function exportToPDF() {
  // 1) grab your table
  const table = document.querySelector('.changes-table');
  // 2) init jsPDF
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });

  // 3) optional: add a title
  pdf.setFontSize(14);
  pdf.text('Comparison Results', 40, 40);

  // 4) render the table with AutoTable
  pdf.autoTable({
    html: table,
    startY: 60,
    theme: 'grid',
    headStyles: { fillColor: [240,240,240] },
    styles: {
      fontSize: 9,
      cellPadding: 4,
      overflow: 'linebreak'
    },
    // ensure no row ever splits across pages:
    pageBreak: 'avoid',
    didDrawPage: (data) => {
      // here you could add page numbers, headers, etc.
    }
  });

  // ——— Draw the CI header & list below the table ———
  const finalY = pdf.lastAutoTable.finalY + 20;
  if (window.currentContraAlerts?.length) {
    // 1) Section title
    pdf.setFontSize(12);
    pdf.text("Potential Contra-Indications", 40, finalY);

    // 2) Each warning item
    pdf.setFontSize(10);
    window.currentContraAlerts.forEach((w, i) => {
      pdf.text(
        `• ${w.a} should NOT be used with ${w.b}`,
        40,
        finalY + 15 + i * 12
      );
    });

    // 3) Footnote
    pdf.setFontSize(9);
    pdf.text(
      "These flags are a quick screen and do not replace clinical judgment.",
      40,
      finalY + 15 + window.currentContraAlerts.length * 12 + 10
    );
  }

  // 5) save the PDF
  pdf.save('MedRec_Report.pdf');
}

function printResults() {
  // 1) make sure we’re on the results screen
  showScreen('results-screen');

  // 2) give the browser a moment to apply your @media print CSS
  setTimeout(() => {
    window.print();
  }, 100);
}

    function startOver() {
      document.querySelectorAll('[data-orig]').forEach(h => {
        h.textContent = h.dataset.orig;
      });

      ['photo1-screen','photo2-screen'].forEach(id => {
        const s = document.getElementById(id);
        if (!s) return;
        s.querySelectorAll('[id^="initial-"]').forEach(el => el.style.display = 'flex');
        s.querySelectorAll('[id^="additional-"]').forEach(el => el.style.display = 'none');
        s.querySelectorAll('.text-input-container').forEach(el => el.style.display = 'flex');
        s.querySelectorAll('.upload-instructions').forEach(el => el.style.display = 'block');
      });
      photo1Files = [];
      photo2Files = [];
      meds1 = [];
      meds2 = [];
      hasTextInput1 = false;
      hasTextInput2 = false;
      document.getElementById('photo1-capture').value = '';
      document.getElementById('photo1-upload').value = '';
      document.getElementById('photo1-capture2').value = '';
      document.getElementById('photo1-upload2').value = '';
      document.getElementById('photo2-capture').value = '';
      document.getElementById('photo2-upload').value = '';
      document.getElementById('photo2-capture2').value = '';
      document.getElementById('photo2-upload2').value = '';
      document.getElementById('photo1-text-input').value = '';
      document.getElementById('photo2-text-input').value = '';
      document.getElementById('photo1-status').textContent = '';
      document.getElementById('photo2-status').textContent = '';
      document.getElementById('photo1-next').disabled = true;
      document.getElementById('photo2-compare').disabled = true;
      document.getElementById('results-content').innerHTML = '';
      document.getElementById('photo1-preview').innerHTML = "";
      document.getElementById('photo2-preview').innerHTML = "";
      document.getElementById('photo1-prompt').style.display = 'none';
      document.getElementById('initial-photo1-options').style.display = 'flex';
      document.getElementById('additional-photo1-option').style.display = 'none';
      document.getElementById('photo2-prompt').style.display = 'none';
      document.getElementById('initial-photo2-options').style.display = 'flex';
      document.getElementById('additional-photo2-option').style.display = 'none';
      showScreen('disclaimer-screen');
    }

    // Tooltip toggle for mobile
    document.querySelectorAll('.tooltip').forEach(tooltip => {
      tooltip.addEventListener('click', (e) => {
        e.stopPropagation();
        const isActive = tooltip.classList.contains('active');
        document.querySelectorAll('.tooltip').forEach(t => t.classList.remove('active'));
        if (!isActive) {
          tooltip.classList.add('active');
        }
      });
    });

    document.addEventListener('click', () => {
      document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.classList.remove('active');
      });
    });

    document.addEventListener('DOMContentLoaded', () => {
      hideLoading();
      updateProgress('disclaimer-screen');
    });
  </script>

</body>
</html>
